package clAmsMgmtClientApi;
import com.sun.jna.Callback;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.Pointer;
import com.sun.jna.PointerType;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.LongByReference;
import com.sun.jna.ptr.PointerByReference;
import com.sun.jna.ptr.ShortByReference;
import com.sun.jna.ptr.ByteByReference;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import java.nio.LongBuffer;
import java.nio.ShortBuffer;
import clUtils.ClUtilsLibrary;
import clUtils.ClUtilsLibrary.*;
/**
 * JNA Wrapper for library <b>ClAmsMgmt</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface ClAmsMgmtLibrary extends Library {
	public static final String JNA_LIBRARY_NAME = "ClAmsMgmt";
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(ClAmsMgmtLibrary.JNA_LIBRARY_NAME);
	public static final ClAmsMgmtLibrary INSTANCE = (ClAmsMgmtLibrary)Native.load(ClAmsMgmtLibrary.JNA_LIBRARY_NAME, ClAmsMgmtLibrary.class);
	/**
	 * <i>native declaration : clAmsTypes.h</i><br>
	 * enum values
	 */
	public static interface ClAmsMgmtStateT {
		/** <i>native declaration : clAmsTypes.h:15</i> */
		public static final int CL_AMS_MGMT_STATE_NONE = 0;
		/** <i>native declaration : clAmsTypes.h:16</i> */
		public static final int CL_AMS_MGMT_STATE_DISABLED = 1;
		/** <i>native declaration : clAmsTypes.h:17</i> */
		public static final int CL_AMS_MGMT_STATE_ENABLED = 2;
	};
	/**
	 * <i>native declaration : clAmsTypes.h</i><br>
	 * enum values
	 */
	public static interface ClAmsAdminStateT {
		/** <i>native declaration : clAmsTypes.h:29</i> */
		public static final int CL_AMS_ADMIN_STATE_NONE = 0;
		/** <i>native declaration : clAmsTypes.h:30</i> */
		public static final int CL_AMS_ADMIN_STATE_UNLOCKED = 1;
		/** <i>native declaration : clAmsTypes.h:31</i> */
		public static final int CL_AMS_ADMIN_STATE_LOCKED_A = 2;
		/** <i>native declaration : clAmsTypes.h:32</i> */
		public static final int CL_AMS_ADMIN_STATE_LOCKED_I = 3;
		/** <i>native declaration : clAmsTypes.h:33</i> */
		public static final int CL_AMS_ADMIN_STATE_SHUTTINGDOWN = 4;
		/** <i>native declaration : clAmsTypes.h:34</i> */
		public static final int CL_AMS_ADMIN_STATE_MAX = 5;
	};
	/**
	 * <i>native declaration : clAmsTypes.h</i><br>
	 * enum values
	 */
	public static interface ClAmsPresenceStateT {
		/** <i>native declaration : clAmsTypes.h:45</i> */
		public static final int CL_AMS_PRESENCE_STATE_NONE = 0;
		/** <i>native declaration : clAmsTypes.h:46</i> */
		public static final int CL_AMS_PRESENCE_STATE_UNINSTANTIATED = 1;
		/** <i>native declaration : clAmsTypes.h:47</i> */
		public static final int CL_AMS_PRESENCE_STATE_INSTANTIATING = 2;
		/** <i>native declaration : clAmsTypes.h:48</i> */
		public static final int CL_AMS_PRESENCE_STATE_INSTANTIATED = 3;
		/** <i>native declaration : clAmsTypes.h:49</i> */
		public static final int CL_AMS_PRESENCE_STATE_TERMINATING = 4;
		/** <i>native declaration : clAmsTypes.h:50</i> */
		public static final int CL_AMS_PRESENCE_STATE_RESTARTING = 5;
		/** <i>native declaration : clAmsTypes.h:51</i> */
		public static final int CL_AMS_PRESENCE_STATE_INSTANTIATION_FAILED = 6;
		/** <i>native declaration : clAmsTypes.h:52</i> */
		public static final int CL_AMS_PRESENCE_STATE_TERMINATION_FAILED = 7;
		/** <i>native declaration : clAmsTypes.h:56</i> */
		public static final int CL_AMS_PRESENCE_STATE_ABSENT = 0;
		/** <i>native declaration : clAmsTypes.h:57</i> */
		public static final int CL_AMS_PRESENCE_STATE_FAULT = 8;
		/** <i>native declaration : clAmsTypes.h:58</i> */
		public static final int CL_AMS_PRESENCE_STATE_FAULT_WTC = 9;
		/** <i>native declaration : clAmsTypes.h:59</i> */
		public static final int CL_AMS_PRESENCE_STATE_FAULT_WTR = 10;
	};
	/**
	 * <i>native declaration : clAmsTypes.h</i><br>
	 * enum values
	 */
	public static interface ClAmsOperStateT {
		/** <i>native declaration : clAmsTypes.h:69</i> */
		public static final int CL_AMS_OPER_STATE_NONE = 0;
		/** <i>native declaration : clAmsTypes.h:70</i> */
		public static final int CL_AMS_OPER_STATE_ENABLED = 1;
		/** <i>native declaration : clAmsTypes.h:71</i> */
		public static final int CL_AMS_OPER_STATE_DISABLED = 2;
	};
	/**
	 * <i>native declaration : clAmsTypes.h</i><br>
	 * enum values
	 */
	public static interface ClAmsHAStateT {
		/** <i>native declaration : clAmsTypes.h:81</i> */
		public static final int CL_AMS_HA_STATE_NONE = 0;
		/** <i>native declaration : clAmsTypes.h:82</i> */
		public static final int CL_AMS_HA_STATE_ACTIVE = 1;
		/** <i>native declaration : clAmsTypes.h:83</i> */
		public static final int CL_AMS_HA_STATE_STANDBY = 2;
		/** <i>native declaration : clAmsTypes.h:84</i> */
		public static final int CL_AMS_HA_STATE_QUIESCED = 3;
		/** <i>native declaration : clAmsTypes.h:85</i> */
		public static final int CL_AMS_HA_STATE_QUIESCING = 4;
	};
	/**
	 * <i>native declaration : clAmsTypes.h</i><br>
	 * enum values
	 */
	public static interface ClAmsReadinessStateT {
		/** <i>native declaration : clAmsTypes.h:96</i> */
		public static final int CL_AMS_READINESS_STATE_NONE = 0;
		/** <i>native declaration : clAmsTypes.h:97</i> */
		public static final int CL_AMS_READINESS_STATE_OUTOFSERVICE = 1;
		/** <i>native declaration : clAmsTypes.h:98</i> */
		public static final int CL_AMS_READINESS_STATE_INSERVICE = 2;
		/** <i>native declaration : clAmsTypes.h:99</i> */
		public static final int CL_AMS_READINESS_STATE_STOPPING = 3;
	};
	/**
	 * <i>native declaration : clAmsTypes.h</i><br>
	 * enum values
	 */
	public static interface ClAmsServiceStateT {
		/** <i>native declaration : clAmsTypes.h:109</i> */
		public static final int CL_AMS_SERVICE_STATE_NONE = 0;
		/** <i>native declaration : clAmsTypes.h:110</i> */
		public static final int CL_AMS_SERVICE_STATE_RUNNING = 1;
		/** <i>native declaration : clAmsTypes.h:111</i> */
		public static final int CL_AMS_SERVICE_STATE_STOPPED = 2;
		/** <i>native declaration : clAmsTypes.h:112</i> */
		public static final int CL_AMS_SERVICE_STATE_STARTINGUP = 3;
		/** <i>native declaration : clAmsTypes.h:113</i> */
		public static final int CL_AMS_SERVICE_STATE_SHUTTINGDOWN = 4;
		/** <i>native declaration : clAmsTypes.h:114</i> */
		public static final int CL_AMS_SERVICE_STATE_UNAVAILABLE = 5;
		/** <i>native declaration : clAmsTypes.h:115</i> */
		public static final int CL_AMS_SERVICE_STATE_HOT_STANDBY = 6;
	};
	/**
	 * <i>native declaration : clAmsTypes.h</i><br>
	 * enum values
	 */
	public static interface ClAmsNodeClassT {
		/** <i>native declaration : clAmsTypes.h:129</i> */
		public static final int CL_AMS_NODE_CLASS_NONE = 0;
		/** <i>native declaration : clAmsTypes.h:130</i> */
		public static final int CL_AMS_NODE_CLASS_A = 1;
		/** <i>native declaration : clAmsTypes.h:131</i> */
		public static final int CL_AMS_NODE_CLASS_B = 2;
		/** <i>native declaration : clAmsTypes.h:132</i> */
		public static final int CL_AMS_NODE_CLASS_C = 3;
		/** <i>native declaration : clAmsTypes.h:133</i> */
		public static final int CL_AMS_NODE_CLASS_D = 4;
		/** <i>native declaration : clAmsTypes.h:134</i> */
		public static final int CL_AMS_NODE_CLASS_MAX = 5;
	};
	/**
	 * <i>native declaration : clAmsTypes.h</i><br>
	 * enum values
	 */
	public static interface ClAmsNodeClusterMemberT {
		/** <i>native declaration : clAmsTypes.h:143</i> */
		public static final int CL_AMS_NODE_IS_NOT_CLUSTER_MEMBER = 0;
		/** <i>native declaration : clAmsTypes.h:144</i> */
		public static final int CL_AMS_NODE_IS_CLUSTER_MEMBER = 1;
		/** <i>native declaration : clAmsTypes.h:145</i> */
		public static final int CL_AMS_NODE_IS_LEAVING_CLUSTER = 2;
	};
	/**
	 * <i>native declaration : clAmsTypes.h</i><br>
	 * enum values
	 */
	public static interface ClAmsSGRedundancyModelT {
		/** <i>native declaration : clAmsTypes.h:164</i> */
		public static final int CL_AMS_SG_REDUNDANCY_MODEL_NONE = 0;
		/** <i>native declaration : clAmsTypes.h:165</i> */
		public static final int CL_AMS_SG_REDUNDANCY_MODEL_NO_REDUNDANCY = 1;
		/** <i>native declaration : clAmsTypes.h:166</i> */
		public static final int CL_AMS_SG_REDUNDANCY_MODEL_TWO_N = 2;
		/** <i>native declaration : clAmsTypes.h:167</i> */
		public static final int CL_AMS_SG_REDUNDANCY_MODEL_M_PLUS_N = 3;
		/** <i>native declaration : clAmsTypes.h:168</i> */
		public static final int CL_AMS_SG_REDUNDANCY_MODEL_N_WAY = 4;
		/** <i>native declaration : clAmsTypes.h:169</i> */
		public static final int CL_AMS_SG_REDUNDANCY_MODEL_N_WAY_ACTIVE = 5;
		/**
		 * user controlled redundancy mode<br>
		 * <i>native declaration : clAmsTypes.h:170</i>
		 */
		public static final int CL_AMS_SG_REDUNDANCY_MODEL_CUSTOM = 6;
		/** <i>native declaration : clAmsTypes.h:171</i> */
		public static final int CL_AMS_SG_REDUNDANCY_MODEL_MAX = 7;
	};
	/**
	 * <i>native declaration : clAmsTypes.h</i><br>
	 * enum values
	 */
	public static interface ClAmsSGLoadingStrategyT {
		/**
		 * invalid<br>
		 * <i>native declaration : clAmsTypes.h:219</i>
		 */
		public static final int CL_AMS_SG_LOADING_STRATEGY_NONE = 0;
		/**
		 * all models<br>
		 * <i>native declaration : clAmsTypes.h:220</i>
		 */
		public static final int CL_AMS_SG_LOADING_STRATEGY_LEAST_SI_PER_SU = 1;
		/**
		 * all models<br>
		 * <i>native declaration : clAmsTypes.h:221</i>
		 */
		public static final int CL_AMS_SG_LOADING_STRATEGY_LEAST_SU_ASSIGNED = 2;
		/**
		 * all models<br>
		 * <i>native declaration : clAmsTypes.h:222</i>
		 */
		public static final int CL_AMS_SG_LOADING_STRATEGY_LEAST_LOAD_PER_SU = 3;
		/**
		 * n-way-* only<br>
		 * <i>native declaration : clAmsTypes.h:223</i>
		 */
		public static final int CL_AMS_SG_LOADING_STRATEGY_BY_SI_PREFERENCE = 4;
		/**
		 * user-callout<br>
		 * <i>native declaration : clAmsTypes.h:224</i>
		 */
		public static final int CL_AMS_SG_LOADING_STRATEGY_USER_DEFINED = 5;
		/** <i>native declaration : clAmsTypes.h:225</i> */
		public static final int CL_AMS_SG_LOADING_STRATEGY_MAX = 6;
	};
	/**
	 * <i>native declaration : clAmsTypes.h</i><br>
	 * enum values
	 */
	public static interface ClAmsCompCapModelT {
		/** <i>native declaration : clAmsTypes.h:239</i> */
		public static final int CL_AMS_COMP_CAP_X_ACTIVE_AND_Y_STANDBY = 1;
		/** <i>native declaration : clAmsTypes.h:240</i> */
		public static final int CL_AMS_COMP_CAP_X_ACTIVE_OR_Y_STANDBY = 2;
		/** <i>native declaration : clAmsTypes.h:241</i> */
		public static final int CL_AMS_COMP_CAP_ONE_ACTIVE_OR_X_STANDBY = 3;
		/** <i>native declaration : clAmsTypes.h:242</i> */
		public static final int CL_AMS_COMP_CAP_ONE_ACTIVE_OR_ONE_STANDBY = 4;
		/** <i>native declaration : clAmsTypes.h:243</i> */
		public static final int CL_AMS_COMP_CAP_X_ACTIVE = 5;
		/** <i>native declaration : clAmsTypes.h:244</i> */
		public static final int CL_AMS_COMP_CAP_ONE_ACTIVE = 6;
		/** <i>native declaration : clAmsTypes.h:245</i> */
		public static final int CL_AMS_COMP_CAP_NON_PREINSTANTIABLE = 7;
		/** <i>native declaration : clAmsTypes.h:246</i> */
		public static final int CL_AMS_COMP_CAP_MAX = 8;
	};
	/**
	 * <i>native declaration : clAmsTypes.h</i><br>
	 * enum values
	 */
	public static interface ClAmsCompPropertyT {
		/** <i>native declaration : clAmsTypes.h:263</i> */
		public static final int CL_AMS_COMP_PROPERTY_SA_AWARE = 1;
		/** <i>native declaration : clAmsTypes.h:264</i> */
		public static final int CL_AMS_COMP_PROPERTY_PROXIED_PREINSTANTIABLE = 2;
		/** <i>native declaration : clAmsTypes.h:265</i> */
		public static final int CL_AMS_COMP_PROPERTY_PROXIED_NON_PREINSTANTIABLE = 3;
		/** <i>native declaration : clAmsTypes.h:266</i> */
		public static final int CL_AMS_COMP_PROPERTY_NON_PROXIED_NON_PREINSTANTIABLE = 4;
		/** <i>native declaration : clAmsTypes.h:267</i> */
		public static final int CL_AMS_COMP_PROPERTY_MAX = 5;
	};
	/**
	 * <i>native declaration : clAmsTypes.h</i><br>
	 * enum values
	 */
	public static interface ClAmsCompHealthcheckInvocationT {
		/** <i>native declaration : clAmsTypes.h:276</i> */
		public static final int CL_AMS_COMP_HEALTHCHECK_AMF_INVOKED = 1;
		/** <i>native declaration : clAmsTypes.h:277</i> */
		public static final int CL_AMS_COMP_HEALTHCHECK_CLIENT_INVOKED = 2;
	};
	/**
	 * <i>native declaration : clAmsTypes.h</i><br>
	 * enum values
	 */
	public static interface ClAmsRecoveryT {
		/** <i>native declaration : clAmsTypes.h:293</i> */
		public static final int CL_AMS_RECOVERY_NONE = 0;
		/** <i>native declaration : clAmsTypes.h:294</i> */
		public static final int CL_AMS_RECOVERY_NO_RECOMMENDATION = 1;
		/** <i>native declaration : clAmsTypes.h:295</i> */
		public static final int CL_AMS_RECOVERY_COMP_RESTART = 2;
		/** <i>native declaration : clAmsTypes.h:296</i> */
		public static final int CL_AMS_RECOVERY_COMP_FAILOVER = 3;
		/** <i>native declaration : clAmsTypes.h:297</i> */
		public static final int CL_AMS_RECOVERY_NODE_SWITCHOVER = 4;
		/** <i>native declaration : clAmsTypes.h:298</i> */
		public static final int CL_AMS_RECOVERY_NODE_FAILOVER = 5;
		/** <i>native declaration : clAmsTypes.h:299</i> */
		public static final int CL_AMS_RECOVERY_NODE_FAILFAST = 6;
		/** <i>native declaration : clAmsTypes.h:300</i> */
		public static final int CL_AMS_RECOVERY_CLUSTER_RESET = 7;
		/** <i>native declaration : clAmsTypes.h:301</i> */
		public static final int CL_AMS_RECOVERY_APP_RESTART = 8;
		/** <i>native declaration : clAmsTypes.h:307</i> */
		public static final int CL_AMS_RECOVERY_INTERNALLY_RECOVERED = 20;
		/** <i>native declaration : clAmsTypes.h:308</i> */
		public static final int CL_AMS_RECOVERY_SU_RESTART = 21;
		/** <i>native declaration : clAmsTypes.h:309</i> */
		public static final int CL_AMS_RECOVERY_NODE_HALT = 22;
		/** <i>native declaration : clAmsTypes.h:315</i> */
		public static final int CL_AMS_EXTERNAL_RECOVERY_RESET = 30;
		/** <i>native declaration : clAmsTypes.h:316</i> */
		public static final int CL_AMS_EXTERNAL_RECOVERY_REBOOT = 31;
		/** <i>native declaration : clAmsTypes.h:317</i> */
		public static final int CL_AMS_EXTERNAL_RECOVERY_POWER_ON = 32;
		/** <i>native declaration : clAmsTypes.h:318</i> */
		public static final int CL_AMS_EXTERNAL_RECOVERY_POWER_OFF = 33;
	};
	/**
	 * <i>native declaration : clAmsTypes.h</i><br>
	 * enum values
	 */
	public static interface ClAmsCSITransitionDescriptorT {
		/** <i>native declaration : clAmsTypes.h:337</i> */
		public static final int CL_AMS_CSI_NEW_ASSIGN = 1;
		/** <i>native declaration : clAmsTypes.h:338</i> */
		public static final int CL_AMS_CSI_QUIESCED = 2;
		/** <i>native declaration : clAmsTypes.h:339</i> */
		public static final int CL_AMS_CSI_NOT_QUIESCED = 3;
		/** <i>native declaration : clAmsTypes.h:340</i> */
		public static final int CL_AMS_CSI_STILL_ACTIVE = 4;
	};
	/**
	 * <i>native declaration : clAmsTypes.h</i><br>
	 * enum values
	 */
	public static interface ClAmsPGTrackFlagT {
		/** <i>native declaration : clAmsTypes.h:399</i> */
		public static final int CL_AMS_PG_TRACK_CURRENT = 1;
		/** <i>native declaration : clAmsTypes.h:400</i> */
		public static final int CL_AMS_PG_TRACK_CHANGES = 2;
		/** <i>native declaration : clAmsTypes.h:401</i> */
		public static final int CL_AMS_PG_TRACK_CHANGES_ONLY = 4;
	};
	/**
	 * <i>native declaration : clAmsTypes.h</i><br>
	 * enum values
	 */
	public static interface ClAmsPGChangeT {
		/** <i>native declaration : clAmsTypes.h:406</i> */
		public static final int CL_AMS_PG_NO_CHANGE = 1;
		/** <i>native declaration : clAmsTypes.h:407</i> */
		public static final int CL_AMS_PG_ADDED = 2;
		/** <i>native declaration : clAmsTypes.h:408</i> */
		public static final int CL_AMS_PG_REMOVED = 3;
		/** <i>native declaration : clAmsTypes.h:409</i> */
		public static final int CL_AMS_PG_STATE_CHANGE = 4;
	};	
	/**
	 * <i>native declaration : clAmsEntities.h</i><br>
	 * enum values
	 */
	public static interface ClAmsEntityTypeT {
		/**
		 * < unused<br>
		 * <i>native declaration : clAmsEntities.h:23</i>
		 */
		public static final int CL_AMS_ENTITY_TYPE_ENTITY = 0;
		/**
		 * < A Cluster Node (system,computer)<br>
		 * <i>native declaration : clAmsEntities.h:24</i>
		 */
		public static final int CL_AMS_ENTITY_TYPE_NODE = 1;
		/**
		 * < A SAF application<br>
		 * <i>native declaration : clAmsEntities.h:25</i>
		 */
		public static final int CL_AMS_ENTITY_TYPE_APP = 2;
		/**
		 * < A SAF service group<br>
		 * <i>native declaration : clAmsEntities.h:26</i>
		 */
		public static final int CL_AMS_ENTITY_TYPE_SG = 3;
		/**
		 * < A SAF service unit<br>
		 * <i>native declaration : clAmsEntities.h:27</i>
		 */
		public static final int CL_AMS_ENTITY_TYPE_SU = 4;
		/**
		 * < A SAF service instance (work assignment)<br>
		 * <i>native declaration : clAmsEntities.h:28</i>
		 */
		public static final int CL_AMS_ENTITY_TYPE_SI = 5;
		/**
		 * < A SAF component (program)<br>
		 * <i>native declaration : clAmsEntities.h:29</i>
		 */
		public static final int CL_AMS_ENTITY_TYPE_COMP = 6;
		/**
		 * < A SAF component service instance (work assigned to a particular program)<br>
		 * <i>native declaration : clAmsEntities.h:30</i>
		 */
		public static final int CL_AMS_ENTITY_TYPE_CSI = 7;
		/**
		 * < A cluster<br>
		 * <i>native declaration : clAmsEntities.h:31</i>
		 */
		public static final int CL_AMS_ENTITY_TYPE_CLUSTER = 8;
	};
	/**
	 * <i>native declaration : clAmsEntities.h</i><br>
	 * enum values
	 */
	public static interface ClAmsEntityTimerTypeT {
		/** <i>native declaration : clAmsEntities.h:149</i> */
		public static final int CL_AMS_NODE_TIMER_SUFAILOVER = 1;
		/** <i>native declaration : clAmsEntities.h:151</i> */
		public static final int CL_AMS_SG_TIMER_INSTANTIATE = 10;
		/** <i>native declaration : clAmsEntities.h:152</i> */
		public static final int CL_AMS_SG_TIMER_ADJUST = 11;
		/** <i>native declaration : clAmsEntities.h:153</i> */
		public static final int CL_AMS_SG_TIMER_ADJUST_PROBATION = 12;
		/** <i>native declaration : clAmsEntities.h:154</i> */
		public static final int CL_AMS_SU_TIMER_COMPRESTART = 20;
		/** <i>native declaration : clAmsEntities.h:155</i> */
		public static final int CL_AMS_SU_TIMER_SURESTART = 21;
		/** <i>native declaration : clAmsEntities.h:156</i> */
		public static final int CL_AMS_SU_TIMER_PROBATION = 22;
		/** <i>native declaration : clAmsEntities.h:157</i> */
		public static final int CL_AMS_SU_TIMER_ASSIGNMENT = 23;
		/** <i>native declaration : clAmsEntities.h:159</i> */
		public static final int CL_AMS_COMP_TIMER_INSTANTIATE = 40;
		/** <i>native declaration : clAmsEntities.h:160</i> */
		public static final int CL_AMS_COMP_TIMER_TERMINATE = 41;
		/** <i>native declaration : clAmsEntities.h:161</i> */
		public static final int CL_AMS_COMP_TIMER_CLEANUP = 42;
		/** <i>native declaration : clAmsEntities.h:162</i> */
		public static final int CL_AMS_COMP_TIMER_AMSTART = 43;
		/** <i>native declaration : clAmsEntities.h:163</i> */
		public static final int CL_AMS_COMP_TIMER_AMSTOP = 44;
		/** <i>native declaration : clAmsEntities.h:164</i> */
		public static final int CL_AMS_COMP_TIMER_QUIESCINGCOMPLETE = 45;
		/** <i>native declaration : clAmsEntities.h:165</i> */
		public static final int CL_AMS_COMP_TIMER_CSISET = 46;
		/** <i>native declaration : clAmsEntities.h:166</i> */
		public static final int CL_AMS_COMP_TIMER_CSIREMOVE = 47;
		/** <i>native declaration : clAmsEntities.h:167</i> */
		public static final int CL_AMS_COMP_TIMER_PROXIEDCOMPINSTANTIATE = 48;
		/** <i>native declaration : clAmsEntities.h:168</i> */
		public static final int CL_AMS_COMP_TIMER_PROXIEDCOMPCLEANUP = 49;
		/** <i>native declaration : clAmsEntities.h:169</i> */
		public static final int CL_AMS_COMP_TIMER_INSTANTIATEDELAY = 50;
		/** <i>native declaration : clAmsEntities.h:170</i> */
		public static final int CL_AMS_COMP_TIMER_MAX = 51;
	};
	/**
	 * <i>native declaration : clAmsEntities.h</i><br>
	 * enum values
	 */
	public static interface ClAmsEntityRefTypeT {
		/** <i>native declaration : clAmsEntities.h:200</i> */
		public static final int CL_AMS_ENTITY_REF_TYPE_ENTITY = 0;
		/** <i>native declaration : clAmsEntities.h:201</i> */
		public static final int CL_AMS_ENTITY_REF_TYPE_NODE = 1;
		/** <i>native declaration : clAmsEntities.h:202</i> */
		public static final int CL_AMS_ENTITY_REF_TYPE_APP = 2;
		/** <i>native declaration : clAmsEntities.h:203</i> */
		public static final int CL_AMS_ENTITY_REF_TYPE_SG = 3;
		/** <i>native declaration : clAmsEntities.h:204</i> */
		public static final int CL_AMS_ENTITY_REF_TYPE_SU = 4;
		/** <i>native declaration : clAmsEntities.h:205</i> */
		public static final int CL_AMS_ENTITY_REF_TYPE_SI = 5;
		/** <i>native declaration : clAmsEntities.h:206</i> */
		public static final int CL_AMS_ENTITY_REF_TYPE_COMP = 6;
		/** <i>native declaration : clAmsEntities.h:207</i> */
		public static final int CL_AMS_ENTITY_REF_TYPE_CSI = 7;
		/** <i>native declaration : clAmsEntities.h:208</i> */
		public static final int CL_AMS_ENTITY_REF_TYPE_SUSI = 8;
		/** <i>native declaration : clAmsEntities.h:209</i> */
		public static final int CL_AMS_ENTITY_REF_TYPE_SISU = 9;
		/** <i>native declaration : clAmsEntities.h:210</i> */
		public static final int CL_AMS_ENTITY_REF_TYPE_COMPCSI = 10;
		/** <i>native declaration : clAmsEntities.h:211</i> */
		public static final int CL_AMS_ENTITY_REF_TYPE_CSICOMP = 11;
	};
	/**
	 * <i>native declaration : clAmsEntities.h</i><br>
	 * enum values
	 */
	public static interface ClAmsEntityListTypeT {
		/** <i>native declaration : clAmsEntities.h:236</i> */
		public static final int CL_AMS_START_LIST = 0;
		/** <i>native declaration : clAmsEntities.h:241</i> */
		public static final int CL_AMS_CONFIG_LIST_START = 1;
		/** <i>native declaration : clAmsEntities.h:242</i> */
		public static final int CL_AMS_NODE_CONFIG_NODE_DEPENDENT_LIST = 2;
		/** <i>native declaration : clAmsEntities.h:243</i> */
		public static final int CL_AMS_NODE_CONFIG_NODE_DEPENDENCIES_LIST = 3;
		/** <i>native declaration : clAmsEntities.h:244</i> */
		public static final int CL_AMS_NODE_CONFIG_SU_LIST = 4;
		/** <i>native declaration : clAmsEntities.h:245</i> */
		public static final int CL_AMS_SG_CONFIG_SU_LIST = 5;
		/** <i>native declaration : clAmsEntities.h:246</i> */
		public static final int CL_AMS_SG_CONFIG_SI_LIST = 6;
		/** <i>native declaration : clAmsEntities.h:247</i> */
		public static final int CL_AMS_SU_CONFIG_COMP_LIST = 7;
		/** <i>native declaration : clAmsEntities.h:248</i> */
		public static final int CL_AMS_SI_CONFIG_SU_RANK_LIST = 8;
		/** <i>native declaration : clAmsEntities.h:249</i> */
		public static final int CL_AMS_SI_CONFIG_SI_DEPENDENTS_LIST = 9;
		/** <i>native declaration : clAmsEntities.h:250</i> */
		public static final int CL_AMS_SI_CONFIG_SI_DEPENDENCIES_LIST = 10;
		/** <i>native declaration : clAmsEntities.h:251</i> */
		public static final int CL_AMS_SI_CONFIG_CSI_LIST = 11;
		/** <i>native declaration : clAmsEntities.h:252</i> */
		public static final int CL_AMS_CSI_CONFIG_NVP_LIST = 12;
		/** <i>native declaration : clAmsEntities.h:253</i> */
		public static final int CL_AMS_CSI_CONFIG_CSI_DEPENDENTS_LIST = 13;
		/** <i>native declaration : clAmsEntities.h:254</i> */
		public static final int CL_AMS_CSI_CONFIG_CSI_DEPENDENCIES_LIST = 14;
		/** <i>native declaration : clAmsEntities.h:255</i> */
		public static final int CL_AMS_CONFIG_LIST_END = 15;
		/** <i>native declaration : clAmsEntities.h:260</i> */
		public static final int CL_AMS_SG_STATUS_INSTANTIABLE_SU_LIST = 16;
		/** <i>native declaration : clAmsEntities.h:261</i> */
		public static final int CL_AMS_SG_STATUS_INSTANTIATED_SU_LIST = 17;
		/** <i>native declaration : clAmsEntities.h:262</i> */
		public static final int CL_AMS_SG_STATUS_IN_SERVICE_SPARE_SU_LIST = 18;
		/** <i>native declaration : clAmsEntities.h:263</i> */
		public static final int CL_AMS_SG_STATUS_ASSIGNED_SU_LIST = 19;
		/** <i>native declaration : clAmsEntities.h:264</i> */
		public static final int CL_AMS_SG_STATUS_FAULTY_SU_LIST = 20;
		/** <i>native declaration : clAmsEntities.h:265</i> */
		public static final int CL_AMS_SU_STATUS_SI_LIST = 21;
		/** <i>native declaration : clAmsEntities.h:266</i> */
		public static final int CL_AMS_SI_STATUS_SU_LIST = 22;
		/** <i>native declaration : clAmsEntities.h:267</i> */
		public static final int CL_AMS_COMP_STATUS_CSI_LIST = 23;
		/** <i>native declaration : clAmsEntities.h:268</i> */
		public static final int CL_AMS_CSI_STATUS_PG_LIST = 24;
		/** <i>native declaration : clAmsEntities.h:273</i> */
		public static final int CL_AMS_ENTITY_LIST_ALL_START = 25;
		/** <i>native declaration : clAmsEntities.h:275</i> */
		public static final int CL_AMS_SG_LIST = 26;
		/** <i>native declaration : clAmsEntities.h:276</i> */
		public static final int CL_AMS_SI_LIST = 27;
		/** <i>native declaration : clAmsEntities.h:277</i> */
		public static final int CL_AMS_NODE_LIST = 28;
		/** <i>native declaration : clAmsEntities.h:278</i> */
		public static final int CL_AMS_SU_LIST = 29;
		/** <i>native declaration : clAmsEntities.h:279</i> */
		public static final int CL_AMS_COMP_LIST = 30;
		/** <i>native declaration : clAmsEntities.h:280</i> */
		public static final int CL_AMS_CSI_LIST = 31;
		/** <i>native declaration : clAmsEntities.h:284</i> */
		public static final int CL_AMS_ENTITY_LIST_ALL_END = 32;
		/** <i>native declaration : clAmsEntities.h:287</i> */
		public static final int CL_AMS_CSI_PGTRACK_CLIENT_LIST = 33;
		/** <i>native declaration : clAmsEntities.h:289</i> */
		public static final int CL_AMS_SU_STATUS_SI_EXTENDED_LIST = 34;
		/** <i>native declaration : clAmsEntities.h:291</i> */
		public static final int CL_AMS_SI_STATUS_SU_EXTENDED_LIST = 35;
		/** <i>native declaration : clAmsEntities.h:293</i> */
		public static final int CL_AMS_END_LIST = 36;
	};
	/**
	 * <i>native declaration : clAmsMgmtCommon.h</i><br>
	 * enum values
	 */
	public static interface ClAmsMgmtClientCallbackRmdInterfaceT {
		/** <i>native declaration : clAmsMgmtCommon.h:53</i> */
		public static final int CL_AMS_MGMT_INITIALIZE = 1;
		/** <i>native declaration : clAmsMgmtCommon.h:54</i> */
		public static final int CL_AMS_MGMT_FINALIZE = 2;
		/** <i>native declaration : clAmsMgmtCommon.h:55</i> */
		public static final int CL_AMS_MGMT_ENTITY_CREATE = 3;
		/** <i>native declaration : clAmsMgmtCommon.h:56</i> */
		public static final int CL_AMS_MGMT_ENTITY_DELETE = 4;
		/** <i>native declaration : clAmsMgmtCommon.h:57</i> */
		public static final int CL_AMS_MGMT_ENTITY_SET_CONFIG = 5;
		/** <i>native declaration : clAmsMgmtCommon.h:58</i> */
		public static final int CL_AMS_MGMT_ENTITY_LOCK_ASSIGNMENT = 6;
		/** <i>native declaration : clAmsMgmtCommon.h:59</i> */
		public static final int CL_AMS_MGMT_ENTITY_LOCK_INSTANTIATION = 7;
		/** <i>native declaration : clAmsMgmtCommon.h:60</i> */
		public static final int CL_AMS_MGMT_ENTITY_UNLOCK = 8;
		/** <i>native declaration : clAmsMgmtCommon.h:61</i> */
		public static final int CL_AMS_MGMT_ENTITY_SHUTDOWN = 9;
		/** <i>native declaration : clAmsMgmtCommon.h:62</i> */
		public static final int CL_AMS_MGMT_ENTITY_RESTART = 10;
		/** <i>native declaration : clAmsMgmtCommon.h:63</i> */
		public static final int CL_AMS_MGMT_ENTITY_REPAIRED = 11;
		/** <i>native declaration : clAmsMgmtCommon.h:64</i> */
		public static final int CL_AMS_MGMT_SG_ADJUST_PREFERENCE = 12;
		/** <i>native declaration : clAmsMgmtCommon.h:65</i> */
		public static final int CL_AMS_MGMT_SI_SWAP = 13;
		/** <i>native declaration : clAmsMgmtCommon.h:66</i> */
		public static final int CL_AMS_MGMT_ENTITY_LIST_ENTITY_REF_ADD = 14;
		/** <i>native declaration : clAmsMgmtCommon.h:67</i> */
		public static final int CL_AMS_MGMT_ENTITY_SET_REF = 15;
		/** <i>native declaration : clAmsMgmtCommon.h:68</i> */
		public static final int CL_AMS_MGMT_CSI_SET_NVP = 16;
		/** <i>native declaration : clAmsMgmtCommon.h:69</i> */
		public static final int CL_AMS_MGMT_DEBUG_ENABLE = 17;
		/** <i>native declaration : clAmsMgmtCommon.h:70</i> */
		public static final int CL_AMS_MGMT_DEBUG_DISABLE = 18;
		/** <i>native declaration : clAmsMgmtCommon.h:71</i> */
		public static final int CL_AMS_MGMT_DEBUG_GET = 19;
		/** <i>native declaration : clAmsMgmtCommon.h:72</i> */
		public static final int CL_AMS_MGMT_DEBUG_ENABLE_LOG_TO_CONSOLE = 20;
		/** <i>native declaration : clAmsMgmtCommon.h:73</i> */
		public static final int CL_AMS_MGMT_DEBUG_DISABLE_LOG_TO_CONSOLE = 21;
		/** <i>native declaration : clAmsMgmtCommon.h:75</i> */
		public static final int CL_AMS_MGMT_CCB_INITIALIZE = 22;
		/** <i>native declaration : clAmsMgmtCommon.h:76</i> */
		public static final int CL_AMS_MGMT_CCB_FINALIZE = 23;
		/** <i>native declaration : clAmsMgmtCommon.h:77</i> */
		public static final int CL_AMS_MGMT_CCB_ENTITY_SET_CONFIG = 24;
		/** <i>native declaration : clAmsMgmtCommon.h:78</i> */
		public static final int CL_AMS_MGMT_CCB_CSI_SET_NVP = 25;
		/** <i>native declaration : clAmsMgmtCommon.h:79</i> */
		public static final int CL_AMS_MGMT_CCB_SET_NODE_DEPENDENCY = 26;
		/** <i>native declaration : clAmsMgmtCommon.h:80</i> */
		public static final int CL_AMS_MGMT_CCB_SET_NODE_SU_LIST = 27;
		/** <i>native declaration : clAmsMgmtCommon.h:81</i> */
		public static final int CL_AMS_MGMT_CCB_SET_SG_SU_LIST = 28;
		/** <i>native declaration : clAmsMgmtCommon.h:82</i> */
		public static final int CL_AMS_MGMT_CCB_SET_SG_SI_LIST = 29;
		/** <i>native declaration : clAmsMgmtCommon.h:83</i> */
		public static final int CL_AMS_MGMT_CCB_SET_SU_COMP_LIST = 30;
		/** <i>native declaration : clAmsMgmtCommon.h:84</i> */
		public static final int CL_AMS_MGMT_CCB_SET_SI_SU_RANK_LIST = 31;
		/** <i>native declaration : clAmsMgmtCommon.h:85</i> */
		public static final int CL_AMS_MGMT_CCB_SET_SI_SI_DEPENDENCY = 32;
		/** <i>native declaration : clAmsMgmtCommon.h:86</i> */
		public static final int CL_AMS_MGMT_CCB_SET_SI_CSI_LIST = 33;
		/** <i>native declaration : clAmsMgmtCommon.h:87</i> */
		public static final int CL_AMS_MGMT_CCB_ENABLE_ENTITY = 34;
		/** <i>native declaration : clAmsMgmtCommon.h:88</i> */
		public static final int CL_AMS_MGMT_CCB_DISABLE_ENTITY = 35;
		/** <i>native declaration : clAmsMgmtCommon.h:89</i> */
		public static final int CL_AMS_MGMT_CCB_ENTITY_CREATE = 36;
		/** <i>native declaration : clAmsMgmtCommon.h:90</i> */
		public static final int CL_AMS_MGMT_CCB_ENTITY_DELETE = 37;
		/** <i>native declaration : clAmsMgmtCommon.h:91</i> */
		public static final int CL_AMS_MGMT_CCB_COMMIT = 38;
		/** <i>native declaration : clAmsMgmtCommon.h:92</i> */
		public static final int CL_AMS_MGMT_ENTITY_GET = 39;
		/** <i>native declaration : clAmsMgmtCommon.h:93</i> */
		public static final int CL_AMS_MGMT_ENTITY_GET_CONFIG = 40;
		/** <i>native declaration : clAmsMgmtCommon.h:94</i> */
		public static final int CL_AMS_MGMT_ENTITY_GET_STATUS = 41;
		/** <i>native declaration : clAmsMgmtCommon.h:95</i> */
		public static final int CL_AMS_MGMT_GET_CSI_NVP_LIST = 42;
		/** <i>native declaration : clAmsMgmtCommon.h:96</i> */
		public static final int CL_AMS_MGMT_GET_ENTITY_LIST = 43;
		/** <i>native declaration : clAmsMgmtCommon.h:97</i> */
		public static final int CL_AMS_MGMT_GET_OL_ENTITY_LIST = 44;
		/** <i>native declaration : clAmsMgmtCommon.h:98</i> */
		public static final int CL_AMS_MGMT_CCB_CSI_DELETE_NVP = 45;
		/** <i>native declaration : clAmsMgmtCommon.h:100</i> */
		public static final int CL_AMS_MGMT_CCB_DELETE_NODE_DEPENDENCY = 46;
		/** <i>native declaration : clAmsMgmtCommon.h:101</i> */
		public static final int CL_AMS_MGMT_CCB_DELETE_NODE_SU_LIST = 47;
		/** <i>native declaration : clAmsMgmtCommon.h:102</i> */
		public static final int CL_AMS_MGMT_CCB_DELETE_SG_SU_LIST = 48;
		/** <i>native declaration : clAmsMgmtCommon.h:103</i> */
		public static final int CL_AMS_MGMT_CCB_DELETE_SG_SI_LIST = 49;
		/** <i>native declaration : clAmsMgmtCommon.h:104</i> */
		public static final int CL_AMS_MGMT_CCB_DELETE_SU_COMP_LIST = 50;
		/** <i>native declaration : clAmsMgmtCommon.h:105</i> */
		public static final int CL_AMS_MGMT_CCB_DELETE_SI_SU_RANK_LIST = 51;
		/** <i>native declaration : clAmsMgmtCommon.h:106</i> */
		public static final int CL_AMS_MGMT_CCB_DELETE_SI_SI_DEPENDENCY = 52;
		/** <i>native declaration : clAmsMgmtCommon.h:107</i> */
		public static final int CL_AMS_MGMT_CCB_DELETE_SI_CSI_LIST = 53;
		/** <i>native declaration : clAmsMgmtCommon.h:109</i> */
		public static final int CL_AMS_MGMT_ENTITY_SET_ALPHA_FACTOR = 54;
		/** <i>native declaration : clAmsMgmtCommon.h:110</i> */
		public static final int CL_AMS_MGMT_MIGRATE_SG = 55;
		/** <i>native declaration : clAmsMgmtCommon.h:112</i> */
		public static final int CL_AMS_MGMT_ENTITY_USER_DATA_SET = 56;
		/** <i>native declaration : clAmsMgmtCommon.h:113</i> */
		public static final int CL_AMS_MGMT_ENTITY_USER_DATA_SETKEY = 57;
		/** <i>native declaration : clAmsMgmtCommon.h:114</i> */
		public static final int CL_AMS_MGMT_ENTITY_USER_DATA_GET = 58;
		/** <i>native declaration : clAmsMgmtCommon.h:115</i> */
		public static final int CL_AMS_MGMT_ENTITY_USER_DATA_GETKEY = 59;
		/** <i>native declaration : clAmsMgmtCommon.h:116</i> */
		public static final int CL_AMS_MGMT_ENTITY_USER_DATA_DELETE = 60;
		/** <i>native declaration : clAmsMgmtCommon.h:117</i> */
		public static final int CL_AMS_MGMT_ENTITY_USER_DATA_DELETEKEY = 61;
		/** <i>native declaration : clAmsMgmtCommon.h:119</i> */
		public static final int CL_AMS_MGMT_CCB_SET_CSI_CSI_DEPENDENCY = 62;
		/** <i>native declaration : clAmsMgmtCommon.h:120</i> */
		public static final int CL_AMS_MGMT_CCB_DELETE_CSI_CSI_DEPENDENCY = 63;
		/** <i>native declaration : clAmsMgmtCommon.h:121</i> */
		public static final int CL_AMS_MGMT_SI_ASSIGN_SU_CUSTOM = 65;
		/** <i>native declaration : clAmsMgmtCommon.h:122</i> */
		public static final int CL_AMS_MGMT_ENTITY_SET_BETA_FACTOR = 66;
		/** <i>native declaration : clAmsMgmtCommon.h:123</i> */
		public static final int CL_AMS_MGMT_ENTITY_FORCE_LOCK = 67;
		/** <i>native declaration : clAmsMgmtCommon.h:124</i> */
		public static final int CL_AMS_MGMT_DB_GET = 68;
		/** <i>native declaration : clAmsMgmtCommon.h:125</i> */
		public static final int CL_AMS_MGMT_COMPUTED_ADMIN_STATE_GET = 69;
		/** <i>native declaration : clAmsMgmtCommon.h:126</i> */
		public static final int CL_AMS_MGMT_ENTITY_FORCE_LOCK_INSTANTIATION = 70;
		/** <i>native declaration : clAmsMgmtCommon.h:127</i> */
		public static final int CL_AMS_MGMT_CCB_BATCH_COMMIT = 71;
	};
	/**
	 * <i>native declaration : clAmsMgmtCommon.h</i><br>
	 * enum values
	 */
	public static interface ClAmsTLVTypeT {
		/** <i>native declaration : clAmsMgmtCommon.h:135</i> */
		public static final int CL_AMS_TLV_TYPE_ENTITY = (int)ClAmsMgmtLibrary.ClAmsEntityTypeT.CL_AMS_ENTITY_TYPE_ENTITY;
		/** <i>native declaration : clAmsMgmtCommon.h:136</i> */
		public static final int CL_AMS_TLV_TYPE_NODE = (int)ClAmsMgmtLibrary.ClAmsEntityTypeT.CL_AMS_ENTITY_TYPE_NODE;
		/** <i>native declaration : clAmsMgmtCommon.h:137</i> */
		public static final int CL_AMS_TLV_TYPE_APP = (int)ClAmsMgmtLibrary.ClAmsEntityTypeT.CL_AMS_ENTITY_TYPE_APP;
		/** <i>native declaration : clAmsMgmtCommon.h:138</i> */
		public static final int CL_AMS_TLV_TYPE_SG = (int)ClAmsMgmtLibrary.ClAmsEntityTypeT.CL_AMS_ENTITY_TYPE_SG;
		/** <i>native declaration : clAmsMgmtCommon.h:139</i> */
		public static final int CL_AMS_TLV_TYPE_SU = (int)ClAmsMgmtLibrary.ClAmsEntityTypeT.CL_AMS_ENTITY_TYPE_SU;
		/** <i>native declaration : clAmsMgmtCommon.h:140</i> */
		public static final int CL_AMS_TLV_TYPE_SI = (int)ClAmsMgmtLibrary.ClAmsEntityTypeT.CL_AMS_ENTITY_TYPE_SI;
		/** <i>native declaration : clAmsMgmtCommon.h:141</i> */
		public static final int CL_AMS_TLV_TYPE_COMP = (int)ClAmsMgmtLibrary.ClAmsEntityTypeT.CL_AMS_ENTITY_TYPE_COMP;
		/** <i>native declaration : clAmsMgmtCommon.h:142</i> */
		public static final int CL_AMS_TLV_TYPE_CSI = (int)ClAmsMgmtLibrary.ClAmsEntityTypeT.CL_AMS_ENTITY_TYPE_CSI;
		/** <i>native declaration : clAmsMgmtCommon.h:143</i> */
		public static final int CL_AMS_TLV_TYPE_CLUSTER = (int)ClAmsMgmtLibrary.ClAmsEntityTypeT.CL_AMS_ENTITY_TYPE_CLUSTER;
		/** <i>native declaration : clAmsMgmtCommon.h:144</i> */
		public static final int CL_AMS_TLV_TYPE_START_LIST = (int)ClAmsMgmtLibrary.ClAmsEntityTypeT.CL_AMS_ENTITY_TYPE_CLUSTER + 1;
		/** <i>native declaration : clAmsMgmtCommon.h:145</i> */
		public static final int CL_AMS_TLV_TYPE_END_LIST = (int)ClAmsMgmtLibrary.ClAmsTLVTypeT.CL_AMS_TLV_TYPE_START_LIST + 1;
	};
	/**
	 * <i>native declaration : clAmsMgmtCommon.h</i><br>
	 * enum values
	 */
	public static interface ClAmsMgmtCCBOperationsT {
		/** <i>native declaration : clAmsMgmtCommon.h:154</i> */
		public static final int CL_AMS_MGMT_CCB_OPERATION_CREATE = 1;
		/** <i>native declaration : clAmsMgmtCommon.h:155</i> */
		public static final int CL_AMS_MGMT_CCB_OPERATION_DELETE = 2;
		/** <i>native declaration : clAmsMgmtCommon.h:156</i> */
		public static final int CL_AMS_MGMT_CCB_OPERATION_SET_CONFIG = 3;
		/** <i>native declaration : clAmsMgmtCommon.h:157</i> */
		public static final int CL_AMS_MGMT_CCB_OPERATION_CSI_SET_NVP = 4;
		/** <i>native declaration : clAmsMgmtCommon.h:158</i> */
		public static final int CL_AMS_MGMT_CCB_OPERATION_SET_NODE_DEPENDENCY = 5;
		/** <i>native declaration : clAmsMgmtCommon.h:159</i> */
		public static final int CL_AMS_MGMT_CCB_OPERATION_SET_NODE_SU_LIST = 6;
		/** <i>native declaration : clAmsMgmtCommon.h:160</i> */
		public static final int CL_AMS_MGMT_CCB_OPERATION_SET_SG_SU_LIST = 7;
		/** <i>native declaration : clAmsMgmtCommon.h:161</i> */
		public static final int CL_AMS_MGMT_CCB_OPERATION_SET_SG_SI_LIST = 8;
		/** <i>native declaration : clAmsMgmtCommon.h:162</i> */
		public static final int CL_AMS_MGMT_CCB_OPERATION_SET_SU_COMP_LIST = 9;
		/** <i>native declaration : clAmsMgmtCommon.h:163</i> */
		public static final int CL_AMS_MGMT_CCB_OPERATION_SET_SI_SU_RANK_LIST = 10;
		/** <i>native declaration : clAmsMgmtCommon.h:164</i> */
		public static final int CL_AMS_MGMT_CCB_OPERATION_SET_SI_SI_DEPENDENCY_LIST = 11;
		/** <i>native declaration : clAmsMgmtCommon.h:165</i> */
		public static final int CL_AMS_MGMT_CCB_OPERATION_SET_SI_CSI_LIST = 12;
		/** <i>native declaration : clAmsMgmtCommon.h:166</i> */
		public static final int CL_AMS_MGMT_CCB_OPERATION_SET_CSI_CSI_DEPENDENCY_LIST = 13;
		/** <i>native declaration : clAmsMgmtCommon.h:167</i> */
		public static final int CL_AMS_MGMT_CCB_OPERATION_CSI_DELETE_NVP = 14;
		/** <i>native declaration : clAmsMgmtCommon.h:168</i> */
		public static final int CL_AMS_MGMT_CCB_OPERATION_DELETE_NODE_DEPENDENCY = 15;
		/** <i>native declaration : clAmsMgmtCommon.h:169</i> */
		public static final int CL_AMS_MGMT_CCB_OPERATION_DELETE_NODE_SU_LIST = 16;
		/** <i>native declaration : clAmsMgmtCommon.h:170</i> */
		public static final int CL_AMS_MGMT_CCB_OPERATION_DELETE_SG_SU_LIST = 17;
		/** <i>native declaration : clAmsMgmtCommon.h:171</i> */
		public static final int CL_AMS_MGMT_CCB_OPERATION_DELETE_SG_SI_LIST = 18;
		/** <i>native declaration : clAmsMgmtCommon.h:172</i> */
		public static final int CL_AMS_MGMT_CCB_OPERATION_DELETE_SU_COMP_LIST = 19;
		/** <i>native declaration : clAmsMgmtCommon.h:173</i> */
		public static final int CL_AMS_MGMT_CCB_OPERATION_DELETE_SI_SU_RANK_LIST = 20;
		/** <i>native declaration : clAmsMgmtCommon.h:174</i> */
		public static final int CL_AMS_MGMT_CCB_OPERATION_DELETE_SI_SI_DEPENDENCY_LIST = 21;
		/** <i>native declaration : clAmsMgmtCommon.h:175</i> */
		public static final int CL_AMS_MGMT_CCB_OPERATION_DELETE_CSI_CSI_DEPENDENCY_LIST = 22;
		/** <i>native declaration : clAmsMgmtCommon.h:176</i> */
		public static final int CL_AMS_MGMT_CCB_OPERATION_DELETE_SI_CSI_LIST = 23;
		/** <i>native declaration : clAmsMgmtCommon.h:177</i> */
		public static final int CL_AMS_MGMT_CCB_OPERATION_MAX = 24;
	};
	/**
	 * <i>native declaration : clAmsMgmtCommon.h</i><br>
	 * enum values
	 */
	public static interface ClAmsMgmtSubAreaT {
		/** <i>native declaration : clAmsMgmtCommon.h:404</i> */
		public static final int CL_AMS_MGMT_SUB_AREA_MSG = 1;
		/** <i>native declaration : clAmsMgmtCommon.h:405</i> */
		public static final int CL_AMS_MGMT_SUB_AREA_STATE_CHANGE = 1 << 1;
		/** <i>native declaration : clAmsMgmtCommon.h:406</i> */
		public static final int CL_AMS_MGMT_SUB_AREA_FN_CALL = 1 << 2;
		/** <i>native declaration : clAmsMgmtCommon.h:407</i> */
		public static final int CL_AMS_MGMT_SUB_AREA_TIMER = 1 << 3;
	};
	/** <i>native declaration : clAmsTypes.h</i> */
	public static final int CL_AMS_HEALTHCHECK_KEY_MAX = (int)32;
	/** <i>native declaration : clAmsTypes.h</i> */
	public static final int CL_AMS_CSI_FLAG_ADD_ONE = (int)0x1;
	/** <i>native declaration : clAmsTypes.h</i> */
	public static final int CL_AMS_CSI_FLAG_TARGET_ONE = (int)0x2;
	/** <i>native declaration : clAmsTypes.h</i> */
	public static final int CL_AMS_CSI_FLAG_TARGET_ALL = (int)0x4;
	
	/** <i>native declaration : clAmsEntities.h</i> */
	public static final int CL_AMS_ENTITY_TYPE_MAX = (int)7;
	/** <i>native declaration : clAmsEntities.h</i> */
	public static final int CL_AMS_ENTITY_OP_REMOVE_MPLUSN = (int)0x1;
	/** <i>native declaration : clAmsEntities.h</i> */
	public static final int CL_AMS_ENTITY_OP_SWAP_REMOVE_MPLUSN = (int)0x2;
	/** <i>native declaration : clAmsEntities.h</i> */
	public static final int CL_AMS_ENTITY_OP_REDUCE_REMOVE_MPLUSN = (int)0x4;
	/** <i>native declaration : clAmsEntities.h</i> */
	public static final int CL_AMS_ENTITY_OP_ACTIVE_REMOVE_MPLUSN = (int)0x8;
	/** <i>native declaration : clAmsEntities.h</i> */
	public static final int CL_AMS_ENTITY_OP_REMOVES_MPLUSN = (int)(0x1 | 0x2 | 0x4);
	/** <i>native declaration : clAmsEntities.h</i> */
	public static final int CL_AMS_ENTITY_OP_SWAP_ACTIVE_MPLUSN = (int)0x10;
	/** <i>native declaration : clAmsEntities.h</i> */
	public static final int CL_AMS_ENTITY_OP_SI_REASSIGN_MPLUSN = (int)0x20;
	/** <i>native declaration : clAmsEntities.h</i> */
	public static final int CL_AMS_ENTITY_OP_ACTIVE_REMOVE_REF_MPLUSN = (int)0x40;
	/** <i>native declaration : clAmsEntities.h</i> */
	public static final int CL_AMS_SG_ADJUST_DURATION = (int)(3000);
	/** <i>native declaration : clAmsEntities.h</i> */
	public static final int CL_AMS_SG_ADJUST_PROBATION = (int)(3000);
	/** <i>native declaration : clAmsEntities.h</i> */
	public static final int CL_AMS_SU_ASSIGNMENT_DELAY = (int)(3000);
	/** <i>native declaration : clAmsEntities.h</i> */
	public static final int CL_AMS_ENTITY_REF_TYPE_MAX = (int)11;
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int CL_AMS_RMD_DEFAULT_TIMEOUT = (int)10000;
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int CL_AMS_RMD_DEFAULT_RETRIES = (int)3;
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int CL_AMS_CONFIG_ATTR_ALL = (int)1;
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int NODE_CONFIG_ADMIN_STATE = (int)(1 << 1);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int NODE_CONFIG_ID = (int)(1 << 2);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int NODE_CONFIG_CLASS_TYPE = (int)(1 << 3);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int NODE_CONFIG_SUB_CLASS_TYPE = (int)(1 << 4);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int NODE_CONFIG_IS_SWAPPABLE = (int)(1 << 5);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int NODE_CONFIG_IS_RESTARTABLE = (int)(1 << 6);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int NODE_CONFIG_AUTO_REPAIR = (int)(1 << 7);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int NODE_CONFIG_IS_ASP_AWARE = (int)(1 << 8);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int NODE_CONFIG_SU_FAILOVER_DURATION = (int)(1 << 9);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int NODE_CONFIG_SU_FAILOVER_COUNT_MAX = (int)(1 << 10);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int SG_CONFIG_ADMIN_STATE = (int)(1 << 1);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int SG_CONFIG_REDUNDANCY_MODEL = (int)(1 << 2);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int SG_CONFIG_LOADING_STRATEGY = (int)(1 << 3);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int SG_CONFIG_FAILBACK_OPTION = (int)(1 << 4);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int SG_CONFIG_AUTO_REPAIR = (int)(1 << 5);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int SG_CONFIG_INSTANTIATE_DURATION = (int)(1 << 6);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int SG_CONFIG_NUM_PREF_ACTIVE_SUS = (int)(1 << 7);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int SG_CONFIG_NUM_PREF_STANDBY_SUS = (int)(1 << 8);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int SG_CONFIG_NUM_PREF_INSERVICE_SUS = (int)(1 << 9);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int SG_CONFIG_NUM_PREF_ASSIGNED_SUS = (int)(1 << 10);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int SG_CONFIG_NUM_PREF_ACTIVE_SUS_PER_SI = (int)(1 << 11);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int SG_CONFIG_MAX_ACTIVE_SIS_PER_SU = (int)(1 << 12);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int SG_CONFIG_MAX_STANDBY_SIS_PER_SU = (int)(1 << 13);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int SG_CONFIG_COMP_RESTART_DURATION = (int)(1 << 14);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int SG_CONFIG_COMP_RESTART_COUNT_MAX = (int)(1 << 15);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int SG_CONFIG_SU_RESTART_DURATION = (int)(1 << 16);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int SG_CONFIG_SU_RESTART_COUNT_MAX = (int)(1 << 17);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int SG_CONFIG_REDUCTION_PROCEDURE = (int)(1 << 18);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int SG_CONFIG_COLOCATION_ALLOWED = (int)(1 << 19);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int SG_CONFIG_AUTO_ADJUST = (int)(1 << 20);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int SG_CONFIG_AUTO_ADJUST_PROBATION = (int)(1 << 21);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int SG_CONFIG_ALPHA_FACTOR = (int)(1 << 22);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int SG_CONFIG_MAX_FAILOVERS = (int)(1 << 23);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int SG_CONFIG_FAILOVER_DURATION = (int)(1 << 24);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int SG_CONFIG_BETA_FACTOR = (int)(1 << 25);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int SU_CONFIG_ADMIN_STATE = (int)(1 << 1);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int SU_CONFIG_RANK = (int)(1 << 2);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int SU_CONFIG_NUM_COMPONENTS = (int)(1 << 3);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int SU_CONFIG_IS_PREINSTANTIABLE = (int)(1 << 4);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int SU_CONFIG_IS_RESTARTABLE = (int)(1 << 5);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int SU_CONFIG_IS_CONTAINER_SU = (int)(1 << 6);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int SI_CONFIG_ADMIN_STATE = (int)(1 << 1);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int SI_CONFIG_RANK = (int)(1 << 2);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int SI_CONFIG_NUM_CSIS = (int)(1 << 3);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int SI_CONFIG_NUM_STANDBY_ASSIGNMENTS = (int)(1 << 4);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int SI_CONFIG_STANDBY_ASSIGNMENT_ORDER = (int)(1 << 5);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int COMP_CONFIG_SUPPORTED_CSI_TYPE = (int)(1 << 1);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int COMP_CONFIG_PROXY_CSI_TYPE = (int)(1 << 2);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int COMP_CONFIG_CAPABILITY_MODEL = (int)(1 << 3);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int COMP_CONFIG_PROPERTY = (int)(1 << 4);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int COMP_CONFIG_IS_RESTARTABLE = (int)(1 << 5);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int COMP_CONFIG_NODE_REBOOT_CLEANUP_FAIL = (int)(1 << 6);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int COMP_CONFIG_INSTANTIATE_LEVEL = (int)(1 << 7);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int COMP_CONFIG_NUM_MAX_INSTANTIATE = (int)(1 << 8);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int COMP_CONFIG_NUM_MAX_INSTANTIATE_WITH_DELAY = (int)(1 << 9);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int COMP_CONFIG_NUM_MAX_TERMINATE = (int)(1 << 10);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int COMP_CONFIG_NUM_MAX_AM_START = (int)(1 << 11);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int COMP_CONFIG_NUM_MAX_AM_STOP = (int)(1 << 12);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int COMP_CONFIG_NUM_MAX_ACTIVE_CSIS = (int)(1 << 13);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int COMP_CONFIG_NUM_MAX_STANDBY_CSIS = (int)(1 << 14);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int COMP_CONFIG_TIMEOUTS = (int)(1 << 15);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int COMP_CONFIG_RECOVERY_ON_TIMEOUT = (int)(1 << 16);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int COMP_CONFIG_PARENT_SU = (int)(1 << 17);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int COMP_CONFIG_INSTANTIATE_COMMAND = (int)(1 << 18);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int CSI_CONFIG_TYPE = (int)(1 << 1);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int CSI_CONFIG_IS_PROXY_CSI = (int)(1 << 2);
	/** <i>native declaration : clAmsMgmtCommon.h</i> */
	public static final int CSI_CONFIG_RANK = (int)(1 << 3);
	/** <i>native declaration : clAmsMgmtClientApi.h</i> */
	public static final String ASP_INSTALL_KEY = (String)"ASP_INSTALL_INFO";
	/** <i>native declaration : clAmsSAClientApi.h</i> */
	public interface ClAmsSACSISetCallbackT extends Callback {
		void apply(long invocation, Pointer compName, int haState, clAmsMgmtClientApi.ClAmsCSIDescriptorT.ByValue csiDescriptor);
	};
	/** <i>native declaration : clAmsSAClientApi.h</i> */
	public interface ClAmsSACSIRemoveCallbackT extends Callback {
		void apply(long invocation, Pointer compName, Pointer csiName, int csiFlags);
	};
	/** <i>native declaration : clAmsSAClientApi.h</i> */
	public interface ClAmsSAPGTrackCallbackT extends Callback {
		void apply(Pointer csiName, ClAmsPGNotificationBufferT.ByValue notificationBuffer, int numMembers, int error);
	};
	/** <i>native declaration : clAmsSAClientApi.h</i> */
	public interface ClAmsSACompHealthcheckCallbackT extends Callback {
		void apply(long invocation, Pointer compName, ClAmsCompHealthcheckKeyT healthcheckkey);
	};
	/** <i>native declaration : clAmsSAClientApi.h</i> */
	public interface ClAmsSACompTerminateCallbackT extends Callback {
		void apply(long invocation, Pointer compName);
	};
	/** <i>native declaration : clAmsSAClientApi.h</i> */
	public interface ClAmsSAProxiedCompInstantiateCallbackT extends Callback {
		void apply(long invocation, Pointer proxiedCompName);
	};
	/** <i>native declaration : clAmsSAClientApi.h</i> */
	public interface ClAmsSAProxiedCompCleanupCallbackT extends Callback {
		void apply(long invocation, Pointer proxiedCompName);
	};
	/**
	 * \brief Component Manager requests the component, identified by \e<br>
	 * compName, to execute healthcheck using \e healthcheckkey<br>
	 * [Asynchronous Call].<br>
	 * * \param invocation Particular invocation of this callback function.<br>
	 * * \param pCompName Pointer to the name of the component that must<br>
	 * undergo healthcheck.<br>
	 * * \param pHealthCheckKey Key to fetch the healthcheck related<br>
	 * attributes.<br>
	 * <i>native declaration : clCpmApi.h:277</i>
	 */
	
	/** <i>native declaration : clCpmApi.h</i> */
	/*public interface ClRcT_callback extends Callback {
		int apply(long invocation, Pointer pCompName, ClAmsCompHealthcheckKeyT pHealthCheckKey);
	};*/
	/** <i>native declaration : clAmsEntities.h:77</i> */
	public interface ClAmsEntityCallbackT extends Callback {
		int apply(ClAmsEntityT.ByReference entity);
	};
	/** <i>native declaration : clAmsEntities.h</i> */
	public interface ClAmsEntityCallbackExtendedT extends Callback {
		int apply(ClAmsEntityConfigT ClAmsEntityTPtr1, Pointer userArg);
	};
	/** <i>native declaration : clAmsEntities.h</i> */
	public interface ClAmsEntityTimerCallbackT extends Callback {
		int apply(ClAmsEntityTimerT ClAmsEntityTimerTPtr1);
	};
	/** <i>native declaration : clAmsEntities.h</i> */
	public interface ClAmsEntityRefCallbackT extends Callback {
		int apply(ClAmsEntityRefT entityRef, int listName);
	};
	/** <i>native declaration : clAmsEntities.h</i> */
	/*public interface ClRcT_callback2 extends Callback {
		int apply(ClAmsEntityConfigT ClAmsEntityTPtr1);
	};*/	
	
	/**
	 * ***********************************<br>
	 *  \brief Starts the use of the management function library.<br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param amsHandle <br>
	 *  (out) The handle returned by the function. It identifies <br>
	 *  a particular initialization of the Availability Management Framework. This <br>
	 *  handle must be passed as the first input parameter for all further usage of<br>
	 *  the function library.<br>
	 *  \param amsCallbacks <br>
	 *  (in) Callbacks into management function user.<br>
	 *  \param version <br>
	 *  (in/out) In the input parameter, you must pass the current version of AMS <br>
	 *  on the client. In the output parameter, you will receive the supported <br>
	 *  version.<br>
	 *  \retval CL_OK <br>
	 *  The function executed successfully.<br>
	 *  \retval CL_ERR_VERSION_MISMATCH <br>
	 *  If the current version and the supported version are not the same.<br>
	 *  \retval CL_ERR_TIMEOUT <br>
	 *  Timeout occured before the call could complete. It is unspecified whether <br>
	 *  the call succeeded or whether it did not. <br>
	 *  \retval CL_ERR_TRY_AGAIN <br>
	 *  The service can not be provided at this time. The process may retry later. <br>
	 *  \retval CL_ERR_INVALID_PARAMETER <br>
	 *  A parameter is not set correctly. <br>
	 *  \retval CL_ERR_NO_MEMORY  <br>
	 *  Either the AMS library or the provider of service is out of memory<br>
	 *  and so cannot provide the service.<br>
	 *  \retval CL_ERR_NULL_POINTER  <br>
	 *  Pointer to an invalid memory space.<br>
	 *  \par Description:<br>
	 *  This function is used to start the use of the management function library. <br>
	 *  It typically registers callbacks and it must be called before invoking any <br>
	 *  other function of the AMS library. In this release there are no callbacks <br>
	 *  to be registered.<br>
	 *  \par Library File:<br>
	 *  ClAmsMgmtClient<br>
	 *  \sa clAmsMgmtFinalize()<br>
	 * Original signature : <code>int clAmsMgmtInitialize(ClAmsMgmtHandleT*, const ClAmsMgmtCallbacksT*, ClVersionT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:113</i><br>
	 * use the safer methods {@link #clAmsMgmtInitialize(java.nio.LongBuffer, clAmsMgmtClientApi.ClAmsMgmtCallbacksT, com.sun.jna.Pointer)} and {@link #clAmsMgmtInitialize(com.sun.jna.ptr.LongByReference, clAmsMgmtClientApi.ClAmsMgmtCallbacksT, com.sun.jna.Pointer)} instead
	 */
	//@Deprecated 
	int clAmsMgmtInitialize(LongByReference amsHandle, ClAmsMgmtCallbacksT amsMgmtCallbacks, Pointer version);
	/**
	 * ***********************************<br>
	 *  \brief Starts the use of the management function library.<br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param amsHandle <br>
	 *  (out) The handle returned by the function. It identifies <br>
	 *  a particular initialization of the Availability Management Framework. This <br>
	 *  handle must be passed as the first input parameter for all further usage of<br>
	 *  the function library.<br>
	 *  \param amsCallbacks <br>
	 *  (in) Callbacks into management function user.<br>
	 *  \param version <br>
	 *  (in/out) In the input parameter, you must pass the current version of AMS <br>
	 *  on the client. In the output parameter, you will receive the supported <br>
	 *  version.<br>
	 *  \retval CL_OK <br>
	 *  The function executed successfully.<br>
	 *  \retval CL_ERR_VERSION_MISMATCH <br>
	 *  If the current version and the supported version are not the same.<br>
	 *  \retval CL_ERR_TIMEOUT <br>
	 *  Timeout occured before the call could complete. It is unspecified whether <br>
	 *  the call succeeded or whether it did not. <br>
	 *  \retval CL_ERR_TRY_AGAIN <br>
	 *  The service can not be provided at this time. The process may retry later. <br>
	 *  \retval CL_ERR_INVALID_PARAMETER <br>
	 *  A parameter is not set correctly. <br>
	 *  \retval CL_ERR_NO_MEMORY  <br>
	 *  Either the AMS library or the provider of service is out of memory<br>
	 *  and so cannot provide the service.<br>
	 *  \retval CL_ERR_NULL_POINTER  <br>
	 *  Pointer to an invalid memory space.<br>
	 *  \par Description:<br>
	 *  This function is used to start the use of the management function library. <br>
	 *  It typically registers callbacks and it must be called before invoking any <br>
	 *  other function of the AMS library. In this release there are no callbacks <br>
	 *  to be registered.<br>
	 *  \par Library File:<br>
	 *  ClAmsMgmtClient<br>
	 *  \sa clAmsMgmtFinalize()<br>
	 * Original signature : <code>int clAmsMgmtInitialize(ClAmsMgmtHandleT*, const ClAmsMgmtCallbacksT*, ClVersionT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:113</i>
	 */
	//int clAmsMgmtInitialize(LongBuffer amsHandle, ClAmsMgmtCallbacksT amsMgmtCallbacks, Pointer version);
	/**
	 * ***********************************<br>
	 *  \brief Terminates the use of the management function library.<br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param amsHandle<br>
	 *  Handle identifying the initialization of the AML by the application <br>
	 *  obtained through earlier invocation of clAmsMgmtInitialize API.<br>
	 *  \retval CL_OK<br>
	 *  The function executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE <br>
	 *  Handle passed is not a valid handle obtained through an earlier call to <br>
	 *  clAmsMmgmtInitialize API.<br>
	 *  \retval CL_ERR_TIMEOUT <br>
	 *  Timeout occured before the call could complete. It is unspecified whether <br>
	 *  the call succeeded or whether it did not. <br>
	 *  \retval CL_ERR_TRY_AGAIN <br>
	 *  The service can not be provided at this time. The process may retry later. <br>
	 *  \retval CL_ERR_NO_MEMORY  <br>
	 *  Either the AMS library or the provider of service is out of memory and can <br>
	 *  not provide the service. <br>
	 *  \par Description:<br>
	 *   This function is used to terminate the use of the management function <br>
	 *   library.This must be called when the services of the AMS library are no <br>
	 *   longer required. This function frees all resources allocated during <br>
	 *   initialization of the library through the clAmsMgmtInitialize() function.<br>
	 *  \par Library File:<br>
	 *  ClAmsMgmtClient<br>
	 *  \sa clAmsMgmtInitialize()<br>
	 * Original signature : <code>int clAmsMgmtFinalize(ClAmsMgmtHandleT)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:161</i>
	 */
	int clAmsMgmtFinalize(long amsHandle);
	/**
	 * ***********************************<br>
	 *  \brief Changes the administrative state of an AMS entity to lock assigned state. <br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param amsHandle <br>
	 *  Handle identifying the initialization of the AML by the application <br>
	 *  obtained through earlier invocation of clAmsMgmtInitialize API.<br>
	 *  \param entity <br>
	 *  Name and type of the entity on which the administrative action is being <br>
	 *  performed<br>
	 *  \retval CL_OK <br>
	 *  The function executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE <br>
	 *  Handle passed is not a valid handle obtained through an earlier call to <br>
	 *  clAmsMmgmtInitialize API.<br>
	 *  \retval CL_ERR_TIMEOUT <br>
	 *  Timeout occured before the call could complete. It is unspecified whether <br>
	 *  the call succeeded or whether it did not. <br>
	 *  \retval CL_ERR_TRY_AGAIN <br>
	 *  The service can not be provided at this time. The process may try later. <br>
	 *  This error is generally returned in cases where the requested action is <br>
	 *  valid but not currently possible, probably because another operation is <br>
	 *  acting upon the logical entity on which the administrative operation is <br>
	 *  invoked. Such an operation can be another administrative operation or an <br>
	 *  error recovery initiated by the AMF. <br>
	 *  \retval CL_ERR_NO_MEMORY  <br>
	 *  Either the AMS library or the provider of service is out of memory and can <br>
	 *  not provide the service. <br>
	 *  \retval CL_ERR_NO_OP<br>
	 *  Invocation of this administrative operation has no effect on the current <br>
	 *  state of the logical entity as it is already in lock assigned state <br>
	 *  \retval CL_ERR_BAD_OPERATION <br>
	 *  Administrative action is not a valid operation for the logical entity in <br>
	 *  the current administrative state.<br>
	 *  \retval CL_ERR_NOT_EXIST <br>
	 *  Entity on which the administrative action is requested is not found in the <br>
	 *  AMS database.<br>
	 *  \par Description:<br>
	 *  The administrative operation is applicable to all Availability Management <br>
	 *  Framework entities that possess an administrative state, namely, service <br>
	 *  unit, service instance, node, and service group. The invocation of this <br>
	 *  administrative operation sets the administrative state of the logical <br>
	 *  entity designated by entity to locked assignment. <br>
	 *  \par<br>
	 *  If this operation is invoked by a client on an entity that is already locked<br>
	 *  assigned, there is no change in the status of such an entity i.e. it remains<br>
	 *  in the locked assigned state, but a benign error value CL_ERR_NO_OP is <br>
	 *  returned to the client conveying that the entity in question, designated by<br>
	 *  entity, is already in the locked assigned state.  <br>
	 *  \par<br>
	 *  If this operation is invoked on an entity that is locked for instantiation, <br>
	 *  there is no change in the status of such an entity, i.e. it remains in the <br>
	 *  locked instantiation state, and the caller is returned a <br>
	 *  CL_ERR_BAD_OPERATION error value.<br>
	 *  \par Library File:<br>
	 *  libClAmsMgmt<br>
	 *  \sa clAmsMgmtEntityLockInstantiation(), clAmsMgmtEntityUnlock()<br>
	 * Original signature : <code>int clAmsMgmtEntityLockAssignment(ClAmsMgmtHandleT, const ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:245</i>
	 */
	int clAmsMgmtEntityLockAssignment(long amsHandle, ClAmsEntityConfigT entity);
	/**
	 * Original signature : <code>int clAmsMgmtEntityLockAssignmentExtended(ClAmsMgmtHandleT, const ClAmsEntityT*, ClBoolT)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:249</i>
	 */
	int clAmsMgmtEntityLockAssignmentExtended(long amsHandle, ClAmsEntityConfigT entity, short retry);
	/**
	 * ***********************************<br>
	 *  \brief Changes the administrative state of an AMS entity to lock instantiated <br>
	 *  state. <br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param amsHandle <br>
	 *  Handle identifying the initialization of the AML by the application <br>
	 *  obtained through earlier invocation of clAmsMgmtInitialize API.<br>
	 *  \param entity <br>
	 *  Name and type of the entity on which the administrative action is being <br>
	 *  performed<br>
	 *  \retval CL_OK <br>
	 *  The function executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE<br>
	 *  Handle passed is not a valid handle obtained through an earlier call to <br>
	 *  clAmsMmgmtInitialize API.<br>
	 *  \retval CL_ERR_TIMEOUT <br>
	 *  Timeout occured before the call could complete. It is unspecified whether <br>
	 *  the call succeeded or whether it did not. <br>
	 *  \retval CL_ERR_TRY_AGAIN <br>
	 *  The service can not be provided at this time. The process may try later. <br>
	 *  This error is generally returned in cases where the requested action is <br>
	 *  valid but not currently possible, probably because another operation is <br>
	 *  acting upon the logical entity on which the administrative operation is <br>
	 *  invoked. Such an operation can be another administrative operation or an <br>
	 *  error recovery initiated by the AMF. <br>
	 * *<br>
	 *  \retval CL_ERR_NO_MEMORY <br>
	 *  Either the AMS library or the provider of service is out of memory and can <br>
	 *  not provide the service. <br>
	 *  \retval CL_ERR_NO_OP <br>
	 *  Invocation of this administrative operation has no effect on the current <br>
	 *  state of the logical entity as it is already in lock instantiated state.<br>
	 *  \retval CL_ERR_BAD_OPERATION <br>
	 *  Administrative action is not a valid operation for the logical entity in <br>
	 *  the current administrative state.<br>
	 *  \retval CL_ERR_NOT_EXIST <br>
	 *  Entity on which the administrative action is requested is not found in the <br>
	 *  AMS database.<br>
	 *  \par Description:<br>
	 *  The administrative operation is applicable to Availability Management <br>
	 *  Framework entities service unit, node and service group. The invocation of <br>
	 *  this administrative operation sets the administrative state of the logical <br>
	 *  entity designated by entity to locked instantiation.<br>
	 *  \par<br>
	 *  After successful invocation of this procedure, all components in all <br>
	 *  pertinent service units are terminated. In particular, all processes in <br>
	 *  those components must cease to exist.<br>
	 *  \par<br>
	 *  Once this operation is invoked on a logical entity, as explained above, all<br>
	 *  pertinent service units within its scope become non-instantiable <br>
	 *  ( after being terminated ) and the effect of this operation can be reversed<br>
	 *  by applying another administrative operation clAmsMgmtEntityLockAssignment,<br>
	 *  which cause the relevent service units to be instantiated in a locked <br>
	 *  assigned state provided that the entity is not locked for instantiation at <br>
	 *  any other level.<br>
	 *  \par<br>
	 *  If this operation is invoked by a client on an entity that is already locked<br>
	 *  instantiated, there is no change in the status of such an entity i.e. it <br>
	 *  remains in the locked instantiated state, but a benign error value <br>
	 *  CL_ERR_NO_OP is returned to the client conveying that the entity in question<br>
	 *  , designated by entity, is already in the locked instantiated state.<br>
	 *  \par<br>
	 *  If this operation is invoked on an entity that is either in the <br>
	 *  shutting-down or unlocked administrative state, there is no change in the <br>
	 *  status of such an entity, i.e. it remains in the respective state, and the <br>
	 *  caller is returned a CL_ERR_BAD_OPERATION error value.<br>
	 *  \par Library File:<br>
	 *  libClAmsMgmt<br>
	 *  \sa clAmsMgmtEntityLockAssignment(), clAmsMgmtEntityUnlock()<br>
	 * Original signature : <code>int clAmsMgmtEntityLockInstantiation(ClAmsMgmtHandleT, const ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:343</i>
	 */
	int clAmsMgmtEntityLockInstantiation(long amsHandle, ClAmsEntityConfigT entity);
	/**
	 * Original signature : <code>int clAmsMgmtEntityLockInstantiationExtended(ClAmsMgmtHandleT, const ClAmsEntityT*, ClBoolT)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:347</i>
	 */
	int clAmsMgmtEntityLockInstantiationExtended(long amsHandle, ClAmsEntityConfigT entity, short retry);
	/**
	 * Original signature : <code>int clAmsMgmtEntityForceLockInstantiation(ClAmsMgmtHandleT, const ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:352</i>
	 */
	int clAmsMgmtEntityForceLockInstantiation(long amsHandle, ClAmsEntityConfigT entity);
	/**
	 * Original signature : <code>int clAmsMgmtEntityForceLockInstantiationExtended(ClAmsMgmtHandleT, const ClAmsEntityT*, ClBoolT)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:356</i>
	 */
	int clAmsMgmtEntityForceLockInstantiationExtended(long amsHandle, ClAmsEntityConfigT entity, short retry);
	/**
	 * ***********************************<br>
	 *  \brief Changes the administrative state of an AMS entity to unlocked state. <br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param amsHandle <br>
	 *  Handle identifying the initialization of the AML by the application <br>
	 *  obtained through earlier invocation of clAmsMgmtInitialize API.<br>
	 *  \param entity <br>
	 *  Name and type of the entity on which the administrative action is being <br>
	 *  performed<br>
	 *  \retval CL_OK <br>
	 *  The function executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE <br>
	 *  Handle passed is not a valid handle obtained through an earlier call to <br>
	 *  clAmsMmgmtInitialize API.<br>
	 *  \retval CL_ERR_TIMEOUT <br>
	 *  Timeout occured before the call could complete. It is unspecified whether <br>
	 *  the call succeeded or whether it did not. <br>
	 *  \retval CL_ERR_TRY_AGAIN <br>
	 *  The service can not be provided at this time. The process may try later. <br>
	 *  This error is generally returned in cases where the requested action is <br>
	 *  valid but not currently possible, probably because another operation is <br>
	 *  acting upon the logical entity on which the administrative operation is <br>
	 *  invoked. Such an operation can be another administrative operation or an <br>
	 *  error recovery initiated by the AMF. <br>
	 *  \retval CL_ERR_NO_MEMORY<br>
	 *  Either the AMS library or the provider of service is out of memory and can <br>
	 *  not provide the service. <br>
	 *  \retval CL_ERR_NO_OP <br>
	 *  Invocation of this administrative operation has no effect on the current <br>
	 *  state of the logical entity as it is already in lock instantiated state.<br>
	 *  \retval CL_ERR_BAD_OPERATION <br>
	 *  Administrative action is not a valid operation for the logical entity in <br>
	 *  the current administrative state.<br>
	 *  \retval CL_ERR_NOT_EXIST <br>
	 *  Entity on which the administrative action is requested is not found in the <br>
	 *  AMS database.<br>
	 *  \par Description:<br>
	 *  The administrative operation is applicable to all Availability Management <br>
	 *  Framework entities that possess an administrative state, namely, service <br>
	 *  unit, service instance, node, and service group. The invocation of this <br>
	 *  administrative operation sets the administrative state of the logical entity<br>
	 *  designated by entity to unlocked. If this operation is invoked by a client <br>
	 *  on an entity that is already unlocked, there is no change in the status of <br>
	 *  such an entity i.e. it remains in the unlocked state, but a benign error <br>
	 *  value CL_ERR_NO_OP is returned to the client conveying that the entity in <br>
	 *  question, designated by entity, is already in the unlocked state. If this <br>
	 *  operation is invoked on an entity that is locked for instantiation, there is<br>
	 *  no change in the status of such an entity, i.e. it remains in the respective<br>
	 *  state, and the caller is returned a CL_ERR_BAD_OPERATION error value.<br>
	 *  \par Library File:<br>
	 *  libClAmsMgmt<br>
	 *  \sa clAmsMgmtEntityLockAssignment(), clAmsMgmtEntityLockInstantiation()<br>
	 * Original signature : <code>int clAmsMgmtEntityUnlock(ClAmsMgmtHandleT, const ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:432</i>
	 */
	int clAmsMgmtEntityUnlock(long amsHandle, ClAmsEntityConfigT entity);
	/**
	 * Original signature : <code>int clAmsMgmtEntityUnlockExtended(ClAmsMgmtHandleT, const ClAmsEntityT*, ClBoolT)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:436</i>
	 */
	int clAmsMgmtEntityUnlockExtended(long amsHandle, ClAmsEntityConfigT entity, short retry);
	/**
	 * ***********************************<br>
	 *  \brief Changes the administrative state of an AMS entity to shutting-down. <br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param amsHandle <br>
	 *  Handle identifying the initialization of the AML by the application <br>
	 *  obtained through earlier invocation of clAmsMgmtInitialize API.<br>
	 *  \param entity <br>
	 *  Name and type of the entity on which the administrative action is being <br>
	 *  performed<br>
	 *  \retval CL_OK <br>
	 *  The function executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE <br>
	 *  Handle passed is not a valid handle obtained through an earlier call to <br>
	 *  clAmsMmgmtInitialize API.<br>
	 *  \retval CL_ERR_TIMEOUT <br>
	 *  Timeout occured before the call could complete. It is unspecified whether <br>
	 *  the call succeeded or whether it did not. <br>
	 *  \retval CL_ERR_TRY_AGAIN <br>
	 *  The service can not be provided at this time. The process may try later. <br>
	 *  This error is generally returned in cases where the requested action is <br>
	 *  valid but not currently possible, probably because another operation is <br>
	 *  acting upon the logical entity on which the administrative operation is <br>
	 *  invoked. Such an operation can be another administrative operation or an <br>
	 *  error recovery initiated by the AMF. <br>
	 *  \retval CL_ERR_NO_MEMORY  <br>
	 *  Either the AMS library or the provider of service is out of memory and can <br>
	 *  not provide the service. <br>
	 *  \retval CL_ERR_NO_OP <br>
	 *  Invocation of this administrative operation has no effect on the current <br>
	 *  state of the logical entity as it is already in shutting-down state.<br>
	 *  \retval CL_ERR_BAD_OPERATION <br>
	 *  Administrative action is not a valid operation for the logical entity in <br>
	 *  the current administrative state.<br>
	 *  \retval CL_ERR_NOT_EXIST <br>
	 *  Entity on which the administrative action is requested is not found in the <br>
	 *  AMS database.<br>
	 *  \par Description:<br>
	 *  The administrative operation is applicable to all Availability Management <br>
	 *  Framework entities that possess an administrative state, namely, service <br>
	 *  unit, service instance, node, and service group. The invocation of this <br>
	 *  administrative operation sets the administrative state of the logical entity<br>
	 *  designated by entity to shutting-down. The administrative operation is <br>
	 *  non-blocking i.e. It does not wait for the logical entity designated by <br>
	 *  entity  to transition to the locked instantiation state, which can possibly<br>
	 *  take a very long time. <br>
	 *  \par<br>
	 *  If this operation is invoked by a client on an entity that is already in <br>
	 *  shutting-down administrative state, there is no change in the status of such<br>
	 *  an entity i.e. it continues shutting-down and the caller is returned a <br>
	 *  benign CL_ERR_NO_OP error value, which means that entity is already <br>
	 *  shutting-down.  <br>
	 *  \par<br>
	 *  If this operation is invoked on an entity that is in either in locked <br>
	 *  instantiation or lock assignment administrative state, there is no change <br>
	 *  in the status of such an entity, i.e. it remains in the respective state, <br>
	 *  and the caller is returned a CL_ERR_BAD_OPERATION error value.<br>
	 *  \par Library File:<br>
	 *  libClAmsMgmt<br>
	 *  \sa <br>
	 *   clAmsMgmtEntityLockAssignment(),<br>
	 *   clAmsMgmtEntityLockInstantiation(),<br>
	 *   clAmsMgmtEntityUnlock()<br>
	 * Original signature : <code>int clAmsMgmtEntityShutdown(ClAmsMgmtHandleT, const ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:521</i>
	 */
	int clAmsMgmtEntityShutdown(long amsHandle, ClAmsEntityConfigT entity);
	/**
	 * Original signature : <code>int clAmsMgmtEntityShutdownExtended(ClAmsMgmtHandleT, const ClAmsEntityT*, ClBoolT)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:525</i>
	 */
	int clAmsMgmtEntityShutdownExtended(long amsHandle, ClAmsEntityConfigT entity, short retry);
	/**
	 * ***********************************<br>
	 *  \brief Restart an AMS entity following termination .<br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param amsHandle <br>
	 *  Handle identifying the initialization of the AML by the application <br>
	 *  obtained through earlier invocation of clAmsMgmtInitialize API.<br>
	 *  \param entity <br>
	 *  Name and type of the entity on which the administrative action is being <br>
	 *  performed<br>
	 *  \retval CL_OK <br>
	 *  The function executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE <br>
	 *  Handle passed is not a valid handle obtained through an earlier call to <br>
	 *  clAmsMmgmtInitialize API.<br>
	 *  \retval CL_ERR_TIMEOUT <br>
	 *  Timeout occured before the call could complete. It is unspecified whether <br>
	 *  the call succeeded or whether it did not. <br>
	 *  \retval CL_ERR_TRY_AGAIN <br>
	 *  The service can not be provided at this time. The process may try later. <br>
	 *  This error is generally returned in cases where the requested action is <br>
	 *  valid but not currently possible, probably because another operation is <br>
	 *  acting upon the logical entity on which the administrative operation is <br>
	 *  invoked. Such an operation can be another administrative operation or an <br>
	 *  error recovery initiated by the AMF. <br>
	 *  \retval CL_ERR_NO_MEMORY <br>
	 *  Either the AMS library or the provider of service is out of memory and can <br>
	 *  not provide the service. <br>
	 *  \retval CL_ERR_NO_OP <br>
	 *  Invocation of this administrative operation has no effect on the current <br>
	 *  state of the logical entity as it is currently restarting. <br>
	 *  \retval CL_ERR_BAD_OPERATION <br>
	 *  The logical entity could not be restarted for various reasons like the <br>
	 *  presence state of the service unit or the component to be re-started was not<br>
	 *  instantiated.<br>
	 *  \retval CL_ERR_NOT_EXIST <br>
	 *  Entity on which the administrative action is requested is not found in the <br>
	 *  AMS database.<br>
	 *  \retval CL_AMS_ERR_INVALID_ENTITY <br>
	 *  Administrative operation is not valid for the entity type designated by type<br>
	 *  field in entity.<br>
	 *  \par Description:<br>
	 *  The administrative operation is applicable for component, service unit or <br>
	 *  node. This procedure typically involves a termination action followed by a <br>
	 *  subsequent instantiation of either the concerned entity or logical entities<br>
	 *  that belong to the concerned entity.<br>
	 *  \par<br>
	 *  This administrative operation is applicable to only those service units <br>
	 *  whose presence state is instantiated. The invocation of this administrative<br>
	 *  operation on a service unit causes the service unit to be restarted by <br>
	 *  restarting all the components within it.<br>
	 *  \par <br>
	 *  If this operation is invoked by a client on an entity that is not <br>
	 *  restartable, there is no change in the status of such an entity, but the <br>
	 *  caller is returned a benign CL_ERR_NO_OP error value, which means that no <br>
	 *  action is being performed.<br>
	 *  \par <br>
	 *  When this operation is performed on an individual component, only the <br>
	 *  component implied in the operation is restarted. <br>
	 *  \par <br>
	 *  When this operation is invoked upon a service unit this operation becomes a<br>
	 *  composite operation that cause collective restart of all components within <br>
	 *  the service unit. In-order to execute such a collective restart of all the <br>
	 *  components in a particular scope, the AMF first completely terminates all <br>
	 *  pertinent components and does not start instantiating them back until all <br>
	 *  components have been terminated.<br>
	 *  \par <br>
	 *  When invoked upon a node, this operation becomes a composite operation that<br>
	 *  causes a collective restart of all service units residing within the node. <br>
	 *  In-order to execute such a collective restart of all the service units in a<br>
	 *  particular scope, the AMF first completely terminates all pertinent service<br>
	 *  units and does not start instantiating them back until all service units <br>
	 *  have been terminated.<br>
	 *  \par <br>
	 *  AMF does not proceed with this operation if another administrative operation<br>
	 *  or an error recovery initiated by AMF is already engaged on the logical <br>
	 *  entity. In such case, an error value of CL_ERR_TRY_AGAIN is returned <br>
	 *  indicating that the action is feasible but not at this instant.<br>
	 * *<br>
	 *  \par Library File:<br>
	 *  libClAmsMgmt<br>
	 *  \sa<br>
	 *  clAmsMgmtEntityLockAssignment(),<br>
	 *  clAmsMgmtEntityLockInstantiation(),<br>
	 *  clAmsMgmtEntityUnlock(),<br>
	 *  clAmsMgmtEntityShutdown()<br>
	 * Original signature : <code>int clAmsMgmtEntityRestart(ClAmsMgmtHandleT, const ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:634</i>
	 */
	int clAmsMgmtEntityRestart(long amsHandle, ClAmsEntityConfigT entity);
	/**
	 * Original signature : <code>int clAmsMgmtEntityRestartExtended(ClAmsMgmtHandleT, const ClAmsEntityT*, ClBoolT)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:638</i>
	 */
	int clAmsMgmtEntityRestartExtended(long amsHandle, ClAmsEntityConfigT entity, short retry);
	/**
	 * ***********************************<br>
	 *  \brief Marks a previously faulty entity as repaired, so that AMS can use it again <br>
	 *  for work assignment.<br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param amsHandle <br>
	 *  Handle identifying the initialization of the AML by the application <br>
	 *  obtained through earlier invocation of clAmsMgmtInitialize API.<br>
	 *  \param entity <br>
	 *  Name and type of the entity on which the administrative action is being <br>
	 *  performed<br>
	 *  \retval CL_OK <br>
	 *  The function executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE <br>
	 *  Handle passed is not a valid handle obtained through an earlier call to <br>
	 *  clAmsMmgmtInitialize API.<br>
	 *  \retval CL_ERR_TIMEOUT <br>
	 *  Timeout occured before the call could complete. It is unspecified whether <br>
	 *  the call succeeded or whether it did not. <br>
	 *  \retval CL_ERR_TRY_AGAIN <br>
	 *  The service can not be provided at this time. The process may try later. <br>
	 *  This error is generally returned in cases where the requested action is <br>
	 *  valid but not currently possible, probably because another operation is <br>
	 *  acting upon the logical entity on which the administrative operation is <br>
	 *  invoked. Such an operation can be another administrative operation or an <br>
	 *  error recovery initiated by the AMF. <br>
	 * *<br>
	 *  \retval CL_ERR_NO_MEMORY  <br>
	 *  Either the AMS library or the provider of service is out of memory and can <br>
	 *  not provide the service. <br>
	 *  \retval CL_ERR_NO_OP <br>
	 *  Invocation of this administrative operation has no effect on the current <br>
	 *  state of the logical entity as it is already enabled. <br>
	 *  \retval CL_ERR_BAD_OPERATION <br>
	 *  The operation could not insure that the presence states of the relevent <br>
	 *  service units and components are either instantiated or uninstantiated. <br>
	 *  \retval CL_ERR_NOT_EXIST <br>
	 *  Entity on which the administrative action is requested is not found in the <br>
	 *  AMS database.<br>
	 *  \retval CL_AMS_ERR_INVALID_ENTITY <br>
	 *  Administrative operation is not valid for the entity type designated by type<br>
	 *  field in entity.<br>
	 *  \par Description:<br>
	 *  The administrative operation is applicable for a service unit or a node. <br>
	 *  \par <br>
	 *  This administrative operation is used to clear the disabled operational <br>
	 *  state of a node or a service unit after they have been successfully mended <br>
	 *  to declare them as repaired. The administrator uses this operation to <br>
	 *  indicate the availability of a service unit or a node for providing service<br>
	 *  after an externally executed repair action. When invoked on a node this <br>
	 *  operation results enabling the operational state of the constituent service<br>
	 *  units and components. When invoked on a service unit, it has a similar <br>
	 *  effect on all the components that make up the service unit.<br>
	 *  \par <br>
	 *  AMS might optionally engage in repairing a node or a service unit after a <br>
	 *  successful recovery procedure execution in which case the AMS itself will <br>
	 *  clear the disabled state of the involved node or a service unit, but if a<br>
	 *  repair action is undertaken by an external entity outside the scope of the<br>
	 *  AMS, or the AMS failed  to successfully repair <br>
	 *  ( and the repair requires intervention by an external entity ), one should <br>
	 *  use this administrative operation to clear the disabled state of the node <br>
	 *  or the service unit to indicate that these entities are repaired and their <br>
	 *  operational state is enabled.<br>
	 *  \par <br>
	 *  If this administrative operation is invoked on a logical entity that is <br>
	 *  already enabled, the entity remains in that state, and a benign error value<br>
	 *  of CL_ERR_NO_OP is returned to the caller.<br>
	 *  <br>
	 *  \par Library File:<br>
	 *  libClAmsMgmt<br>
	 *  \sa<br>
	 *  clAmsMgmtEntityLockAssignment(),<br>
	 *  clAmsMgmtEntityLockInstantiation(),<br>
	 *  clAmsMgmtEntityUnlock(),<br>
	 *  clAmsMgmtEntityShutdown(),<br>
	 *  clAmsMgmtEntityRestart()<br>
	 * Original signature : <code>int clAmsMgmtEntityRepaired(ClAmsMgmtHandleT, const ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:830</i>
	 */
	int clAmsMgmtEntityRepaired(long amsHandle, ClAmsEntityConfigT entity);
	/**
	 * Original signature : <code>int clAmsMgmtEntityRepairedExtended(ClAmsMgmtHandleT, const ClAmsEntityT*, ClBoolT)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:834</i>
	 */
	int clAmsMgmtEntityRepairedExtended(long amsHandle, ClAmsEntityConfigT entity, short retry);
	/**
	 * ***********************************<br>
	 *  \brief Swaps the HA state of the appropriate CSIs contained within an SI<br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param amsHandle <br>
	 *  Handle identifying the initialization of the AML by the application <br>
	 *  obtained through earlier invocation of clAmsMgmtInitialize API.<br>
	 *  \param si<br>
	 *  Name of the SI thats being swapped<br>
	 *  \retval CL_OK <br>
	 *  The function executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE <br>
	 *  Handle passed is not a valid handle obtained through an earlier call to <br>
	 *  clAmsMmgmtInitialize API.<br>
	 *  \retval CL_ERR_BAD_OPERATION <br>
	 *  Swap was attempted on an SI thats not allowed. This is returned whenever SI<br>
	 *  doesnt have standby assignments or is not active or in quiescing state. Its also<br>
	 *  returned when the parent SG for the SI has a redundancy model of N WAY active or<br>
	 *  no redundancy.<br>
	 *  \retval CL_ERR_TRY_AGAIN <br>
	 *  The swap cannot be performed at this time. This error is returned when<br>
	 *  the constituent service units of the SIs have instantiating/terminating<br>
	 *  or restarting presence states.<br>
	 *  \retval CL_ERR_NOT_EXIST <br>
	 *  Entity on which the administrative action is requested is not found in the <br>
	 *  AMS database.<br>
	 *  \retval CL_AMS_ERR_INVALID_ENTITY <br>
	 *  Administrative operation is not valid for the entity type designated by type<br>
	 *  field in entity.<br>
	 *  \par Description:<br>
	 *  This administrative operation is used to swap the ha states of the CSIs within the SI<br>
	 *  assigned to service units. It results in the interchange of HA states of the CSIs<br>
	 *  assigned to the components within a service unit. If the SI is protected by 2N redundancy<br>
	 *  model, it results in swapping of all the active and standby SIs assigned to the service unit<br>
	 *  to which the SI getting swapped is assigned. In case of M+N, it also results in swapping<br>
	 *  of all the active SIs assigned to the service unit to which the swapped SI is assigned.<br>
	 *  This operation is not supported on N-WAY active and no redundancy models. Application of this <br>
	 *  operation may potentially result in modification of the standby assignments of all the other SIs<br>
	 *  protected by the same service group but not assigned active to the service unit to which the<br>
	 *  swapped SI is assigned active.<br>
	 *  <br>
	 *  \par Library File:<br>
	 *  libClAmsMgmt<br>
	 *  \sa<br>
	 *  clAmsMgmtEntityLockAssignment(),<br>
	 *  clAmsMgmtEntityLockInstantiation(),<br>
	 *  clAmsMgmtEntityUnlock(),<br>
	 *  clAmsMgmtEntityShutdown(),<br>
	 *  clAmsMgmtEntityRestart()<br>
	 *  clAmsMgmtEntityRepaired()<br>
	 * Original signature : <code>int clAmsMgmtSISwap(ClAmsMgmtHandleT, const ClCharT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:904</i><br>
	 * @deprecated use the safer methods {@link #clAmsMgmtSISwap(long, java.nio.ByteBuffer)} and {@link #clAmsMgmtSISwap(long, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	int clAmsMgmtSISwap(long amsHandle, Pointer si);
	/**
	 * ***********************************<br>
	 *  \brief Swaps the HA state of the appropriate CSIs contained within an SI<br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param amsHandle <br>
	 *  Handle identifying the initialization of the AML by the application <br>
	 *  obtained through earlier invocation of clAmsMgmtInitialize API.<br>
	 *  \param si<br>
	 *  Name of the SI thats being swapped<br>
	 *  \retval CL_OK <br>
	 *  The function executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE <br>
	 *  Handle passed is not a valid handle obtained through an earlier call to <br>
	 *  clAmsMmgmtInitialize API.<br>
	 *  \retval CL_ERR_BAD_OPERATION <br>
	 *  Swap was attempted on an SI thats not allowed. This is returned whenever SI<br>
	 *  doesnt have standby assignments or is not active or in quiescing state. Its also<br>
	 *  returned when the parent SG for the SI has a redundancy model of N WAY active or<br>
	 *  no redundancy.<br>
	 *  \retval CL_ERR_TRY_AGAIN <br>
	 *  The swap cannot be performed at this time. This error is returned when<br>
	 *  the constituent service units of the SIs have instantiating/terminating<br>
	 *  or restarting presence states.<br>
	 *  \retval CL_ERR_NOT_EXIST <br>
	 *  Entity on which the administrative action is requested is not found in the <br>
	 *  AMS database.<br>
	 *  \retval CL_AMS_ERR_INVALID_ENTITY <br>
	 *  Administrative operation is not valid for the entity type designated by type<br>
	 *  field in entity.<br>
	 *  \par Description:<br>
	 *  This administrative operation is used to swap the ha states of the CSIs within the SI<br>
	 *  assigned to service units. It results in the interchange of HA states of the CSIs<br>
	 *  assigned to the components within a service unit. If the SI is protected by 2N redundancy<br>
	 *  model, it results in swapping of all the active and standby SIs assigned to the service unit<br>
	 *  to which the SI getting swapped is assigned. In case of M+N, it also results in swapping<br>
	 *  of all the active SIs assigned to the service unit to which the swapped SI is assigned.<br>
	 *  This operation is not supported on N-WAY active and no redundancy models. Application of this <br>
	 *  operation may potentially result in modification of the standby assignments of all the other SIs<br>
	 *  protected by the same service group but not assigned active to the service unit to which the<br>
	 *  swapped SI is assigned active.<br>
	 *  <br>
	 *  \par Library File:<br>
	 *  libClAmsMgmt<br>
	 *  \sa<br>
	 *  clAmsMgmtEntityLockAssignment(),<br>
	 *  clAmsMgmtEntityLockInstantiation(),<br>
	 *  clAmsMgmtEntityUnlock(),<br>
	 *  clAmsMgmtEntityShutdown(),<br>
	 *  clAmsMgmtEntityRestart()<br>
	 *  clAmsMgmtEntityRepaired()<br>
	 * Original signature : <code>int clAmsMgmtSISwap(ClAmsMgmtHandleT, const ClCharT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:904</i>
	 */
	int clAmsMgmtSISwap(long amsHandle, String si);
	/**
	 * Original signature : <code>int clAmsMgmtSISwapExtended(ClAmsMgmtHandleT, const ClCharT*, ClBoolT)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:908</i><br>
	 * @deprecated use the safer methods {@link #clAmsMgmtSISwapExtended(long, java.nio.ByteBuffer, short)} and {@link #clAmsMgmtSISwapExtended(long, com.sun.jna.Pointer, short)} instead
	 */
	@Deprecated 
	int clAmsMgmtSISwapExtended(long amsHandle, Pointer si, short retry);
	/**
	 * Original signature : <code>int clAmsMgmtSISwapExtended(ClAmsMgmtHandleT, const ClCharT*, ClBoolT)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:908</i>
	 */
	int clAmsMgmtSISwapExtended(long amsHandle, String si, short retry);
	/**
	 * ***********************************<br>
	 *  \brief Restores the SG to the most preferred assignments<br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param amsHandle <br>
	 *  Handle identifying the initialization of the AML by the application <br>
	 *  obtained through earlier invocation of clAmsMgmtInitialize API.<br>
	 *  \param sg<br>
	 *  Name of the SG thats being adjusted<br>
	 *  \param enable<br>
	 *  Flag indicating the auto adjustment setting on the SG<br>
	 *  \retval CL_OK <br>
	 *  The function executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE <br>
	 *  Handle passed is not a valid handle obtained through an earlier call to <br>
	 *  clAmsMmgmtInitialize API.<br>
	 *  \retval CL_ERR_NOT_EXIST <br>
	 *  Entity on which the administrative action is requested is not found in the <br>
	 *  AMS database.<br>
	 *  \retval CL_AMS_ERR_INVALID_ENTITY <br>
	 *  Administrative operation is not valid for the entity type designated by type<br>
	 *  field in entity.<br>
	 *  \par Description:<br>
	 *  This administrative operation is used to restore the SG to the most preferred assignments<br>
	 *  based on the rank of the associated service units. The need for auto adjustment arises when<br>
	 *  the service unit becomes instantiable or when its readiness state is IN-SERVICE or when an<br>
	 *  service instance is UNLOCKED. If the service group becomes eligible for auto adjustment after<br>
	 *  a fault or recovery, the adjustment procedure is run on the newly repaired service units after<br>
	 *  the service groups auto-adjust probation period expires on the repaired service units. But<br>
	 *  these service units are used in other operations like switchover and failover.<br>
	 *  <br>
	 *  \par Library File:<br>
	 *  libClAmsMgmt<br>
	 *  \sa<br>
	 *  clAmsMgmtEntityLockAssignment(),<br>
	 *  clAmsMgmtEntityLockInstantiation(),<br>
	 *  clAmsMgmtEntityUnlock(),<br>
	 *  clAmsMgmtEntityShutdown(),<br>
	 *  clAmsMgmtEntityRestart(),<br>
	 *  clAmsMgmtEntityRepaired(),<br>
	 *  clAmsMgmtSISwap()<br>
	 * Original signature : <code>int clAmsMgmtSGAdjust(ClAmsMgmtHandleT, const ClCharT*, ClBoolT)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:969</i><br>
	 * @deprecated use the safer methods {@link #clAmsMgmtSGAdjust(long, java.nio.ByteBuffer, short)} and {@link #clAmsMgmtSGAdjust(long, com.sun.jna.Pointer, short)} instead
	 */
	@Deprecated 
	int clAmsMgmtSGAdjust(long amsHandle, Pointer sg, short enable);
	/**
	 * ***********************************<br>
	 *  \brief Restores the SG to the most preferred assignments<br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param amsHandle <br>
	 *  Handle identifying the initialization of the AML by the application <br>
	 *  obtained through earlier invocation of clAmsMgmtInitialize API.<br>
	 *  \param sg<br>
	 *  Name of the SG thats being adjusted<br>
	 *  \param enable<br>
	 *  Flag indicating the auto adjustment setting on the SG<br>
	 *  \retval CL_OK <br>
	 *  The function executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE <br>
	 *  Handle passed is not a valid handle obtained through an earlier call to <br>
	 *  clAmsMmgmtInitialize API.<br>
	 *  \retval CL_ERR_NOT_EXIST <br>
	 *  Entity on which the administrative action is requested is not found in the <br>
	 *  AMS database.<br>
	 *  \retval CL_AMS_ERR_INVALID_ENTITY <br>
	 *  Administrative operation is not valid for the entity type designated by type<br>
	 *  field in entity.<br>
	 *  \par Description:<br>
	 *  This administrative operation is used to restore the SG to the most preferred assignments<br>
	 *  based on the rank of the associated service units. The need for auto adjustment arises when<br>
	 *  the service unit becomes instantiable or when its readiness state is IN-SERVICE or when an<br>
	 *  service instance is UNLOCKED. If the service group becomes eligible for auto adjustment after<br>
	 *  a fault or recovery, the adjustment procedure is run on the newly repaired service units after<br>
	 *  the service groups auto-adjust probation period expires on the repaired service units. But<br>
	 *  these service units are used in other operations like switchover and failover.<br>
	 *  <br>
	 *  \par Library File:<br>
	 *  libClAmsMgmt<br>
	 *  \sa<br>
	 *  clAmsMgmtEntityLockAssignment(),<br>
	 *  clAmsMgmtEntityLockInstantiation(),<br>
	 *  clAmsMgmtEntityUnlock(),<br>
	 *  clAmsMgmtEntityShutdown(),<br>
	 *  clAmsMgmtEntityRestart(),<br>
	 *  clAmsMgmtEntityRepaired(),<br>
	 *  clAmsMgmtSISwap()<br>
	 * Original signature : <code>int clAmsMgmtSGAdjust(ClAmsMgmtHandleT, const ClCharT*, ClBoolT)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:969</i>
	 */
	int clAmsMgmtSGAdjust(long amsHandle, String sg, short enable);
	/**
	 * Original signature : <code>int clAmsMgmtSGAdjustExtended(ClAmsMgmtHandleT, const ClCharT*, ClBoolT, ClBoolT)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:974</i><br>
	 * @deprecated use the safer methods {@link #clAmsMgmtSGAdjustExtended(long, java.nio.ByteBuffer, short, short)} and {@link #clAmsMgmtSGAdjustExtended(long, com.sun.jna.Pointer, short, short)} instead
	 */
	@Deprecated 
	int clAmsMgmtSGAdjustExtended(long amsHandle, Pointer sg, short enable, short retry);
	/**
	 * Original signature : <code>int clAmsMgmtSGAdjustExtended(ClAmsMgmtHandleT, const ClCharT*, ClBoolT, ClBoolT)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:974</i>
	 */
	int clAmsMgmtSGAdjustExtended(long amsHandle, String sg, short enable, short retry);
	/**
	 * ***********************************<br>
	 * <br>
	 *  \brief Enables debugging for AMS entitity(ies).<br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param amsHandle (in) Handle identifying the initialization of the AML by the<br>
	 *  application obtained through earlier invocation of clAmsMgmtInitialize API.  <br>
	 *  \param entity (in) Name and type of the entity on which the debugFlags have to<br>
	 *  be set. NULL value for the entity indicates that debugFlags are being set <br>
	 *  for entire AMS.  <br>
	 *  \param debugFlags (in) This parameter defines the type of the debug messages to<br>
	 *  be enabled for entity(ies). See the AMS Debug Flags above for description <br>
	 *  of various debugFlags.  AMS debug flags can be  used in conjunction with <br>
	 *  each other. For example, to enable all types of logging messages, the <br>
	 *  debugFlags combination will be : CL_AMS_MGMT_SUB_AREA_MSG | <br>
	 *  CL_AMS_MGMT_SUB_AREA_STATE_CHANGE  | CL_AMS_MGMT_SUB_AREA_FN_CALL | <br>
	 *  CL_AMS_MGMT_SUB_AREA_TIMER <br>
	 *    <br>
	 *  \retval CL_OK  The function completed successfully. <br>
	 *  \retval CL_ERR_INVALID_HANDLE Handle passed is not a valid handle obtained <br>
	 *  through an earlier call to clAmsMgmtInitialize API.  <br>
	 *  \retval CL_ERR_TIMEOUT Timeout occurred before the call could be completed. It <br>
	 *  is unspecified whether the call succeeded or whether it did not.  <br>
	 *  \retval CL_ERR_NO_MEMORY Either the AMS library or the provider of service is <br>
	 *  out of memory and cannot provide the service.  <br>
	 *  \retval CL_ERR_NOT_EXIST Entity on which the action is requested is not found in <br>
	 *  the AMS database.<br>
	 *                <br>
	 *  \par Description: <br>
	 *  This API enables AMS logging for AMS entity(ies). AMS server logs different <br>
	 *  types of messages. These messages have been divided in 4 categories i.e. <br>
	 *  Important ams events related messages, timer related messages, entity state <br>
	 *  change messages and function entry messages  (see details above). This API can <br>
	 *  be used to enable logging of particular types of messages by AMS server.<br>
	 *  \par<br>
	 *  If the entity name is NULL, AMS server enables debugFlags for all AMS entities.<br>
	 *  \par Library  File: <br>
	 *  libClAmsMgmt<br>
	 *  \sa clAmsMgmtDebugDisable(), clAmsMgmtDebugGet()<br>
	 * Original signature : <code>int clAmsMgmtDebugEnable(ClAmsMgmtHandleT, const ClAmsEntityT*, ClUint8T)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:1034</i>
	 */
	int clAmsMgmtDebugEnable(long amsHandle, ClAmsEntityConfigT entity, byte debugFlags);
	/**
	 * ***********************************<br>
	 *  \brief Disables debugging for AMS entitity(ies).  <br>
	 *  \par Header File: <br>
	 *  clAmsMgmtClientApi.h <br>
	 *  \param amsHandle (in) Handle identifying the initialization of the AML by the<br>
	 *  application obtained through earlier invocation of clAmsMgmtInitialize API.  <br>
	 *  \param entity (in) Name and type of the entity on which the debugFlags have to be<br>
	 *  set. NULL value for the entity indicates that debugFlags are being set for entire AMS.  <br>
	 *  \param debugFlags (in) This parameter defines the type of the debug messages to <br>
	 *  be disabled for entity(ies). See the AMS Debug Flags above for description<br>
	 *  of various debugFlags.  <br>
	 *  AMS debug flags can be  used in conjunction with each other. For example, to<br>
	 *  disble all types of logging messages, the debugFlags combination will be : <br>
	 *  CL_AMS_MGMT_SUB_AREA_MSG | CL_AMS_MGMT_SUB_AREA_STATE_CHANGE  | <br>
	 *  CL_AMS_MGMT_SUB_AREA_FN_CALL | CL_AMS_MGMT_SUB_AREA_TIMER <br>
	 *  \retval CL_OK The function completed successfully.  <br>
	 *  \retval CL_ERR_INVALID_HANDLE Handle passed is not a valid handle obtained<br>
	 *  through an earlier call to clAmsMgmtInitialize API.  <br>
	 *  \retval CL_ERR_TIMEOUT Timeout occurred before the call could be completed. It <br>
	 *  is unspecified whether the call succeeded or whether it did not.  <br>
	 *  \retval CL_ERR_NO_MEMORY Either the AMS library or the provider of service is<br>
	 *  out of memory and cannot provide the service.  <br>
	 *  \retval CL_ERR_NOT_EXIST Entity on which the administrative action is requested is <br>
	 *  not found in the AMS database.  <br>
	 *  \par Description: <br>
	 *  This API disables AMS logging for AMS entity(ies). AMS server logs different<br>
	 *  types of messages. These messages have been divided in 4 categories i.e.<br>
	 *  Important ams events related messages, timer related messages, entity state <br>
	 *  change messages and function entry messages  (see details above). This API <br>
	 *  can be used to disable logging of particular types of messages by AMS server.<br>
	 *  If the entity name is NULL, AMS server disables debugFlags for all AMS <br>
	 *  entities.  <br>
	 *  \par Library  File: <br>
	 *  libClAmsMgmt <br>
	 *  \sa clAmsMgmtDebugEnable(), clAmsMgmtDebugGet()<br>
	 * Original signature : <code>int clAmsMgmtDebugDisable(ClAmsMgmtHandleT, const ClAmsEntityT*, ClUint8T)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:1094</i>
	 */
	int clAmsMgmtDebugDisable(long amsHandle, ClAmsEntityConfigT entity, byte debugFlags);
	/**
	 * ***********************************<br>
	 *  \brief Returns the debugging flags for AMS entitity(ies).<br>
	 *  \par Header File: <br>
	 *  clAmsMgmtClientApi.h <br>
	 *  \param amsHandle (in) Handle identifying the initialization of the AML by the<br>
	 *  application obtained through earlier invocation of clAmsMgmtInitialize API. <br>
	 *  \param entity (in) Name and type of the entity on which the debugFlags have to be<br>
	 *  set. NULL value for the entity indicates that debugFlags are being set for entire AMS.  <br>
	 *  \param debugFlags (out) AML returns the enabled debugFlags for the AMS entity(ies)<br>
	 *  in this parameter. See the AMS Debug Flags above for description of various debugFlags.  <br>
	 *  \retval CL_OK The function completed successfully.  <br>
	 *  \retval CL_ERR_INVALID_HANDLE Handle passed is not a valid handle obtained<br>
	 *  through an earlier call to clAmsMgmtInitialize API.  <br>
	 *  \retval CL_ERR_TIMEOUT Timeout occurred before the call could be completed. It is<br>
	 *  unspecified whether the call succeeded or whether it did not.  <br>
	 *  \retval CL_ERR_NO_MEMORY Either the AMS library or the provider of service is out<br>
	 *  of memory and cannot provide the service.  <br>
	 *  \retval CL_ERR_NOT_EXIST Entity on which the administrative action is requested is <br>
	 *  not found in the AMS database.  <br>
	 *  \par Description: <br>
	 *  This API retrieves the debug flags for AMS entity(ies). AMS server logs<br>
	 *  different types of messages. These messages have been divided in 4 categories<br>
	 *  i.e. Important ams events related messages, timer related messages, entity<br>
	 *  state change messages and function entry messages  (see details above). This<br>
	 *  API can be used to retrieve the types of messages, which are currently logged<br>
	 *  by AMS server.  <br>
	 *  \par<br>
	 *  If the entity name is NULL, AMS server returns debugFlags for all AMS<br>
	 *  entities.  <br>
	 *  \par Library  File: <br>
	 *  libClAmsMgmt <br>
	 *  \sa clAmsMgmtDebugEnable(), clAmsMgmtDebugDisable()<br>
	 * Original signature : <code>int clAmsMgmtDebugGet(ClAmsMgmtHandleT, const ClAmsEntityT*, ClUint8T*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:1150</i><br>
	 * @deprecated use the safer methods {@link #clAmsMgmtDebugGet(long, clAmsMgmtClientApi.ClAmsEntityConfigT, java.nio.ByteBuffer)} and {@link #clAmsMgmtDebugGet(long, clAmsMgmtClientApi.ClAmsEntityConfigT, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	int clAmsMgmtDebugGet(long amsHandle, ClAmsEntityConfigT entity, Pointer debugFlags);
	/**
	 * ***********************************<br>
	 *  \brief Returns the debugging flags for AMS entitity(ies).<br>
	 *  \par Header File: <br>
	 *  clAmsMgmtClientApi.h <br>
	 *  \param amsHandle (in) Handle identifying the initialization of the AML by the<br>
	 *  application obtained through earlier invocation of clAmsMgmtInitialize API. <br>
	 *  \param entity (in) Name and type of the entity on which the debugFlags have to be<br>
	 *  set. NULL value for the entity indicates that debugFlags are being set for entire AMS.  <br>
	 *  \param debugFlags (out) AML returns the enabled debugFlags for the AMS entity(ies)<br>
	 *  in this parameter. See the AMS Debug Flags above for description of various debugFlags.  <br>
	 *  \retval CL_OK The function completed successfully.  <br>
	 *  \retval CL_ERR_INVALID_HANDLE Handle passed is not a valid handle obtained<br>
	 *  through an earlier call to clAmsMgmtInitialize API.  <br>
	 *  \retval CL_ERR_TIMEOUT Timeout occurred before the call could be completed. It is<br>
	 *  unspecified whether the call succeeded or whether it did not.  <br>
	 *  \retval CL_ERR_NO_MEMORY Either the AMS library or the provider of service is out<br>
	 *  of memory and cannot provide the service.  <br>
	 *  \retval CL_ERR_NOT_EXIST Entity on which the administrative action is requested is <br>
	 *  not found in the AMS database.  <br>
	 *  \par Description: <br>
	 *  This API retrieves the debug flags for AMS entity(ies). AMS server logs<br>
	 *  different types of messages. These messages have been divided in 4 categories<br>
	 *  i.e. Important ams events related messages, timer related messages, entity<br>
	 *  state change messages and function entry messages  (see details above). This<br>
	 *  API can be used to retrieve the types of messages, which are currently logged<br>
	 *  by AMS server.  <br>
	 *  \par<br>
	 *  If the entity name is NULL, AMS server returns debugFlags for all AMS<br>
	 *  entities.  <br>
	 *  \par Library  File: <br>
	 *  libClAmsMgmt <br>
	 *  \sa clAmsMgmtDebugEnable(), clAmsMgmtDebugDisable()<br>
	 * Original signature : <code>int clAmsMgmtDebugGet(ClAmsMgmtHandleT, const ClAmsEntityT*, ClUint8T*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:1150</i>
	 */
	int clAmsMgmtDebugGet(long amsHandle, ClAmsEntityConfigT entity, ByteByReference debugFlags);
	/**
	 * ***********************************<br>
	 *  \brief Enables AMS debugging messages to be displayed on the console.  <br>
	 *  \par Header File: <br>
	 *  clAmsMgmtClientApi.h <br>
	 *  \param amsHandle (in) Handle identifying the initialization of the AML by the<br>
	 *  application obtained through earlier invocation of clAmsMgmtInitialize API.  <br>
	 *  \retval CL_OK The function completed successfully.  <br>
	 *  \retval CL_ERR_INVALID_HANDLE Handle passed is not a valid handle obtained<br>
	 *  through an earlier call to clAmsMgmtInitialize API.  <br>
	 *  \retval CL_ERR_TIMEOUT Timeout occurred before the call could be completed. It is<br>
	 *  unspecified whether the call succeeded or whether it did not.  <br>
	 *  \retval CL_ERR_NO_MEMORY Either the AMS library or the provider of service is <br>
	 *  out of memory and cannot provide the service.  <br>
	 *  \par Description: <br>
	 *  This API is used to display AMS messages on the standard output. By default,<br>
	 *  AMS messages are sent to log server. This API enables the log messages to be<br>
	 *  also seen on the screen. This is a useful API to debug and understand AMS<br>
	 *  server behavior.  <br>
	 *  \par Library  File: <br>
	 *  libClAmsMgmt <br>
	 *  \sa clAmsMgmtDebugDisableLogToConsole()<br>
	 * Original signature : <code>int clAmsMgmtDebugEnableLogToConsole(ClAmsMgmtHandleT)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:1191</i>
	 */
	int clAmsMgmtDebugEnableLogToConsole(long amsHandle);
	/**
	 * ***********************************<br>
	 *  \brief Disables display of AMS debugging messages on the console.  <br>
	 *  \par Header File: <br>
	 *  clAmsMgmtClientApi.h <br>
	 *  \param amsHandle (in) Handle identifying the initialization of the AML by the<br>
	 *  application obtained through earlier invocation of clAmsMgmtInitialize API.  <br>
	 *  \retval CL_OK The function completed successfully.  <br>
	 *  \retval CL_ERR_INVALID_HANDLE Handle passed is not a valid handle obtained<br>
	 *  through an earlier call to clAmsMgmtInitialize API.  <br>
	 *  \retval CL_ERR_TIMEOUT Timeout occurred before the call could be completed. It is<br>
	 *  unspecified whether the call succeeded or whether it did not.  <br>
	 *  \retval CL_ERR_NO_MEMORY Either the AMS library or the provider of service is<br>
	 *  out of memory and cannot provide the service.  <br>
	 *  \par Description: <br>
	 *  This API is used to disable the display of AMS messages on the standard<br>
	 *  output. By default, AMS messages are sent to log server. So AMS messages can<br>
	 *  still be seen using ASP logging facility.  <br>
	 *  \par Library  File: <br>
	 *  libClAmsMgmt <br>
	 *  \sa clAmsMgmtDebugEnableLogToConsole()<br>
	 * Original signature : <code>int clAmsMgmtDebugDisableLogToConsole(ClAmsMgmtHandleT)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:1230</i>
	 */
	int clAmsMgmtDebugDisableLogToConsole(long amsHandle);
	/**
	 * ***********************************<br>
	 *  \brief Changes the alpha factor configured for a given SG<br>
	 *  \par Header File: <br>
	 *  clAmsMgmtClientApi.h <br>
	 *  \param amsHandle (in) Handle identifying the initialization of the AML by the<br>
	 *  application obtained through earlier invocation of clAmsMgmtInitialize API.  <br>
	 *  \param entity (in) Name of the SG and type should be CL_AMS_ENTITY_TYPE_SG <br>
	 *  to get current alpha factor configured for the SG<br>
	 *  \param alphaFactor (in) The value for the alphaFactor which should be <br>
	 *  between 0 and 100.<br>
	 *  \retval CL_OK The function completed successfully.  <br>
	 *  \retval CL_ERR_INVALID_HANDLE Handle passed is not a valid handle obtained<br>
	 *  through an earlier call to clAmsMgmtInitialize API.  <br>
	 *  \retval CL_ERR_TIMEOUT Timeout occurred before the call could be completed. It is<br>
	 *  unspecified whether the call succeeded or whether it did not.  <br>
	 *  \retval CL_ERR_NO_MEMORY Either the AMS library or the provider of service is<br>
	 *  out of memory and cannot provide the service.  <br>
	 *  <br>
	 *  \retval CL_ERR_INVALID_PARAMETER The alpha factor provided was invalid.<br>
	 *  \retval CL_ERR_NOT_EXIST The SG wasnt found in the AMS DB to change the alpha factor<br>
	 *  \par Description: <br>
	 *  This API is used to change the SGs alpha factor configuration. This variable<br>
	 *  limits the active number of service units incase the available service units<br>
	 *  are less than the preferred active service units. This variable helps to <br>
	 *  dynamically limit the active service units that can be assigned work. <br>
	 *  Judicious usage of this variable would allow dynamic changes to redundancy <br>
	 *  mode at runtime without disrupting service. For example with a 10+1 model, <br>
	 *  one can start with an alpha factor of 10 to get 1+1 incase nodes are going <br>
	 *  to be added dynamically or incase the active service units are supposed to<br>
	 *  be restricted. Making it 20, would give 2+1. So one can add the third blade<br>
	 *  and then change alpha factor to 20. By default, the alpha factor is set to <br>
	 *  100 which takes into account, all the available service units. The <br>
	 *  acceptable values for alpha factor are between 0 and 100. Providing a value <br>
	 *  of 0 would result in assigning 1 active service unit incase the available <br>
	 *  service units are less than preferred and SG has instantiable service units.<br>
	 *  \par Library  File: <br>
	 *  libClAmsMgmt <br>
	 *  \sa clAmsMgmtEntityGetConfig<br>
	 * Original signature : <code>int clAmsMgmtEntitySetAlphaFactor(ClAmsMgmtHandleT, ClAmsEntityT*, int)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:1290</i>
	 */
	int clAmsMgmtEntitySetAlphaFactor(long amsHandle, ClAmsEntityConfigT entity, int alphaFactor);
	/**
	 * ***********************************<br>
	 *  \brief Changes the beta factor configured for a given SG<br>
	 *  \par Header File: <br>
	 *  clAmsMgmtClientApi.h <br>
	 *  \param amsHandle (in) Handle identifying the initialization of the AML by the<br>
	 *  application obtained through earlier invocation of clAmsMgmtInitialize API.  <br>
	 *  \param entity (in) Name of the SG and type should be CL_AMS_ENTITY_TYPE_SG <br>
	 *  to get current alpha factor configured for the SG<br>
	 *  \param betaFactor (in) The value for the betaFactor which should be <br>
	 *  between 0 and 100.<br>
	 *  \retval CL_OK The function completed successfully.  <br>
	 *  \retval CL_ERR_INVALID_HANDLE Handle passed is not a valid handle obtained<br>
	 *  through an earlier call to clAmsMgmtInitialize API.  <br>
	 *  \retval CL_ERR_TIMEOUT Timeout occurred before the call could be completed. It is<br>
	 *  unspecified whether the call succeeded or whether it did not.  <br>
	 *  \retval CL_ERR_NO_MEMORY Either the AMS library or the provider of service is<br>
	 *  out of memory and cannot provide the service.  <br>
	 *  <br>
	 *  \retval CL_ERR_INVALID_PARAMETER The beta factor provided was invalid.<br>
	 *  \retval CL_ERR_NOT_EXIST The SG wasnt found in the AMS DB to change the beta factor<br>
	 *  \par Description: <br>
	 *  This API is used to change the SGs beta factor configuration. This variable<br>
	 *  limits the standby number of service units incase the available service units<br>
	 *  are less than the preferred standby service units. This variable helps to <br>
	 *  dynamically limit the standby service units that can be assigned work. <br>
	 *  Judicious usage of this variable would allow dynamic changes to redundancy <br>
	 *  mode at runtime without disrupting service. For example with a 10+1 model, <br>
	 *  one can start with an beta factor of 100 to get 1+1 incase nodes are going <br>
	 *  to be added dynamically or incase the active service units are supposed to<br>
	 *  be restricted. As nodes enter the cluster, it would increase slowly from 2+1 to 3+1,4+1,... 10+1. <br>
	 *  By default the value is set to 0 or disabled.<br>
	 *  The acceptable values for beta factor are between 0 and 100. <br>
	 *  \par Library  File: <br>
	 *  libClAmsMgmt <br>
	 *  \sa clAmsMgmtEntityGetConfig<br>
	 * Original signature : <code>int clAmsMgmtEntitySetBetaFactor(ClAmsMgmtHandleT, ClAmsEntityT*, int)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:1348</i>
	 */
	int clAmsMgmtEntitySetBetaFactor(long amsHandle, ClAmsEntityConfigT entity, int betaFactor);
	/**
	 * ***********************************<br>
	 *  \brief Initializes the AMS management control library.<br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param amlHandle (in) The AMS handle returned by the AMS on<br>
	 *  invocation of the clAmsMgmtInitialize() API.<br>
	 *  \param ccbHandle (out) The AMS management control handle returned<br>
	 *  by the library.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE The AMS management handle passed is<br>
	 *  invalid.<br>
	 *  \par Description:<br>
	 *  The clAmsMgmtCCBInitialize() establishes the applications<br>
	 *  association with the AMS management control library. Application<br>
	 *  must call this function before using any of the clAmsMgmtCCB*<br>
	 *  APIs.  The CCB functions are transactional.  Application then call<br>
	 *  a number of functions to modify the AMF state, and when complete<br>
	 *  call clAmsMgmtCCBCommit() to commit the changes to the AMF database.<br>
	 *  The application can then reuse the handle for another group of state<br>
	 *  modifications.<br>
	 *  However, if the application decides to abort the changes, it must call<br>
	 *  clAmsMgmtCCBFinalize(), and then clAmsMgmtCCBInitialize() to get a new<br>
	 *  handle.<br>
	 * *<br>
	 *  \par Library File:<br>
	 *  ClAmsMgmt<br>
	 *  \sa clAmsMgmtCCBCommit(), clAmsMgmtCCBFinalize()<br>
	 * Original signature : <code>int clAmsMgmtCCBInitialize(ClAmsMgmtHandleT, ClAmsMgmtCCBHandleT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:1391</i><br>
	 * use the safer methods {@link #clAmsMgmtCCBInitialize(long, java.nio.LongBuffer)} and {@link #clAmsMgmtCCBInitialize(long, com.sun.jna.ptr.LongByReference)} instead
	 */
	//@Deprecated 
	int clAmsMgmtCCBInitialize(long amlHandle, LongByReference ccbHandle);
	/**
	 * ***********************************<br>
	 *  \brief Initializes the AMS management control library.<br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param amlHandle (in) The AMS handle returned by the AMS on<br>
	 *  invocation of the clAmsMgmtInitialize() API.<br>
	 *  \param ccbHandle (out) The AMS management control handle returned<br>
	 *  by the library.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE The AMS management handle passed is<br>
	 *  invalid.<br>
	 *  \par Description:<br>
	 *  The clAmsMgmtCCBInitialize() establishes the applications<br>
	 *  association with the AMS management control library. Application<br>
	 *  must call this function before using any of the clAmsMgmtCCB*<br>
	 *  APIs.  The CCB functions are transactional.  Application then call<br>
	 *  a number of functions to modify the AMF state, and when complete<br>
	 *  call clAmsMgmtCCBCommit() to commit the changes to the AMF database.<br>
	 *  The application can then reuse the handle for another group of state<br>
	 *  modifications.<br>
	 *  However, if the application decides to abort the changes, it must call<br>
	 *  clAmsMgmtCCBFinalize(), and then clAmsMgmtCCBInitialize() to get a new<br>
	 *  handle.<br>
	 * *<br>
	 *  \par Library File:<br>
	 *  ClAmsMgmt<br>
	 *  \sa clAmsMgmtCCBCommit(), clAmsMgmtCCBFinalize()<br>
	 * Original signature : <code>int clAmsMgmtCCBInitialize(ClAmsMgmtHandleT, ClAmsMgmtCCBHandleT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:1391</i>
	 */
	//int clAmsMgmtCCBInitialize(long amlHandle, LongBuffer ccbHandle);
	/**
	 * ***********************************<br>
	 * \brief Finalizes the AMS management control library.<br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param ccbHandle (in) The CCB handle returned by the AMS on<br>
	 *  invocation of clAmsMgmtCCBInitialize() API.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE AMS management handle passed is<br>
	 *  invalid.<br>
	 *  \par Description:<br>
	 *  The clAmsMgmtCCBFinalize() calls removes the applications<br>
	 *  association with the AMS management control library, and aborts<br>
	 *  any pending operations.  After this call the application should no<br>
	 *  longer use this handle to call any AMS management control functions.<br>
	 *  \par Library File:<br>
	 *  ClAmsMgmt<br>
	 *  \sa clAmsMgmtCCBCommit(), clAmsMgmtCCBInitialize()<br>
	 * Original signature : <code>int clAmsMgmtCCBFinalize(ClAmsMgmtCCBHandleT)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:1424</i>
	 */
	int clAmsMgmtCCBFinalize(long ccbHandle);
	/**
	 * ***********************************<br>
	 *  \brief Applies the operation specific to CCB context in AMS DB<br>
	 *  atomically.<br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param ccbHandle (in) The CCB handle returned by the AMS on<br>
	 *  invocation of the clAmsMgmtCCBInitialize() API.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE AMS management handle passed is invalid.<br>
	 *  \par Description:<br>
	 *  The clAmsMgmtCCBCommit() API atomically carries out the previously<br>
	 *  specified AMS management control set operation(s) on the AMS<br>
	 *  DB. Applications must invoke this call ideally after they have<br>
	 *  called all the management control set APIs for the sets to take<br>
	 *  effect. <br>
	 *  After calling clAmsMgmtCCBCommit() the handle can be reused for another<br>
	 *  transaction.  To abort the transaction instead of committing, use<br>
	 *  clAmsMgmtCCBFinalize().<br>
	 *  \par Library File:<br>
	 *  ClAmsMgmt<br>
	 *  \sa clAmsMgmtCCBInitialize(), clAmsMgmtCCBFinalize()<br>
	 * Original signature : <code>int clAmsMgmtCCBCommit(ClAmsMgmtCCBHandleT)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:1461</i>
	 */
	int clAmsMgmtCCBCommit(long ccbHandle);
	/**
	 * ***********************************<br>
	 *  \brief Creates a new instance of an AMS entity.<br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param handle (in) The CCB handle returned by the AMS on<br>
	 *  invocation of the clAmsMgmtCCBInitialize() API.<br>
	 *  \param entity (in) The name and type of the new AMS entity to be<br>
	 *  created.<br>
	 * <br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE AMS management handle passed is invalid.<br>
	 *  \par Description:<br>
	 *  This API allows us to add new entity into an AMS database<br>
	 *  dynamically. The newly added entity can be either SG, SI, CSI,<br>
	 *  Node, SU or Component, depending on the type specified in ClAmsEntityT.<br>
	 *  \par Library File:<br>
	 *  ClAmsMgmt<br>
	 *  \sa clAmsMgmtCCBEntityDelete()<br>
	 * Original signature : <code>int clAmsMgmtCCBEntityCreate(ClAmsMgmtCCBHandleT, const ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:1493</i>
	 */
	int clAmsMgmtCCBEntityCreate(long handle, ClAmsEntityConfigT entity);
	/**
	 * ***********************************<br>
	 *  \brief Deletes an instance of an AMS entity from AMS database.<br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param handle (in) The CCB handle returned by the AMS on<br>
	 *  invocation of the clAmsMgmtCCBInitialize() API.<br>
	 *  \param entity (in) The name and type of the new AMS entity to be<br>
	 *  deleted.<br>
	 * <br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE AMS management handle passed is invalid.<br>
	 *  \par Description:<br>
	 *  This API allows to delete an AMS entity from the AMS database<br>
	 *  dynamically. The entity to be removed can be either SG, SI, CSI,<br>
	 *  Node, SU or Component.<br>
	 *  \par Library File:<br>
	 *  ClAmsMgmt<br>
	 *  \sa clAmsMgmtCCBEntityCreate()<br>
	 * Original signature : <code>int clAmsMgmtCCBEntityDelete(ClAmsMgmtCCBHandleT, const ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:1525</i>
	 */
	int clAmsMgmtCCBEntityDelete(long handle, ClAmsEntityConfigT entity);
	/**
	 * ***********************************<br>
	 *  \brief Sets one or more scalar attributes of an AMS entity.<br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param handle (in) The CCB handle returned by the AMS on<br>
	 *  invocation of the clAmsMgmtCCBInitialize() API.<br>
	 *  \param entityConfig (in) New configuration values for the AMS<br>
	 *  entity attributes(s) whose configuration is being set. AMS entity<br>
	 *  name and type is also specified in this structure.<br>
	 *  \param bitmask (in) Mask specifying the attribute(s) whose value<br>
	 *  is being set to new values.<br>
	 * <br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE AMS management handle passed is invalid.<br>
	 *  \par Description:<br>
	 *  This API allows us to set one or more of the single valued<br>
	 *  attribute(s) of an AMS entity. Two set more than one attribute,<br>
	 *  the bitMasks representing those attributes can be bitwise<br>
	 *  ORed. The entity can be a SG, SI, CSI, Node, SU or<br>
	 *  Component. Following paragraphs show what attributes of a<br>
	 *  particular entity can be set.<br>
	 *  \par SG:<br>
	 *  \arg \c SG_CONFIG_ADMIN_STATE<br>
	 *  \par SI:<br>
	 *  \arg \c SI_CONFIG_NUM_STANDBY_ASSIGNMENTS<br>
	 *  \par Component:<br>
	 *  \arg \c COMP_CONFIG_TIMEOUTS<br>
	 *  \arg \c COMP_CONFIG_CAPABILITY_MODEL<br>
	 *  \arg \c COMP_CONFIG_RECOVERY_ON_TIMEOUT<br>
	 *  \arg \c COMP_CONFIG_INSTANTIATE_COMMAND<br>
	 *  \par Library File:<br>
	 *  ClAmsMgmt<br>
	 *  \sa None<br>
	 * Original signature : <code>int clAmsMgmtCCBEntitySetConfig(ClAmsMgmtCCBHandleT, ClAmsEntityConfigT*, ClUint64T)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:1574</i>
	 */
	int clAmsMgmtCCBEntitySetConfig(long handle, ClAmsEntityConfigT entityConfig, long bitMask);
	/**
	 * ***********************************<br>
	 *  \brief Sets or creates a name value pair for a CSI.<br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param handle (in) The CCB handle returned by the AMS on<br>
	 *  invocation of the clAmsMgmtCCBInitialize() API.<br>
	 *  \param csiName (in) The name of the CSI.<br>
	 *  \param nvp (in) The name value pair to be set/created.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE AMS management handle passed is invalid.<br>
	 *  \par Description:<br>
	 *  This API sets a name value pair for the component service<br>
	 *  instance. If the name value pair specified does not already exist<br>
	 *  for the CSI, then AMS creates the name value pair.<br>
	 *  \par Library File:<br>
	 *  ClAmsMgmt<br>
	 *  \sa clAmsMgmtCCBCSIDeleteNVP()<br>
	 * Original signature : <code>int clAmsMgmtCCBCSISetNVP(ClAmsMgmtCCBHandleT, ClAmsEntityT*, ClAmsCSINVPT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:1607</i>
	 */
	int clAmsMgmtCCBCSISetNVP(long handle, ClAmsEntityConfigT csiName, ClAmsCSINameValuePairT nvp);
	/**
	 * ***********************************<br>
	 *  \brief Deletes a name value pair for a CSI.<br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param handle (in) The CCB handle returned by the AMS on<br>
	 *  invocation of the clAmsMgmtCCBInitialize() API.<br>
	 *  \param csiName (in) The name of the CSI.<br>
	 *  \param nvp (in) The name value pair for the CSI to be deleted.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE AMS management handle passed is invalid.<br>
	 *  \retval CL_ERR_NOT_EXIST The CSI specified by the \e csiName<br>
	 *  doesn't exist in AMS database.<br>
	 *  \par Description:<br>
	 *  This API deletes a name value pair of the component service<br>
	 *  instance.<br>
	 *  \par Library File:<br>
	 *  ClAmsMgmt<br>
	 *  \sa clAmsMgmtCCBCSISetNVP()<br>
	 * Original signature : <code>int clAmsMgmtCCBCSIDeleteNVP(ClAmsMgmtCCBHandleT, ClAmsEntityT*, ClAmsCSINVPT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:1641</i>
	 */
	int clAmsMgmtCCBCSIDeleteNVP(long handle, ClAmsEntityConfigT csiName, ClAmsCSINameValuePairT nvp);
	/**
	 * ***********************************<br>
	 *  \brief Adds a node to the node dependencies list of an AMS node.<br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param handle (in) The CCB handle returned by the AMS on<br>
	 *  invocation of the clAmsMgmtCCBInitialize() API.<br>
	 *  \param nodeName (in) Name of the node whose dependency list is<br>
	 *  being modified.<br>
	 *  \param dependencyNodeName (in) Name of the dependent node to be<br>
	 *  added in the node's dependencies list.<br>
	 * <br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE AMS management handle passed is invalid.<br>
	 *  \retval CL_ERR_DOESNT_EXIST The node specified by the \e nodeName<br>
	 *  doesn't exist in AMS database.<br>
	 *  \par Description:<br>
	 *  This API allows adding one node at a time to the dependency list<br>
	 *  of a particular node. Node dependency plays roles during CSI<br>
	 *  assignment, CSI removal etc and generally means that the dependent<br>
	 *  node cannot function properly without the node upon which it<br>
	 *  depends.<br>
	 *  \par Library File:<br>
	 *  ClAmsMgmt<br>
	 *  \sa clAmsMgmtCCBDeleteNodeDependency()<br>
	 * Original signature : <code>int clAmsMgmtCCBSetNodeDependency(ClAmsMgmtCCBHandleT, ClAmsEntityT*, ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:1680</i>
	 */
	int clAmsMgmtCCBSetNodeDependency(long handle, ClAmsEntityConfigT nodeName, ClAmsEntityConfigT dependencyNodeName);
	/**
	 * ***********************************<br>
	 *  \brief Deletes a node from the node dependencies list of an AMS<br>
	 *  node.<br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param handle (in) The CCB handle returned by the AMS on<br>
	 *  invocation of the clAmsMgmtCCBInitialize() API.<br>
	 *  \param nodeName (in) Name of the node whose dependency list is<br>
	 *  being modified.<br>
	 *  \param dependencyNodeName (in) Name of the dependent node to be<br>
	 *  removed from the node's dependencies list.<br>
	 * <br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE AMS management handle passed is invalid.<br>
	 *  \retval CL_ERR_DOESNT_EXIST The node specified by the \e nodeName<br>
	 *  doesn't exist in AMS database.<br>
	 *  \par Description:<br>
	 *  This API allows removing one node at a time from the dependency list<br>
	 *  of a particular node.<br>
	 *  \par Library File:<br>
	 *  ClAmsMgmt<br>
	 *  \sa clAmsMgmtCCBSetNodeDependency()<br>
	 * Original signature : <code>int clAmsMgmtCCBDeleteNodeDependency(ClAmsMgmtCCBHandleT, ClAmsEntityT*, ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:1717</i>
	 */
	int clAmsMgmtCCBDeleteNodeDependency(long handle, ClAmsEntityConfigT nodeName, ClAmsEntityConfigT dependencyNodeName);
	/**
	 * ***********************************<br>
	 *  \brief Adds a SU to the SU list of an AMS node.<br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param handle (in) The CCB handle returned by the AMS on<br>
	 *  invocation of the clAmsMgmtCCBInitialize() API.<br>
	 *  \param nodeName (in) Name of the node whose SU list is being<br>
	 *  modified.<br>
	 *  \param suName (in) Name of SU being added to the SU list of the<br>
	 *  node.<br>
	 * <br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE AMS management handle passed is invalid.<br>
	 *  \retval CL_ERR_DOESNT_EXIST The node specified by the \e nodeName<br>
	 *  doesn't exist in AMS database.<br>
	 *  \par Description:<br>
	 *  This API allows us to add one SU at a time to the SU list of a<br>
	 *  node. By adding an SU to SU list of a node, we are establishing a<br>
	 *  containment relation that the SU represented by \e suName is<br>
	 *  contained in the node \e nodeName.<br>
	 *  \par Library File:<br>
	 *  ClAmsMgmt<br>
	 *  \sa clAmsMgmtCCBDeleteNodeSUList()<br>
	 * Original signature : <code>int clAmsMgmtCCBSetNodeSUList(ClAmsMgmtCCBHandleT, ClAmsEntityT*, ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:1755</i>
	 */
	int clAmsMgmtCCBSetNodeSUList(long handle, ClAmsEntityConfigT nodeName, ClAmsEntityConfigT suName);
	/**
	 * ***********************************<br>
	 *  \brief Removes a SU from the SU list of an AMS node.<br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param handle (in) The CCB handle returned by the AMS on<br>
	 *  invocation of the clAmsMgmtCCBInitialize() API.<br>
	 *  \param nodeName (in) Name of the node whose SU list is being<br>
	 *  modified.<br>
	 *  \param suName (in) Name of SU to be removed from the SU list of<br>
	 *  the node.<br>
	 * <br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE AMS management handle passed is invalid.<br>
	 *  \retval CL_ERR_DOESNT_EXIST The node specified by the \e nodeName<br>
	 *  doesn't exist in AMS database.<br>
	 *  \par Description:<br>
	 *  This API allows us to remove one SU at a time from the su list of<br>
	 *  a node. By removing an SU to SU list of a node, we are destroying<br>
	 *  a containment relation that the SU represented by \e suName is<br>
	 *  contained in the node \e nodeName.<br>
	 *  \par Library File:<br>
	 *  ClAmsMgmt<br>
	 *  \sa clAmsMgmtCCBSetNodeSUList()<br>
	 * Original signature : <code>int clAmsMgmtCCBDeleteNodeSUList(ClAmsMgmtCCBHandleT, ClAmsEntityT*, ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:1793</i>
	 */
	int clAmsMgmtCCBDeleteNodeSUList(long handle, ClAmsEntityConfigT nodeName, ClAmsEntityConfigT suName);
	/**
	 * ***********************************<br>
	 *  \brief Adds a SU to the SU list of an AMS SG.<br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param handle (in) The CCB handle returned by the AMS on<br>
	 *  invocation of the clAmsMgmtCCBInitialize() API.<br>
	 *  \param sgName (in) Name of the SG whose SU list is being modified.<br>
	 *  \param suName (in) Name of SU being added to the SU list of the<br>
	 *  SG.<br>
	 * <br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE AMS management handle passed is invalid.<br>
	 *  \retval CL_ERR_DOESNT_EXIST The SG specified by the \e sgName<br>
	 *  doesn't exist in AMS database.<br>
	 *  \par Description:<br>
	 *  This API allows us to add one SU at a time to the SU list of a<br>
	 *  SG. By adding an SU to SU list of a SG, we are establishing a<br>
	 *  containment relation that the SU represented by \e suName is<br>
	 *  contained (protected by) in the SG \e sgName for the purposes of<br>
	 *  carrying out high availability functions like switchover/failover<br>
	 *  etc.<br>
	 *  \par Library File:<br>
	 *  ClAmsMgmt<br>
	 *  \sa clAmsMgmtCCBDeleteSGSUList()<br>
	 * Original signature : <code>int clAmsMgmtCCBSetSGSUList(ClAmsMgmtCCBHandleT, ClAmsEntityT*, ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:1832</i>
	 */
	int clAmsMgmtCCBSetSGSUList(long handle, ClAmsEntityConfigT sgName, ClAmsEntityConfigT suName);
	/**
	 * ***********************************<br>
	 *  \brief Deletes a SU from the SU list of an AMS SG.<br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param handle (in) The CCB handle returned by the AMS on<br>
	 *  invocation of the clAmsMgmtCCBInitialize() API.<br>
	 *  \param sgName (in) Name of the SG whose SU list is being modified.<br>
	 *  \param suName (in) Name of SU that is removed from the SU list of<br>
	 *  the SG.<br>
	 * <br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE AMS management handle passed is invalid.<br>
	 *  \retval CL_ERR_DOESNT_EXIST The SG specified by the \e sgName<br>
	 *  doesn't exist in AMS database.<br>
	 *  \par Description:<br>
	 *  This API allows us to remove one SU at a time from the SU list of<br>
	 *  a SG. By removing an SU from SU list of a SG, we are destroying a<br>
	 *  containment relation that the SU represented by \e suName is<br>
	 *  contained (protected by) in the SG \e sgName for the purposes of<br>
	 *  carrying out high availability functions like switchover/failover<br>
	 *  etc.<br>
	 *  \par Library File:<br>
	 *  ClAmsMgmt<br>
	 *  \sa clAmsMgmtCCBSetSGSUList()<br>
	 * Original signature : <code>int clAmsMgmtCCBDeleteSGSUList(ClAmsMgmtCCBHandleT, ClAmsEntityT*, ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:1871</i>
	 */
	int clAmsMgmtCCBDeleteSGSUList(long handle, ClAmsEntityConfigT sgName, ClAmsEntityConfigT suName);
	/**
	 * ***********************************<br>
	 *  \brief Adds a SI to the SI list of an AMS SG.<br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param handle (in) The CCB handle returned by the AMS on<br>
	 *  invocation of the clAmsMgmtCCBInitialize() API.<br>
	 *  \param sgName (in) Name of the SG whose SU list is being modified.<br>
	 *  \param siName (in) Name of SI being added to the SI list of the<br>
	 *  SG.<br>
	 * <br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE AMS management handle passed is invalid.<br>
	 *  \retval CL_ERR_DOESNT_EXIST The SG specified by the \e sgName<br>
	 *  doesn't exist in AMS database.<br>
	 *  \par Description:<br>
	 *  This API allows us to add one SI at a time to the SI list of a<br>
	 *  SG. By adding an SI to SI list of a SG, we are establishing a<br>
	 *  containment relation that the SI represented by \e siName is<br>
	 *  contained (protected by) in the SG \e sgName for the purposes of<br>
	 *  carrying out high availability functions.<br>
	 *  \par Library File:<br>
	 *  ClAmsMgmt<br>
	 *  \sa clAmsMgmtCCBDeleteSGSIList()<br>
	 * Original signature : <code>int clAmsMgmtCCBSetSGSIList(ClAmsMgmtCCBHandleT, ClAmsEntityT*, ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:1909</i>
	 */
	int clAmsMgmtCCBSetSGSIList(long handle, ClAmsEntityConfigT sgName, ClAmsEntityConfigT siName);
	/**
	 * ***********************************<br>
	 *  \brief Deletes a SI from the SI list of an AMS SG.<br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param handle (in) The CCB handle returned by the AMS on<br>
	 *  invocation of the clAmsMgmtCCBInitialize() API.<br>
	 *  \param sgName (in) Name of the SG whose SI list is being modified.<br>
	 *  \param siName (in) Name of SI that is removed from the SI list of<br>
	 *  the SG.<br>
	 * <br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE AMS management handle passed is invalid.<br>
	 *  \retval CL_ERR_DOESNT_EXIST The SG specified by the \e sgName<br>
	 *  doesn't exist in AMS database.<br>
	 *  \par Description:<br>
	 *  This API allows us to remove one SI at a time from the SI list of<br>
	 *  a SG. By removing an SI from SI list of a SG, we are destroying a<br>
	 *  containment relation that the SI represented by \e siName is<br>
	 *  contained (protected by) in the SG \e sgName for the purposes of<br>
	 *  carrying out high availability functions.<br>
	 *  \par Library File:<br>
	 *  ClAmsMgmt<br>
	 *  \sa clAmsMgmtCCBSetSGSIList()<br>
	 * Original signature : <code>int clAmsMgmtCCBDeleteSGSIList(ClAmsMgmtCCBHandleT, ClAmsEntityT*, ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:1947</i>
	 */
	int clAmsMgmtCCBDeleteSGSIList(long handle, ClAmsEntityConfigT sgName, ClAmsEntityConfigT siName);
	/**
	 * ***********************************<br>
	 *  \brief Adds a component to the component list of an AMS SU.<br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param handle (in) The CCB handle returned by the AMS on<br>
	 *  invocation of the clAmsMgmtCCBInitialize() API.<br>
	 *  \param suName (in) Name of the SU whose component list is being<br>
	 *  modified.<br>
	 *  \param compName (in) Name of component being added to the<br>
	 *  component list of the SU.<br>
	 * <br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE AMS management handle passed is invalid.<br>
	 *  \retval CL_ERR_DOESNT_EXIST The SU specified by the \e suName<br>
	 *  doesn't exist in AMS database.<br>
	 *  \par Description:<br>
	 *  This API allows us to add one component at a time to the component<br>
	 *  list of a SU. By adding an component to component list of a SU, we<br>
	 *  are establishing a containment relation that the component \e<br>
	 *  compName is contained in the SU \e suName for the purposes of<br>
	 *  carrying out high availability functions like fault escalation<br>
	 *  etc.<br>
	 *  \par Library File:<br>
	 *  ClAmsMgmt<br>
	 *  \sa clAmsMgmtCCBDeleteSUCompList()<br>
	 * Original signature : <code>int clAmsMgmtCCBSetSUCompList(ClAmsMgmtCCBHandleT, ClAmsEntityT*, ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:1987</i>
	 */
	int clAmsMgmtCCBSetSUCompList(long handle, ClAmsEntityConfigT suName, ClAmsEntityConfigT compName);
	/**
	 * ***********************************<br>
	 *  \brief Removes a component from the component list of an AMS SU.<br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param handle (in) The CCB handle returned by the AMS on<br>
	 *  invocation of the clAmsMgmtCCBInitialize() API.<br>
	 *  \param suName (in) Name of the SU whose component list is being<br>
	 *  modified.<br>
	 *  \param compName (in) Name of component that is being removed from<br>
	 *  the component list of the SU.<br>
	 * <br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE AMS management handle passed is invalid.<br>
	 *  \retval CL_ERR_DOESNT_EXIST The SU specified by the \e suName<br>
	 *  doesn't exist in AMS database.<br>
	 *  \par Description:<br>
	 *  This API allows us to remove one component at a time from the<br>
	 *  component list of a SU. By adding an component to component list<br>
	 *  of a SU, we are destroying a containment relation that the<br>
	 *  component \e compName is contained in the SU \e suName for the<br>
	 *  purposes of carrying out high availability functions like fault<br>
	 *  escalation etc.<br>
	 *  \par Library File:<br>
	 *  ClAmsMgmt<br>
	 *  \sa clAmsMgmtCCBSetSUCompList()<br>
	 * Original signature : <code>int clAmsMgmtCCBDeleteSUCompList(ClAmsMgmtCCBHandleT, ClAmsEntityT*, ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2027</i>
	 */
	int clAmsMgmtCCBDeleteSUCompList(long handle, ClAmsEntityConfigT suName, ClAmsEntityConfigT compName);
	/**
	 * ***********************************<br>
	 *  \brief Adds a SU in the SU rank list for an AMS SI.<br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param handle (in) The CCB handle returned by the AMS on<br>
	 *  invocation of the clAmsMgmtCCBInitialize() API.<br>
	 *  \param siName (in) Name of the SI whose SU rank list is being<br>
	 *  modified.<br>
	 *  \param suName (in) Name of SU being added to the SU rank list of<br>
	 *  the SI.<br>
	 * <br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE AMS management handle passed is invalid.<br>
	 *  \retval CL_ERR_DOESNT_EXIST The SI specified by the \e siName<br>
	 *  doesn't exist in AMS database.<br>
	 *  \par Description:<br>
	 *  This API allows us to add one SU at a time to the SU rank list of<br>
	 *  a SI. By adding an SU to SU rank list of a SI, we are establishing<br>
	 *  a association relation that the SU \e suName is associated with<br>
	 *  the SI \e siName for the purposes of carrying out high<br>
	 *  availability functions like work assignment etc.<br>
	 *  \par Library File:<br>
	 *  ClAmsMgmt<br>
	 *  \sa clAmsMgmtCCBDeleteSISURankList()<br>
	 * Original signature : <code>int clAmsMgmtCCBSetSISURankList(ClAmsMgmtCCBHandleT, ClAmsEntityT*, ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2066</i>
	 */
	int clAmsMgmtCCBSetSISURankList(long handle, ClAmsEntityConfigT siName, ClAmsEntityConfigT suName);
	/**
	 * ***********************************<br>
	 *  \brief Removes a SU from the SU rank list for an AMS SI.<br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param handle (in) The CCB handle returned by the AMS on<br>
	 *  invocation of the clAmsMgmtCCBInitialize() API.<br>
	 *  \param siName (in) Name of the SI whose SU rank list is being<br>
	 *  modified.<br>
	 *  \param suName (in) Name of SU that is removed from the SU rank<br>
	 *  list of the SI.<br>
	 * <br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE AMS management handle passed is invalid.<br>
	 *  \retval CL_ERR_DOESNT_EXIST The SI specified by the \e siName<br>
	 *  doesn't exist in AMS database.<br>
	 *  \par Description:<br>
	 *  This API allows us to remove one SU at a time from the SU rank<br>
	 *  list of a SI. By removing a SU from SU rank list of a SI, we are<br>
	 *  destroying the association relation that the SU \e suName is<br>
	 *  associated with the SI \e siName for the purposes of carrying out<br>
	 *  high availability functions like work assignment etc.<br>
	 *  \par Library File:<br>
	 *  ClAmsMgmt<br>
	 *  \sa clAmsMgmtCCBSetSISURankList()<br>
	 * Original signature : <code>int clAmsMgmtCCBDeleteSISURankList(ClAmsMgmtCCBHandleT, ClAmsEntityT*, ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2105</i>
	 */
	int clAmsMgmtCCBDeleteSISURankList(long handle, ClAmsEntityConfigT siName, ClAmsEntityConfigT suName);
	/**
	 * ***********************************<br>
	 *  \brief Adds a SI in the SI dependencies list for an AMS SI.<br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param handle (in) The CCB handle returned by the AMS on<br>
	 *  invocation of the clAmsMgmtCCBInitialize() API.<br>
	 *  \param siName (in) Name of the SI whose dependency list is being<br>
	 *  modified.<br>
	 *  \param dependencySIName (in) Name of the dependent si to be<br>
	 *  added in the SI's dependencies list.<br>
	 * <br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE AMS management handle passed is invalid.<br>
	 *  \retval CL_ERR_DOESNT_EXIST The si specified by the \e siName<br>
	 *  doesn't exist in AMS database.<br>
	 *  \par Description:<br>
	 *  This API allows adding one SI at a time to the dependency list of<br>
	 *  a particular SI. SI dependency plays roles during CSI assignment,<br>
	 *  CSI removal etc and generally means that the dependent SI must be<br>
	 *  operated upon before operating on the SI that depends on it.<br>
	 *  \par Library File:<br>
	 *  ClAmsMgmt<br>
	 *  \sa clAmsMgmtCCBDeleteSIDependency()<br>
	 * Original signature : <code>int clAmsMgmtCCBSetSIDependency(ClAmsMgmtCCBHandleT, ClAmsEntityT*, ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2142</i>
	 */
	int clAmsMgmtCCBSetSIDependency(long handle, ClAmsEntityConfigT siName, ClAmsEntityConfigT dependencySIName);
	/**
	 * ***********************************<br>
	 *  \brief Deletes a SI from the SI dependencies list for an AMS SI.<br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param handle (in) The CCB handle returned by the AMS on<br>
	 *  invocation of the clAmsMgmtCCBInitialize() API.<br>
	 *  \param siName (in) Name of the SI whose dependency list is being<br>
	 *  modified.<br>
	 *  \param dependencySIName (in) Name of the dependent SI to be<br>
	 *  removed from the SI's dependencies list.<br>
	 * <br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE AMS management handle passed is invalid.<br>
	 *  \retval CL_ERR_DOESNT_EXIST The SI specified by the \e siName<br>
	 *  doesn't exist in AMS database.<br>
	 *  \par Description:<br>
	 *  This API allows removing one SI at a time from the dependency list<br>
	 *  of a particular SI.<br>
	 *  \par Library File:<br>
	 *  ClAmsMgmt<br>
	 *  \sa clAmsMgmtCCBSetSIDependency()<br>
	 * Original signature : <code>int clAmsMgmtCCBDeleteSIDependency(ClAmsMgmtCCBHandleT, ClAmsEntityT*, ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2178</i>
	 */
	int clAmsMgmtCCBDeleteSIDependency(long handle, ClAmsEntityConfigT siName, ClAmsEntityConfigT dependencySIName);
	/**
	 * ***********************************<br>
	 *  \brief Adds a CSI in the CSI dependencies list for an AMS CSI.<br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param handle (in) The CCB handle returned by the AMS on<br>
	 *  invocation of the clAmsMgmtCCBInitialize() API.<br>
	 *  \param csiName (in) Name of the CSI whose dependency list is being<br>
	 *  modified.<br>
	 *  \param dependencyCSIName (in) Name of the dependent csi to be<br>
	 *  added in the CSI's dependencies list.<br>
	 * <br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE AMS management handle passed is invalid.<br>
	 *  \retval CL_ERR_DOESNT_EXIST The csi specified by the \e csiName<br>
	 *  doesn't exist in AMS database.<br>
	 *  \par Description:<br>
	 *  This API allows adding one CSI at a time to the dependency list of<br>
	 *  a particular CSI. CSI dependency plays roles during CSI assignment,<br>
	 *  CSI removal etc and generally means that the dependent CSI must be<br>
	 *  operated upon before operating on the CSI that depends on it.<br>
	 *  \par Library File:<br>
	 *  ClAmsMgmt<br>
	 *  \sa clAmsMgmtCCBDeleteCSIDependency()<br>
	 * Original signature : <code>int clAmsMgmtCCBSetCSIDependency(ClAmsMgmtCCBHandleT, ClAmsEntityT*, ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2216</i>
	 */
	int clAmsMgmtCCBSetCSIDependency(long handle, ClAmsEntityConfigT csiName, ClAmsEntityConfigT dependencyCSIName);
	/**
	 * ***********************************<br>
	 *  \brief Deletes a CSI from the CSI dependencies list for an AMS CSI.<br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param handle (in) The CCB handle returned by the AMS on<br>
	 *  invocation of the clAmsMgmtCCBInitialize() API.<br>
	 *  \param csiName (in) Name of the CSI whose dependency list is being<br>
	 *  modified.<br>
	 *  \param dependencyCSIName (in) Name of the dependent CSI to be<br>
	 *  removed from the CSI's dependencies list.<br>
	 * <br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE AMS management handle passed is invalid.<br>
	 *  \retval CL_ERR_DOESNT_EXIST The CSI specified by the \e csiName<br>
	 *  doesn't exist in AMS database.<br>
	 *  \par Description:<br>
	 *  This API allows removing one CSI at a time from the dependency list<br>
	 *  of a particular CSI.<br>
	 *  \par Library File:<br>
	 *  ClAmsMgmt<br>
	 *  \sa clAmsMgmtCCBDeleteCSIDependency()<br>
	 * Original signature : <code>int clAmsMgmtCCBDeleteCSIDependency(ClAmsMgmtCCBHandleT, ClAmsEntityT*, ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2251</i>
	 */
	int clAmsMgmtCCBDeleteCSIDependency(long handle, ClAmsEntityConfigT csiName, ClAmsEntityConfigT dependencyCSIName);
	/**
	 * ***********************************<br>
	 *  \brief Adds a CSI in the CSI list for an AMS SI.<br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param handle (in) The CCB handle returned by the AMS on<br>
	 *  invocation of the clAmsMgmtCCBInitialize() API.<br>
	 *  \param siName (in) Name of the SI whose CSI list is being<br>
	 *  modified.<br>
	 *  \param csiName (in) Name of CSI being added to the CSI list of the<br>
	 *  SI.<br>
	 * <br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE AMS management handle passed is invalid.<br>
	 *  \retval CL_ERR_DOESNT_EXIST The SI specified by the \e siName<br>
	 *  doesn't exist in AMS database.<br>
	 *  \par Description:<br>
	 *  This API allows us to add one CSI at a time to the CSI list of a<br>
	 *  SI. By adding a CSI to CSI list of a SI, we are establishing a<br>
	 *  containment relation that the CSI \e csiName is contained in the<br>
	 *  SI \e siName for the purposes of carrying out high availability<br>
	 *  functions like fault escalation etc.<br>
	 *  \par Library File:<br>
	 *  ClAmsMgmt<br>
	 *  \sa clAmsMgmtCCBDeleteSICSIList()<br>
	 * Original signature : <code>int clAmsMgmtCCBSetSICSIList(ClAmsMgmtCCBHandleT, ClAmsEntityT*, ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2290</i>
	 */
	int clAmsMgmtCCBSetSICSIList(long handle, ClAmsEntityConfigT siName, ClAmsEntityConfigT csiName);
	/**
	 * ***********************************<br>
	 *  \brief Removes a CSI from the CSI list for an AMS SI.<br>
	 *  \par Header File:<br>
	 *  clAmsMgmtClientApi.h<br>
	 *  \param handle (in) The CCB handle returned by the AMS on<br>
	 *  invocation of the clAmsMgmtCCBInitialize() API.<br>
	 *  \param siName (in) Name of the SI whose CSI list is being<br>
	 *  modified.<br>
	 *  \param csiName (in) Name of CSI that is being removed from the CSI<br>
	 *  list of the SI.<br>
	 * <br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE AMS management handle passed is invalid.<br>
	 *  \retval CL_ERR_DOESNT_EXIST The SI specified by the \e siName<br>
	 *  doesn't exist in AMS database.<br>
	 *  \par Description:<br>
	 *  This API allows us to remove one CSI at a time from the CSI list<br>
	 *  of a SI. By adding an CSI to CSI list of a SI, we are destroying a<br>
	 *  containment relation that the CSI \e csiName is contained in the<br>
	 *  SI \e siName for the purposes of carrying out high availability<br>
	 *  functions like fault escalation etc.<br>
	 *  \par Library File:<br>
	 *  ClAmsMgmt<br>
	 *  \sa clAmsMgmtCCBSetSICSIList()<br>
	 * Original signature : <code>int clAmsMgmtCCBDeleteSICSIList(ClAmsMgmtCCBHandleT, ClAmsEntityT*, ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2329</i>
	 */
	int clAmsMgmtCCBDeleteSICSIList(long handle, ClAmsEntityConfigT siName, ClAmsEntityConfigT csiName);
	/**
	 * \brief Returns the configuration and status scalar attributes of an AMS entity<br>
	 * \param handle      Handle returned by the AML on invocation of clAmsMgmtInitialize API.<br>
	 * \param entityRef   Name of the AMS entity whose configuration and status attributes are queried. The attributes are also returned in this structure.<br>
	 * *<br>
	 * \return OpenClovis return code<br>
	 * \retval  CL_OK                     Operation successful<br>
	 * \retval  CL_ERR_INVALID_HANDLE     Error: AML CCB Handle is invalid<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>int clAmsMgmtEntityGet(ClAmsMgmtHandleT, ClAmsEntityRefT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2351</i>
	 */
	int clAmsMgmtEntityGet(long handle, ClAmsEntityRefT.ByReference entityRef);
	/**
	 * \brief Returns the configuration scalar attributes of an AMF entity<br>
	 * \param handle       Handle returned by the AML on invocation of clAmsMgmtInitialize API.<br>
	 * \param entity       Name of the AMS entity whose configuration attributes are queried<br>
	 * \param entityConfig Entity configuration structure returned by AMF<br>
	 * \return OpenClovis return code<br>
	 * \retval CL_OK                      Operation successful<br>
	 * \retval CL_ERR_INVALID_HANDLE      Error: AML CCB Handle is invalid<br>
	 * \retval CL_AMS_ERR_INVALID_ENTITY  The entity is not valid<br>
	 * \retval CL_ERR_NOT_EXIST           The entity does not exist<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>int clAmsMgmtEntityGetConfig(ClAmsMgmtHandleT, ClAmsEntityT*, ClAmsEntityConfigT**)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2374</i><br>
	 * use the safer method {@link #clAmsMgmtEntityGetConfig(long, clAmsMgmtClientApi.ClAmsEntityConfigT, clAmsMgmtClientApi.ClAmsEntityConfigT.ByReference[])} instead
	 */
	//@Deprecated 
	int clAmsMgmtEntityGetConfig(long handle, ClAmsEntityConfigT entity, PointerByReference entityConfig);
	/**
	 * \brief Returns the configuration scalar attributes of an AMF entity<br>
	 * \param handle       Handle returned by the AML on invocation of clAmsMgmtInitialize API.<br>
	 * \param entity       Name of the AMS entity whose configuration attributes are queried<br>
	 * \param entityConfig Entity configuration structure returned by AMF<br>
	 * \return OpenClovis return code<br>
	 * \retval CL_OK                      Operation successful<br>
	 * \retval CL_ERR_INVALID_HANDLE      Error: AML CCB Handle is invalid<br>
	 * \retval CL_AMS_ERR_INVALID_ENTITY  The entity is not valid<br>
	 * \retval CL_ERR_NOT_EXIST           The entity does not exist<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>int clAmsMgmtEntityGetConfig(ClAmsMgmtHandleT, ClAmsEntityT*, ClAmsEntityConfigT**)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2374</i>
	 */
	//int clAmsMgmtEntityGetConfig(long handle, ClAmsEntityConfigT entity, ClAmsEntityConfigT.ByReference entityConfig[]);
	/**
	 * \brief Returns the configuration information for nodes<br>
	 * \param handle Handle returned by the AML on invocation of clAmsMgmtInitialize() API.<br>
	 * \param entName Null terminated name of the AMS entity.<br>
	 * \return NULL entity does not exist, or a pointer to the entity configuration.  You must free (clHeapFree) this pointer.<br>
	 * \par Description:<br>
	 * This is a convenience function that returns the current configuration of the entity by<br>
	 * calling clAmsMgmtEntityGetConfig with the correct ClAmsEntityT structure.<br>
	 * \sa clAmsMgmtEntityGetConfig()<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>ClAmsNodeConfigT* clAmsMgmtNodeGetConfig(ClAmsMgmtHandleT, const ClCharT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2396</i><br>
	 * @deprecated use the safer methods {@link #clAmsMgmtNodeGetConfig(long, java.nio.ByteBuffer)} and {@link #clAmsMgmtNodeGetConfig(long, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	ClAmsNodeConfigT clAmsMgmtNodeGetConfig(long handle, Pointer entName);
	/**
	 * \brief Returns the configuration information for nodes<br>
	 * \param handle Handle returned by the AML on invocation of clAmsMgmtInitialize() API.<br>
	 * \param entName Null terminated name of the AMS entity.<br>
	 * \return NULL entity does not exist, or a pointer to the entity configuration.  You must free (clHeapFree) this pointer.<br>
	 * \par Description:<br>
	 * This is a convenience function that returns the current configuration of the entity by<br>
	 * calling clAmsMgmtEntityGetConfig with the correct ClAmsEntityT structure.<br>
	 * \sa clAmsMgmtEntityGetConfig()<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>ClAmsNodeConfigT* clAmsMgmtNodeGetConfig(ClAmsMgmtHandleT, const ClCharT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2396</i>
	 */
	ClAmsNodeConfigT clAmsMgmtNodeGetConfig(long handle, String entName);
	/**
	 * \brief Returns the configuration information for a service group<br>
	 * \param handle Handle returned by the AML on invocation of clAmsMgmtInitialize() API.<br>
	 * \param entName Null terminated name of the AMS entity.<br>
	 * \return NULL entity does not exist, or a pointer to the entity configuration.  You must free (clHeapFree) this pointer.<br>
	 * \par Description:<br>
	 * This is a convenience function that returns the current configuration of the entity by<br>
	 * calling clAmsMgmtEntityGetConfig with the correct ClAmsEntityT structure.<br>
	 * \sa clAmsMgmtEntityGetConfig()<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>ClAmsSGConfigT* clAmsMgmtServiceGroupGetConfig(ClAmsMgmtHandleT, const ClCharT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2417</i><br>
	 * @deprecated use the safer methods {@link #clAmsMgmtServiceGroupGetConfig(long, java.nio.ByteBuffer)} and {@link #clAmsMgmtServiceGroupGetConfig(long, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	ClAmsSGConfigT clAmsMgmtServiceGroupGetConfig(long handle, Pointer entName);
	/**
	 * \brief Returns the configuration information for a service group<br>
	 * \param handle Handle returned by the AML on invocation of clAmsMgmtInitialize() API.<br>
	 * \param entName Null terminated name of the AMS entity.<br>
	 * \return NULL entity does not exist, or a pointer to the entity configuration.  You must free (clHeapFree) this pointer.<br>
	 * \par Description:<br>
	 * This is a convenience function that returns the current configuration of the entity by<br>
	 * calling clAmsMgmtEntityGetConfig with the correct ClAmsEntityT structure.<br>
	 * \sa clAmsMgmtEntityGetConfig()<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>ClAmsSGConfigT* clAmsMgmtServiceGroupGetConfig(ClAmsMgmtHandleT, const ClCharT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2417</i>
	 */
	ClAmsSGConfigT clAmsMgmtServiceGroupGetConfig(long handle, String entName);
	/**
	 * \brief Returns the configuration information for a service unit.<br>
	 * \param handle Handle returned by the AML on invocation of clAmsMgmtInitialize() API.<br>
	 * \param entName Null terminated name of the AMS entity.<br>
	 * \return NULL entity does not exist, or a pointer to the entity configuration.  You must free (clHeapFree) this pointer.<br>
	 * \par Description:<br>
	 * This is a convenience function that returns the current configuration of the entity by<br>
	 * calling clAmsMgmtEntityGetConfig with the correct ClAmsEntityT structure.<br>
	 * \sa clAmsMgmtEntityGetConfig()<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>ClAmsSUConfigT* clAmsMgmtServiceUnitGetConfig(ClAmsMgmtHandleT, const ClCharT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2438</i><br>
	 * @deprecated use the safer methods {@link #clAmsMgmtServiceUnitGetConfig(long, java.nio.ByteBuffer)} and {@link #clAmsMgmtServiceUnitGetConfig(long, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	ClAmsSUConfigT clAmsMgmtServiceUnitGetConfig(long handle, Pointer entName);
	/**
	 * \brief Returns the configuration information for a service unit.<br>
	 * \param handle Handle returned by the AML on invocation of clAmsMgmtInitialize() API.<br>
	 * \param entName Null terminated name of the AMS entity.<br>
	 * \return NULL entity does not exist, or a pointer to the entity configuration.  You must free (clHeapFree) this pointer.<br>
	 * \par Description:<br>
	 * This is a convenience function that returns the current configuration of the entity by<br>
	 * calling clAmsMgmtEntityGetConfig with the correct ClAmsEntityT structure.<br>
	 * \sa clAmsMgmtEntityGetConfig()<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>ClAmsSUConfigT* clAmsMgmtServiceUnitGetConfig(ClAmsMgmtHandleT, const ClCharT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2438</i>
	 */
	ClAmsSUConfigT clAmsMgmtServiceUnitGetConfig(long handle, String entName);
	/**
	 * \brief Returns the configuration information for a service instance.<br>
	 * \param handle Handle returned by the AML on invocation of clAmsMgmtInitialize() API.<br>
	 * \param entName Null terminated name of the AMS entity.<br>
	 * \return NULL entity does not exist, or a pointer to the entity configuration.  You must free (clHeapFree) this pointer.<br>
	 * \par Description:<br>
	 * This is a convenience function that returns the current configuration of the entity by<br>
	 * calling clAmsMgmtEntityGetConfig with the correct ClAmsEntityT structure.<br>
	 * \sa clAmsMgmtEntityGetConfig()<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>ClAmsSIConfigT* clAmsMgmtServiceInstanceGetConfig(ClAmsMgmtHandleT, const ClCharT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2459</i><br>
	 * @deprecated use the safer methods {@link #clAmsMgmtServiceInstanceGetConfig(long, java.nio.ByteBuffer)} and {@link #clAmsMgmtServiceInstanceGetConfig(long, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	ClAmsSIConfigT clAmsMgmtServiceInstanceGetConfig(long handle, Pointer entName);
	/**
	 * \brief Returns the configuration information for a service instance.<br>
	 * \param handle Handle returned by the AML on invocation of clAmsMgmtInitialize() API.<br>
	 * \param entName Null terminated name of the AMS entity.<br>
	 * \return NULL entity does not exist, or a pointer to the entity configuration.  You must free (clHeapFree) this pointer.<br>
	 * \par Description:<br>
	 * This is a convenience function that returns the current configuration of the entity by<br>
	 * calling clAmsMgmtEntityGetConfig with the correct ClAmsEntityT structure.<br>
	 * \sa clAmsMgmtEntityGetConfig()<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>ClAmsSIConfigT* clAmsMgmtServiceInstanceGetConfig(ClAmsMgmtHandleT, const ClCharT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2459</i>
	 */
	ClAmsSIConfigT clAmsMgmtServiceInstanceGetConfig(long handle, String entName);
	/**
	 * \brief Returns the configuration information for a component service instance.<br>
	 * \param handle Handle returned by the AML on invocation of clAmsMgmtInitialize() API.<br>
	 * \param entName Null terminated name of the AMS entity.<br>
	 * \return NULL entity does not exist, or a pointer to the entity configuration.  You must free (clHeapFree) this pointer.<br>
	 * \par Description:<br>
	 * This is a convenience function that returns the current configuration of the entity by<br>
	 * calling clAmsMgmtEntityGetConfig with the correct ClAmsEntityT structure.<br>
	 * \sa clAmsMgmtEntityGetConfig()<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>ClAmsCSIConfigT* clAmsMgmtCompServiceInstanceGetConfig(ClAmsMgmtHandleT, const ClCharT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2480</i><br>
	 * @deprecated use the safer methods {@link #clAmsMgmtCompServiceInstanceGetConfig(long, java.nio.ByteBuffer)} and {@link #clAmsMgmtCompServiceInstanceGetConfig(long, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	ClAmsCSIConfigT clAmsMgmtCompServiceInstanceGetConfig(long handle, Pointer entName);
	/**
	 * \brief Returns the configuration information for a component service instance.<br>
	 * \param handle Handle returned by the AML on invocation of clAmsMgmtInitialize() API.<br>
	 * \param entName Null terminated name of the AMS entity.<br>
	 * \return NULL entity does not exist, or a pointer to the entity configuration.  You must free (clHeapFree) this pointer.<br>
	 * \par Description:<br>
	 * This is a convenience function that returns the current configuration of the entity by<br>
	 * calling clAmsMgmtEntityGetConfig with the correct ClAmsEntityT structure.<br>
	 * \sa clAmsMgmtEntityGetConfig()<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>ClAmsCSIConfigT* clAmsMgmtCompServiceInstanceGetConfig(ClAmsMgmtHandleT, const ClCharT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2480</i>
	 */
	ClAmsCSIConfigT clAmsMgmtCompServiceInstanceGetConfig(long handle, String entName);
	/**
	 * \brief Returns the configuration information for a component.<br>
	 * \param handle Handle returned by the AML on invocation of clAmsMgmtInitialize() API.<br>
	 * \param entName Null terminated name of the AMS entity.<br>
	 * \return NULL entity does not exist, or a pointer to the entity configuration.  You must free (clHeapFree) this pointer.<br>
	 * \par Description:<br>
	 * This is a convenience function that returns the current configuration of the entity by<br>
	 * calling clAmsMgmtEntityGetConfig with the correct ClAmsEntityT structure.<br>
	 * \sa clAmsMgmtEntityGetConfig()<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>ClAmsCompConfigT* clAmsMgmtCompGetConfig(ClAmsMgmtHandleT, const ClCharT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2501</i><br>
	 * @deprecated use the safer methods {@link #clAmsMgmtCompGetConfig(long, java.nio.ByteBuffer)} and {@link #clAmsMgmtCompGetConfig(long, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	ClAmsCompConfigT clAmsMgmtCompGetConfig(long handle, Pointer entName);
	/**
	 * \brief Returns the configuration information for a component.<br>
	 * \param handle Handle returned by the AML on invocation of clAmsMgmtInitialize() API.<br>
	 * \param entName Null terminated name of the AMS entity.<br>
	 * \return NULL entity does not exist, or a pointer to the entity configuration.  You must free (clHeapFree) this pointer.<br>
	 * \par Description:<br>
	 * This is a convenience function that returns the current configuration of the entity by<br>
	 * calling clAmsMgmtEntityGetConfig with the correct ClAmsEntityT structure.<br>
	 * \sa clAmsMgmtEntityGetConfig()<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>ClAmsCompConfigT* clAmsMgmtCompGetConfig(ClAmsMgmtHandleT, const ClCharT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2501</i>
	 */
	ClAmsCompConfigT clAmsMgmtCompGetConfig(long handle, String entName);
	/**
	 * \brief returns the status (transient) scalar attributes of an AMS entity<br>
	 * \param handle         Handle returned by the AML on invocation of clAmsMgmtInitialize() API.<br>
	 * \param entity         Name of the AMS entity whose status attributes are queried<br>
	 * \param entityStatus   Entity status structure returned by AMF.  It is your responsibility to clHeapFree() the returned object.<br>
	 * \return<br>
	 * \retval  CL_OK                      - Operation successful<br>
	 * \retval  CL_ERR_INVALID_HANDLE      - Error: AML CCB Handle is invalid<br>
	 * \retval CL_AMS_ERR_INVALID_ENTITY  The entity is not valid<br>
	 * \retval CL_ERR_NOT_EXIST           The entity does not exist<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>int clAmsMgmtEntityGetStatus(ClAmsMgmtHandleT, ClAmsEntityT*, ClAmsEntityStatusT**)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2523</i><br>
	 *  use the safer method {@link #clAmsMgmtEntityGetStatus(long, clAmsMgmtClientApi.ClAmsEntityConfigT, clAmsMgmtClientApi.ClAmsEntityStatusT.ByReference[])} instead
	 */
	//@Deprecated 
	int clAmsMgmtEntityGetStatus(long handle, ClAmsEntityConfigT entity, PointerByReference entityStatus);
	/**
	 * \brief returns the status (transient) scalar attributes of an AMS entity<br>
	 * \param handle         Handle returned by the AML on invocation of clAmsMgmtInitialize() API.<br>
	 * \param entity         Name of the AMS entity whose status attributes are queried<br>
	 * \param entityStatus   Entity status structure returned by AMF.  It is your responsibility to clHeapFree() the returned object.<br>
	 * \return<br>
	 * \retval  CL_OK                      - Operation successful<br>
	 * \retval  CL_ERR_INVALID_HANDLE      - Error: AML CCB Handle is invalid<br>
	 * \retval CL_AMS_ERR_INVALID_ENTITY  The entity is not valid<br>
	 * \retval CL_ERR_NOT_EXIST           The entity does not exist<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>int clAmsMgmtEntityGetStatus(ClAmsMgmtHandleT, ClAmsEntityT*, ClAmsEntityStatusT**)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2523</i>
	 */
	//int clAmsMgmtEntityGetStatus(long handle, ClAmsEntityConfigT entity, clAmsMgmtClientApi.ClAmsEntityStatusT.ByReference entityStatus[]);
	/**
	 * \brief Returns the current status information of a node.<br>
	 * \param handle Handle returned by the AML on invocation of clAmsMgmtInitialize() API.<br>
	 * \param entName NULL terminated name of the AMS entity.<br>
	 * \return A pointer to the entity's status object, or NULL.  You must free (clHeapFree()) this pointer.<br>
	 * \par Description:<br>
	 * This is a convenience function that returns the current status of the entity by<br>
	 * calling clAmsMgmtEntityGetStatus() with the correct ClAmsEntityT structure.<br>
	 * \sa clAmsMgmtEntityGetConfig()<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>ClAmsNodeStatusT* clAmsMgmtNodeGetStatus(ClAmsMgmtHandleT, const ClCharT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2545</i><br>
	 * @deprecated use the safer methods {@link #clAmsMgmtNodeGetStatus(long, java.nio.ByteBuffer)} and {@link #clAmsMgmtNodeGetStatus(long, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	ClAmsNodeStatusT clAmsMgmtNodeGetStatus(long handle, Pointer entName);
	/**
	 * \brief Returns the current status information of a node.<br>
	 * \param handle Handle returned by the AML on invocation of clAmsMgmtInitialize() API.<br>
	 * \param entName NULL terminated name of the AMS entity.<br>
	 * \return A pointer to the entity's status object, or NULL.  You must free (clHeapFree()) this pointer.<br>
	 * \par Description:<br>
	 * This is a convenience function that returns the current status of the entity by<br>
	 * calling clAmsMgmtEntityGetStatus() with the correct ClAmsEntityT structure.<br>
	 * \sa clAmsMgmtEntityGetConfig()<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>ClAmsNodeStatusT* clAmsMgmtNodeGetStatus(ClAmsMgmtHandleT, const ClCharT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2545</i>
	 */
	ClAmsNodeStatusT clAmsMgmtNodeGetStatus(long handle, String entName);
	/**
	 * \brief Returns the current status information of a service group.<br>
	 * \param handle Handle returned by the AML on invocation of clAmsMgmtInitialize() API.<br>
	 * \param entName NULL terminated name of the AMS entity.<br>
	 * \return A pointer to the entity's status object, or NULL.  You must free (clHeapFree()) this pointer.<br>
	 * \par Description:<br>
	 * This is a convenience function that returns the current status of the entity by<br>
	 * calling clAmsMgmtEntityGetStatus() with the correct ClAmsEntityT structure.<br>
	 * \sa clAmsMgmtEntityGetConfig()<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>ClAmsSGStatusT* clAmsMgmtServiceGroupGetStatus(ClAmsMgmtHandleT, const ClCharT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2566</i><br>
	 * @deprecated use the safer methods {@link #clAmsMgmtServiceGroupGetStatus(long, java.nio.ByteBuffer)} and {@link #clAmsMgmtServiceGroupGetStatus(long, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	ClAmsSGStatusT clAmsMgmtServiceGroupGetStatus(long handle, Pointer entName);
	/**
	 * \brief Returns the current status information of a service group.<br>
	 * \param handle Handle returned by the AML on invocation of clAmsMgmtInitialize() API.<br>
	 * \param entName NULL terminated name of the AMS entity.<br>
	 * \return A pointer to the entity's status object, or NULL.  You must free (clHeapFree()) this pointer.<br>
	 * \par Description:<br>
	 * This is a convenience function that returns the current status of the entity by<br>
	 * calling clAmsMgmtEntityGetStatus() with the correct ClAmsEntityT structure.<br>
	 * \sa clAmsMgmtEntityGetConfig()<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>ClAmsSGStatusT* clAmsMgmtServiceGroupGetStatus(ClAmsMgmtHandleT, const ClCharT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2566</i>
	 */
	ClAmsSGStatusT clAmsMgmtServiceGroupGetStatus(long handle, String entName);
	/**
	 * \brief Returns the current status information of a service unit.<br>
	 * \param handle Handle returned by the AML on invocation of clAmsMgmtInitialize() API.<br>
	 * \param entName NULL terminated name of the AMS entity.<br>
	 * \return A pointer to the entity's status object, or NULL.  You must free (clHeapFree()) this pointer.<br>
	 * \par Description:<br>
	 * This is a convenience function that returns the current status of the entity by<br>
	 * calling clAmsMgmtEntityGetStatus() with the correct ClAmsEntityT structure.<br>
	 * \sa clAmsMgmtEntityGetConfig()<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>ClAmsSUStatusT* clAmsMgmtServiceUnitGetStatus(ClAmsMgmtHandleT, const ClCharT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2587</i><br>
	 * @deprecated use the safer methods {@link #clAmsMgmtServiceUnitGetStatus(long, java.nio.ByteBuffer)} and {@link #clAmsMgmtServiceUnitGetStatus(long, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	ClAmsSUStatusT clAmsMgmtServiceUnitGetStatus(long handle, Pointer entName);
	/**
	 * \brief Returns the current status information of a service unit.<br>
	 * \param handle Handle returned by the AML on invocation of clAmsMgmtInitialize() API.<br>
	 * \param entName NULL terminated name of the AMS entity.<br>
	 * \return A pointer to the entity's status object, or NULL.  You must free (clHeapFree()) this pointer.<br>
	 * \par Description:<br>
	 * This is a convenience function that returns the current status of the entity by<br>
	 * calling clAmsMgmtEntityGetStatus() with the correct ClAmsEntityT structure.<br>
	 * \sa clAmsMgmtEntityGetConfig()<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>ClAmsSUStatusT* clAmsMgmtServiceUnitGetStatus(ClAmsMgmtHandleT, const ClCharT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2587</i>
	 */
	ClAmsSUStatusT clAmsMgmtServiceUnitGetStatus(long handle, String entName);
	/**
	 * \brief Returns the current status information of a service instance.<br>
	 * \param handle Handle returned by the AML on invocation of clAmsMgmtInitialize() API.<br>
	 * \param entName NULL terminated name of the AMS entity.<br>
	 * \return A pointer to the entity's status object, or NULL.  You must free (clHeapFree()) this pointer.<br>
	 * \par Description:<br>
	 * This is a convenience function that returns the current status of the entity by<br>
	 * calling clAmsMgmtEntityGetStatus() with the correct ClAmsEntityT structure.<br>
	 * \sa clAmsMgmtEntityGetConfig()<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>ClAmsSIStatusT* clAmsMgmtServiceInstanceGetStatus(ClAmsMgmtHandleT, const ClCharT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2608</i><br>
	 * @deprecated use the safer methods {@link #clAmsMgmtServiceInstanceGetStatus(long, java.nio.ByteBuffer)} and {@link #clAmsMgmtServiceInstanceGetStatus(long, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	ClAmsSIStatusT clAmsMgmtServiceInstanceGetStatus(long handle, Pointer entName);
	/**
	 * \brief Returns the current status information of a service instance.<br>
	 * \param handle Handle returned by the AML on invocation of clAmsMgmtInitialize() API.<br>
	 * \param entName NULL terminated name of the AMS entity.<br>
	 * \return A pointer to the entity's status object, or NULL.  You must free (clHeapFree()) this pointer.<br>
	 * \par Description:<br>
	 * This is a convenience function that returns the current status of the entity by<br>
	 * calling clAmsMgmtEntityGetStatus() with the correct ClAmsEntityT structure.<br>
	 * \sa clAmsMgmtEntityGetConfig()<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>ClAmsSIStatusT* clAmsMgmtServiceInstanceGetStatus(ClAmsMgmtHandleT, const ClCharT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2608</i>
	 */
	ClAmsSIStatusT clAmsMgmtServiceInstanceGetStatus(long handle, String entName);
	/**
	 * \brief Returns the current status information of a component service instance.<br>
	 * \param handle Handle returned by the AML on invocation of clAmsMgmtInitialize() API.<br>
	 * \param entName NULL terminated name of the AMS entity.<br>
	 * \return A pointer to the entity's status object, or NULL.  You must free (clHeapFree()) this pointer.<br>
	 * \par Description:<br>
	 * This is a convenience function that returns the current status of the entity by<br>
	 * calling clAmsMgmtEntityGetStatus() with the correct ClAmsEntityT structure.<br>
	 * \sa clAmsMgmtEntityGetConfig()<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>ClAmsCSIStatusT* clAmsMgmtCompServiceInstanceGetStatus(ClAmsMgmtHandleT, const ClCharT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2629</i><br>
	 * @deprecated use the safer methods {@link #clAmsMgmtCompServiceInstanceGetStatus(long, java.nio.ByteBuffer)} and {@link #clAmsMgmtCompServiceInstanceGetStatus(long, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	ClAmsCSIStatusT clAmsMgmtCompServiceInstanceGetStatus(long handle, Pointer entName);
	/**
	 * \brief Returns the current status information of a component service instance.<br>
	 * \param handle Handle returned by the AML on invocation of clAmsMgmtInitialize() API.<br>
	 * \param entName NULL terminated name of the AMS entity.<br>
	 * \return A pointer to the entity's status object, or NULL.  You must free (clHeapFree()) this pointer.<br>
	 * \par Description:<br>
	 * This is a convenience function that returns the current status of the entity by<br>
	 * calling clAmsMgmtEntityGetStatus() with the correct ClAmsEntityT structure.<br>
	 * \sa clAmsMgmtEntityGetConfig()<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>ClAmsCSIStatusT* clAmsMgmtCompServiceInstanceGetStatus(ClAmsMgmtHandleT, const ClCharT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2629</i>
	 */
	ClAmsCSIStatusT clAmsMgmtCompServiceInstanceGetStatus(long handle, String entName);
	/**
	 * \brief Returns the current status information of a component.<br>
	 * \param handle Handle returned by the AML on invocation of clAmsMgmtInitialize() API.<br>
	 * \param entName NULL terminated name of the AMS entity.<br>
	 * \return A pointer to the entity's status object, or NULL.  You must free (clHeapFree()) this pointer.<br>
	 * \par Description:<br>
	 * This is a convenience function that returns the current status of the entity by<br>
	 * calling clAmsMgmtEntityGetStatus() with the correct ClAmsEntityT structure.<br>
	 * \sa clAmsMgmtEntityGetConfig()<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>ClAmsCompStatusT* clAmsMgmtCompGetStatus(ClAmsMgmtHandleT, const ClCharT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2650</i><br>
	 * @deprecated use the safer methods {@link #clAmsMgmtCompGetStatus(long, java.nio.ByteBuffer)} and {@link #clAmsMgmtCompGetStatus(long, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	ClAmsCompStatusT clAmsMgmtCompGetStatus(long handle, Pointer entName);
	/**
	 * \brief Returns the current status information of a component.<br>
	 * \param handle Handle returned by the AML on invocation of clAmsMgmtInitialize() API.<br>
	 * \param entName NULL terminated name of the AMS entity.<br>
	 * \return A pointer to the entity's status object, or NULL.  You must free (clHeapFree()) this pointer.<br>
	 * \par Description:<br>
	 * This is a convenience function that returns the current status of the entity by<br>
	 * calling clAmsMgmtEntityGetStatus() with the correct ClAmsEntityT structure.<br>
	 * \sa clAmsMgmtEntityGetConfig()<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>ClAmsCompStatusT* clAmsMgmtCompGetStatus(ClAmsMgmtHandleT, const ClCharT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2650</i>
	 */
	ClAmsCompStatusT clAmsMgmtCompGetStatus(long handle, String entName);
	/**
	 * \brief Get all entities of a particular type.<br>
	 * \param handle   Handle returned by the AML on invocation of clAmsMgmtInitialize() API.<br>
	 * \param listName What type of entity to get.<br>
	 * \param buffer   An array of entity names.  You must clHeapFree([param]->entity) if [param]->count > 0. <br>
	 * \return Success or error code<br>
	 * \par Description:<br>
	 * The function gets the names of all entities of a particular type.<br>
	 * It can be called for each type to get the names of all entities.<br>
	 * These names can then be used to retrieve the configuration and status of<br>
	 * every entity, giving access to the complete AMF entity database.<br>
	 * \sa clAmsMgmtEntityGetConfig(), clAmsMgmtEntityGetStatus()<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>int clAmsMgmtGetList(ClAmsMgmtHandleT, ClAmsEntityListTypeT, ClAmsEntityBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2674</i>
	 */
	int clAmsMgmtGetList(long handle, int listName, ClAmsEntityBufferT.ByReference buffer);
	/**
	 * \brief returns the name value pair list for a csi <br>
	 * \param handle       Handle returned by the AML on invocation of clAmsMgmtInitialize API.<br>
	 * \param  csi         Name of the csi whose nvp list is queried <br>
	 * \param  nvpBuffer   Buffer containing the nvp list for the csi <br>
	 * *<br>
	 * \return  Clovis return code<br>
	 * \retval  CL_OK                      Operation successful<br>
	 * \retval  CL_ERR_INVALID_HANDLE      Error: AML CCB Handle is invalid<br>
	 * \retval  CL_AMS_ERR_INVALID_ENTITY  The entity is not valid<br>
	 * \retval  CL_ERR_NOT_EXIST           The entity does not exist<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>int clAmsMgmtGetCSINVPList(ClAmsMgmtHandleT, ClAmsEntityT*, ClAmsCSINVPBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2697</i>
	 */
	int clAmsMgmtGetCSINVPList(long handle, ClAmsEntityConfigT csi, ClAmsCSINVPBufferT.ByReference nvpBuffer);
	/**
	 * returns the csi-csi dependencies list for a csi <br>
	 * \param handle                     Handle returned by the AML on invocation of clAmsMgmtInitialize API.<br>
	 * \param csi                        Name of the csi whose csi-csi dependencies list is queried<br>
	 * \param dependenciesCSIBuffer      Buffer containing the csi-csi dependencies list for the csi. You must clHeapFree([param]->entity) if [param]->count > 0. <br>
	 * \return OpenClovis return code<br>
	 * \retval  CL_OK                      Operation successful<br>
	 * \retval  CL_ERR_INVALID_HANDLE      Error: AML CCB Handle is invalid<br>
	 * \retval  CL_AMS_ERR_INVALID_ENTITY  The entity is not valid<br>
	 * \retval  CL_ERR_NOT_EXIST           The entity does not exist<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>int clAmsMgmtGetCSIDependenciesList(ClAmsMgmtHandleT, ClAmsEntityT*, ClAmsEntityBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2720</i>
	 */
	int clAmsMgmtGetCSIDependenciesList(long handle, ClAmsEntityConfigT csi, ClAmsEntityBufferT.ByReference dependenciesCSIBuffer);
	/**
	 * \brief Get all service group names<br>
	 * \param handle         Handle returned by the AMF on invocation of clAmsMgmtInitialize API.<br>
	 * \param entityBuffer   Buffer containing an array of entity names.  You must clHeapFree([param]->entity) if [param]->count > 0. <br>
	 * \return  Clovis return code<br>
	 * \retval  CL_OK                      Operation successful<br>
	 * \retval  CL_ERR_INVALID_HANDLE      Error: AML CCB Handle is invalid<br>
	 * \par Description:<br>
	 * This is a type-safe wrapper around clAmsMgmtGetList()<br>
	 * \sa clAmsMgmtGetList()<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>int clAmsMgmtGetSGList(ClAmsMgmtHandleT, ClAmsEntityBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2743</i>
	 */
	int clAmsMgmtGetSGList(long handle, ClAmsEntityBufferT.ByReference entityBuffer);
	/**
	 * \brief Get all service instance entity names<br>
	 * \param handle         Handle returned by the AMF on invocation of clAmsMgmtInitialize API.<br>
	 * \param entityBuffer   Buffer containing an array of entity names.  You must clHeapFree([param]->entity) if [param]->count > 0. <br>
	 * \return  Clovis return code<br>
	 * \retval  CL_OK                      Operation successful<br>
	 * \retval  CL_ERR_INVALID_HANDLE      Error: AML CCB Handle is invalid<br>
	 * \par Description:<br>
	 * This is a type-safe wrapper around clAmsMgmtGetList()<br>
	 * \sa clAmsMgmtGetList()<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>int clAmsMgmtGetSIList(ClAmsMgmtHandleT, ClAmsEntityBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2766</i>
	 */
	int clAmsMgmtGetSIList(long handle, ClAmsEntityBufferT.ByReference entityBuffer);
	/**
	 * \brief Get all component service instance entity names<br>
	 * \param handle         Handle returned by the AMF on invocation of clAmsMgmtInitialize API.<br>
	 * \param entityBuffer   Buffer containing an array of entity names.  You must clHeapFree([param]->entity) if [param]->count > 0. <br>
	 * \return  Clovis return code<br>
	 * \retval  CL_OK                      Operation successful<br>
	 * \retval  CL_ERR_INVALID_HANDLE      Error: AML CCB Handle is invalid<br>
	 * \par Description:<br>
	 * This is a type-safe wrapper around clAmsMgmtGetList()<br>
	 * \sa clAmsMgmtGetList()<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>int clAmsMgmtGetCSIList(ClAmsMgmtHandleT, ClAmsEntityBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2789</i>
	 */
	int clAmsMgmtGetCSIList(long handle, ClAmsEntityBufferT.ByReference entityBuffer);
	/**
	 * \brief Get all node entity names<br>
	 * \param handle         Handle returned by the AMF on invocation of clAmsMgmtInitialize API.<br>
	 * \param entityBuffer   Buffer containing an array of entity names.  You must clHeapFree([param]->entity) if [param]->count > 0. <br>
	 * \return  Clovis return code<br>
	 * \retval  CL_OK                      Operation successful<br>
	 * \retval  CL_ERR_INVALID_HANDLE      Error: AML CCB Handle is invalid<br>
	 * \par Description:<br>
	 * This is a type-safe wrapper around clAmsMgmtGetList()<br>
	 * \sa clAmsMgmtGetList()<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>int clAmsMgmtGetNodeList(ClAmsMgmtHandleT, ClAmsEntityBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2812</i>
	 */
	int clAmsMgmtGetNodeList(long handle, ClAmsEntityBufferT.ByReference entityBuffer);
	/**
	 * \brief Get all service unit entity names<br>
	 * \param handle         Handle returned by the AMF on invocation of clAmsMgmtInitialize API.<br>
	 * \param entityBuffer   Buffer containing an array of entity names.  You must clHeapFree([param]->entity) if [param]->count > 0. <br>
	 * \return  Clovis return code<br>
	 * \retval  CL_OK                      Operation successful<br>
	 * \retval  CL_ERR_INVALID_HANDLE      Error: AML CCB Handle is invalid<br>
	 * \par Description:<br>
	 * This is a type-safe wrapper around clAmsMgmtGetList()<br>
	 * \sa clAmsMgmtGetList()<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>int clAmsMgmtGetSUList(ClAmsMgmtHandleT, ClAmsEntityBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2835</i>
	 */
	int clAmsMgmtGetSUList(long handle, ClAmsEntityBufferT.ByReference entityBuffer);
	/**
	 * \brief Get all component entity names<br>
	 * \param handle         Handle returned by the AMF on invocation of clAmsMgmtInitialize API.<br>
	 * \param entityBuffer   Buffer containing an array of entity names.  You must clHeapFree([param]->entity) if [param]->count > 0. <br>
	 * \return  Clovis return code<br>
	 * \retval  CL_OK                      Operation successful<br>
	 * \retval  CL_ERR_INVALID_HANDLE      Error: AML CCB Handle is invalid<br>
	 * \par Description:<br>
	 * This is a type-safe wrapper around clAmsMgmtGetList()<br>
	 * \sa clAmsMgmtGetList()<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>int clAmsMgmtGetCompList(ClAmsMgmtHandleT, ClAmsEntityBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2858</i>
	 */
	int clAmsMgmtGetCompList(long handle, ClAmsEntityBufferT.ByReference entityBuffer);
	/**
	 * \brief returns the node dependencies list for a node <br>
	 * \param handle                    Handle returned by the AML on invocation of clAmsMgmtInitialize API.<br>
	 * \param node                      Name of the node whose node dependencies list is queried <br>
	 * \param dependencyBuffer          Buffer containing the node dependencies list for the node.  You must clHeapFree([param]->entity) if [param]->count > 0.  <br>
	 * *<br>
	 * \return OpenClovis return code<br>
	 * \retval  CL_OK                      Operation successful<br>
	 * \retval  CL_ERR_INVALID_HANDLE      Error: AML CCB Handle is invalid<br>
	 * \retval  CL_AMS_ERR_INVALID_ENTITY  The entity is not valid<br>
	 * \retval  CL_ERR_NOT_EXIST           The entity does not exist<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>int clAmsMgmtGetNodeDependenciesList(ClAmsMgmtHandleT, ClAmsEntityT*, ClAmsEntityBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2882</i>
	 */
	int clAmsMgmtGetNodeDependenciesList(long handle, ClAmsEntityConfigT node, ClAmsEntityBufferT.ByReference dependencyBuffer);
	/**
	 * \brief returns the node su list for a node <br>
	 * \param handle                  Handle returned by the AML on invocation of clAmsMgmtInitialize API.<br>
	 * \param node                    Name of the node whose su list is queried <br>
	 * \param suBuffer                Buffer containing the node su list for the node.  You must clHeapFree([param]->entity) if [param]->count > 0.  <br>
	 * \return OpenClovis return code<br>
	 * \retval CL_OK                  Operation successful<br>
	 * \retval CL_ERR_INVALID_HANDLE  Error: AML CCB Handle is invalid<br>
	 * \retval  CL_AMS_ERR_INVALID_ENTITY  The entity is not valid<br>
	 * \retval  CL_ERR_NOT_EXIST           The entity does not exist<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>int clAmsMgmtGetNodeSUList(ClAmsMgmtHandleT, ClAmsEntityT*, ClAmsEntityBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2906</i>
	 */
	int clAmsMgmtGetNodeSUList(long handle, ClAmsEntityConfigT node, ClAmsEntityBufferT.ByReference suBuffer);
	/**
	 * Original signature : <code>int clAmsMgmtGetSGSUList(ClAmsMgmtHandleT, ClAmsEntityT*, ClAmsEntityBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2931</i>
	 */
	int clAmsMgmtGetSGSUList(long handle, ClAmsEntityConfigT sg, ClAmsEntityBufferT.ByReference suBuffer);
	/**
	 * Original signature : <code>int clAmsMgmtGetSGSIList(ClAmsMgmtHandleT, ClAmsEntityT*, ClAmsEntityBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2957</i>
	 */
	int clAmsMgmtGetSGSIList(long handle, ClAmsEntityConfigT sg, ClAmsEntityBufferT.ByReference siBuffer);
	/**
	 * Original signature : <code>int clAmsMgmtGetSUCompList(ClAmsMgmtHandleT, ClAmsEntityT*, ClAmsEntityBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:2982</i>
	 */
	int clAmsMgmtGetSUCompList(long handle, ClAmsEntityConfigT su, ClAmsEntityBufferT.ByReference compBuffer);
	/**
	 * Original signature : <code>int clAmsMgmtGetSISURankList(ClAmsMgmtHandleT, ClAmsEntityT*, ClAmsEntityBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3006</i>
	 */
	int clAmsMgmtGetSISURankList(long handle, ClAmsEntityConfigT si, ClAmsEntityBufferT.ByReference suBuffer);
	/**
	 * returns the si-si dependencies list for a si <br>
	 * \param handle                    Handle returned by the AML on invocation of clAmsMgmtInitialize API.<br>
	 * \param si                        Name of the si whose si-si dependencies list is queried<br>
	 * \param dependenciesSIBuffer      Buffer containing the si-si dependencies list for the si.  You must clHeapFree(dependenciesSIBuffer->entity) if dependenciesSIBuffer->count > 0. <br>
	 * \return OpenClovis return code<br>
	 * \retval  CL_OK                      Operation successful<br>
	 * \retval  CL_ERR_INVALID_HANDLE      Error: AML CCB Handle is invalid<br>
	 * \retval  CL_AMS_ERR_INVALID_ENTITY  The entity is not valid<br>
	 * \retval  CL_ERR_NOT_EXIST           The entity does not exist<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>int clAmsMgmtGetSIDependenciesList(ClAmsMgmtHandleT, ClAmsEntityT*, ClAmsEntityBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3028</i>
	 */
	int clAmsMgmtGetSIDependenciesList(long handle, ClAmsEntityConfigT si, ClAmsEntityBufferT.ByReference dependenciesSIBuffer);
	/**
	 * Original signature : <code>int clAmsMgmtGetSICSIList(ClAmsMgmtHandleT, ClAmsEntityT*, ClAmsEntityBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3052</i>
	 */
	int clAmsMgmtGetSICSIList(long handle, ClAmsEntityConfigT si, ClAmsEntityBufferT.ByReference csiBuffer);
	/**
	 * Original signature : <code>int clAmsMgmtGetSGInstantiableSUList(ClAmsMgmtHandleT, ClAmsEntityT*, ClAmsEntityBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3076</i>
	 */
	int clAmsMgmtGetSGInstantiableSUList(long handle, ClAmsEntityConfigT sg, ClAmsEntityBufferT.ByReference instantiableSUBuffer);
	/**
	 * Original signature : <code>int clAmsMgmtGetSGInstantiatedSUList(ClAmsMgmtHandleT, ClAmsEntityT*, ClAmsEntityBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3101</i>
	 */
	int clAmsMgmtGetSGInstantiatedSUList(long handle, ClAmsEntityConfigT sg, ClAmsEntityBufferT.ByReference instantiatedSUBuffer);
	/**
	 * Original signature : <code>int clAmsMgmtGetSGInServiceSpareSUList(ClAmsMgmtHandleT, ClAmsEntityT*, ClAmsEntityBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3124</i>
	 */
	int clAmsMgmtGetSGInServiceSpareSUList(long handle, ClAmsEntityConfigT sg, ClAmsEntityBufferT.ByReference inserviceSpareSUBuffer);
	/**
	 * Original signature : <code>int clAmsMgmtGetSGAssignedSUList(ClAmsMgmtHandleT, ClAmsEntityT*, ClAmsEntityBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3149</i>
	 */
	int clAmsMgmtGetSGAssignedSUList(long handle, ClAmsEntityConfigT sg, ClAmsEntityBufferT.ByReference assignedSUBuffer);
	/**
	 * Original signature : <code>int clAmsMgmtGetSGFaultySUList(ClAmsMgmtHandleT, ClAmsEntityT*, ClAmsEntityBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3177</i>
	 */
	int clAmsMgmtGetSGFaultySUList(long handle, ClAmsEntityConfigT sg, ClAmsEntityBufferT.ByReference faultySUBuffer);
	/**
	 * Original signature : <code>int clAmsMgmtGetSUAssignedSIsList(ClAmsMgmtHandleT, ClAmsEntityT*, ClAmsSUSIRefBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3206</i>
	 */
	int clAmsMgmtGetSUAssignedSIsList(long handle, ClAmsEntityConfigT su, ClAmsSUSIRefBufferT.ByReference siBuffer);
	/**
	 * Original signature : <code>int clAmsMgmtGetSUAssignedSIsExtendedList(ClAmsMgmtHandleT, ClAmsEntityT*, ClAmsSUSIExtendedRefBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3211</i>
	 */
	int clAmsMgmtGetSUAssignedSIsExtendedList(long handle, ClAmsEntityConfigT su, ClAmsSUSIExtendedRefBufferT.ByReference siBuffer);
	/**
	 * Original signature : <code>int clAmsMgmtGetSISUList(ClAmsMgmtHandleT, ClAmsEntityT*, ClAmsSISURefBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3236</i>
	 */
	int clAmsMgmtGetSISUList(long handle, ClAmsEntityConfigT si, ClAmsSISURefBufferT.ByReference suBuffer);
	/**
	 * Original signature : <code>int clAmsMgmtGetSISUExtendedList(ClAmsMgmtHandleT, ClAmsEntityT*, ClAmsSISUExtendedRefBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3241</i>
	 */
	int clAmsMgmtGetSISUExtendedList(long handle, ClAmsEntityConfigT si, ClAmsSISUExtendedRefBufferT.ByReference suBuffer);
	/**
	 * * returns the list of csi's assigned to a component <br>
	 * \param handle                    Handle returned by the AML on invocation of clAmsMgmtInitialize API.<br>
	 * \param comp                      Name of the component whose csi list is queried <br>
	 * \param csiBuffer                 Buffer containing the list of csi's assigned to the component <br>
	 * \return OpenClovis return code<br>
	 * \retval  CL_OK                      Operation successful<br>
	 * \retval  CL_ERR_INVALID_HANDLE      Error: AML CCB Handle is invalid<br>
	 * \retval  CL_AMS_ERR_INVALID_ENTITY  The entity is not valid<br>
	 * \retval  CL_ERR_NOT_EXIST           The entity does not exist<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>int clAmsMgmtGetCompCSIList(ClAmsMgmtHandleT, ClAmsEntityT*, ClAmsCompCSIRefBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3264</i>
	 */
	int clAmsMgmtGetCompCSIList(long handle, ClAmsEntityConfigT comp, ClAmsCompCSIRefBufferT.ByReference csiBuffer);
	/**
	 * Original signature : <code>int clAmsMgmtGetSIHAState(ClAmsMgmtHandleT, const ClCharT*, const ClCharT*, ClAmsHAStateT*, ClBoolT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3269</i><br>
	 * use the safer methods {@link #clAmsMgmtGetSIHAState(long, java.nio.ByteBuffer, java.nio.ByteBuffer, clAmsMgmtClientApi.int, java.nio.ShortBuffer)} and {@link #clAmsMgmtGetSIHAState(long, com.sun.jna.Pointer, com.sun.jna.Pointer, clAmsMgmtClientApi.int, com.sun.jna.ptr.ShortByReference)} instead
	 */
	//@Deprecated 
	int clAmsMgmtGetSIHAState(long handle, Pointer si, Pointer su, int haState, ShortByReference fullyAssigned);
	/**
	 * Original signature : <code>int clAmsMgmtGetSIHAState(ClAmsMgmtHandleT, const ClCharT*, const ClCharT*, ClAmsHAStateT*, ClBoolT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3269</i>
	 */
	//int clAmsMgmtGetSIHAState(long handle, ByteBuffer si, ByteBuffer su, int haState, ShortBuffer fullyAssigned);
	/**
	 * Original signature : <code>int clAmsMgmtGetSUHAState(ClAmsMgmtHandleT, const ClCharT*, ClBoolT, ClAmsHAStateT*, ClBoolT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3275</i><br>
	 * use the safer methods {@link #clAmsMgmtGetSUHAState(long, java.nio.ByteBuffer, short, clAmsMgmtClientApi.int, java.nio.ShortBuffer)} and {@link #clAmsMgmtGetSUHAState(long, com.sun.jna.Pointer, short, clAmsMgmtClientApi.int, com.sun.jna.ptr.ShortByReference)} instead
	 */
	//@Deprecated 
	int clAmsMgmtGetSUHAState(long handle, Pointer su, short checkAllSIs, int haState, ShortByReference fullyAssigned);
	/**
	 * Original signature : <code>int clAmsMgmtGetSUHAState(ClAmsMgmtHandleT, const ClCharT*, ClBoolT, ClAmsHAStateT*, ClBoolT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3275</i>
	 */
	//int clAmsMgmtGetSUHAState(long handle, ByteBuffer su, short checkAllSIs, int haState, ShortBuffer fullyAssigned);
	/**
	 * * Convert an SG from one redundancy model to another, without taking it offline<br>
	 * \param handle       Handle returned by the AML on invocation of clAmsMgmtInitialize() API.<br>
	 * \param sg           Name of the Service Group that is being modified<br>
	 * \param prefix       Newly created entities' names will start with this string <br>
	 * \param activeSUs    Number of service units you want to be active.<br>
	 * \param standbySUs   Number of service units you want to be standby.<br>
	 * \param migrateList  All entities that were created for you to tweak before committing.<br>
	 * \return OpenClovis return code<br>
	 * \retval  CL_OK                      Operation successful<br>
	 * \retval  CL_ERR_INVALID_HANDLE      Error: AML CCB Handle is invalid<br>
	 * \retval  CL_ERR_NOT_EXIST           The entity does not exist<br>
	 * *<br>
	 * \par Description:<br>
	 * This function uses all of the other functions defined in this module<br>
	 * to implement a major configuration change to an SG.  The SG can be<br>
	 * either inservice or out-of-service during this call.  Inservice entities<br>
	 * will be disturbed as little as possible during the configuration modification.<br>
	 * The function does not give you complete control over all aspects of the<br>
	 * configuration change, notably it does not let you choose which SUs to<br>
	 * remove (if you are reducing the number of SUs), and it does not let you<br>
	 * choose which nodes to deploy new SUs onto (if increasing the SUs).<br>
	 * For this reason, it may be more appropriate for you to use this function<br>
	 * as an example implementation rather than to call it directly.<br>
	 * However, we do attempt to make intelligent decisions about what to remove or<br>
	 * add.  For example, the function will prefer to remove entities that are not<br>
	 * in service (so if you want to remove particular entities, simply shut those<br>
	 * and only those entities down before calling this function), and it will<br>
	 * preferentially create entities on existing nodes that are not controllers and<br>
	 * do not currently contain this SG.<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>int clAmsMgmtMigrateSG(ClAmsMgmtHandleT, const ClCharT*, const ClCharT*, int, int, ClAmsMgmtMigrateListT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3322</i><br>
	 * @deprecated use the safer methods {@link #clAmsMgmtMigrateSG(long, java.nio.ByteBuffer, java.nio.ByteBuffer, , , clAmsMgmtClientApi.ClAmsMgmtMigrateList)} and {@link #clAmsMgmtMigrateSG(long, com.sun.jna.Pointer, com.sun.jna.Pointer, , , clAmsMgmtClientApi.ClAmsMgmtMigrateList)} instead
	 */
	@Deprecated 
	int clAmsMgmtMigrateSG(long handle, Pointer sg, Pointer prefix, int activeSUs, int standbySUs, ClAmsMgmtMigrateList migrateList);
	/**
	 * * Convert an SG from one redundancy model to another, without taking it offline<br>
	 * \param handle       Handle returned by the AML on invocation of clAmsMgmtInitialize() API.<br>
	 * \param sg           Name of the Service Group that is being modified<br>
	 * \param prefix       Newly created entities' names will start with this string <br>
	 * \param activeSUs    Number of service units you want to be active.<br>
	 * \param standbySUs   Number of service units you want to be standby.<br>
	 * \param migrateList  All entities that were created for you to tweak before committing.<br>
	 * \return OpenClovis return code<br>
	 * \retval  CL_OK                      Operation successful<br>
	 * \retval  CL_ERR_INVALID_HANDLE      Error: AML CCB Handle is invalid<br>
	 * \retval  CL_ERR_NOT_EXIST           The entity does not exist<br>
	 * *<br>
	 * \par Description:<br>
	 * This function uses all of the other functions defined in this module<br>
	 * to implement a major configuration change to an SG.  The SG can be<br>
	 * either inservice or out-of-service during this call.  Inservice entities<br>
	 * will be disturbed as little as possible during the configuration modification.<br>
	 * The function does not give you complete control over all aspects of the<br>
	 * configuration change, notably it does not let you choose which SUs to<br>
	 * remove (if you are reducing the number of SUs), and it does not let you<br>
	 * choose which nodes to deploy new SUs onto (if increasing the SUs).<br>
	 * For this reason, it may be more appropriate for you to use this function<br>
	 * as an example implementation rather than to call it directly.<br>
	 * However, we do attempt to make intelligent decisions about what to remove or<br>
	 * add.  For example, the function will prefer to remove entities that are not<br>
	 * in service (so if you want to remove particular entities, simply shut those<br>
	 * and only those entities down before calling this function), and it will<br>
	 * preferentially create entities on existing nodes that are not controllers and<br>
	 * do not currently contain this SG.<br>
	 * \par Library File:<br>
	 *  ClAmsMgmt<br>
	 * Original signature : <code>int clAmsMgmtMigrateSG(ClAmsMgmtHandleT, const ClCharT*, const ClCharT*, int, int, ClAmsMgmtMigrateListT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3322</i>
	 */
	int clAmsMgmtMigrateSG(long handle, String sg, String prefix, int activeSUs, int standbySUs, ClAmsMgmtMigrateList.ByReference migrateList);
	/**
	 * ***********************************<br>
	 *  \brief Associate arbitrary data with an AMF entity<br>
	 *  \param handle (in) The AMS handle returned from clAmsMgmtInitialize() API.<br>
	 *  \param entity (in) Name and type of the relevant entity<br>
	 *  \param data   (in) Buffer of data to associate<br>
	 *  \param len    (in) Length (bytes) of the data in the buffer<br>
	 * <br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_CID_AMS:CL_ERR_NOT_EXIST  The entity does not exist<br>
	 *  \par Description:<br>
	 *  This API persistently associates an arbitrary chunk of data with this entity.<br>
	 *  This data can be used by application code for any purpose.<br>
	 *  \sa clAmsMgmtEntityUserDataDelete(), clAmsMgmtEntityUserDataGet(), clAmsMgmtEntityUserDataSetKey()<br>
	 * Original signature : <code>int clAmsMgmtEntityUserDataSet(ClAmsMgmtHandleT, ClAmsEntityT*, ClCharT*, int)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3353</i><br>
	 * @deprecated use the safer methods {@link #clAmsMgmtEntityUserDataSet(long, clAmsMgmtClientApi.ClAmsEntityConfigT, java.nio.ByteBuffer, )} and {@link #clAmsMgmtEntityUserDataSet(long, clAmsMgmtClientApi.ClAmsEntityConfigT, com.sun.jna.Pointer, )} instead
	 */
	@Deprecated 
	int clAmsMgmtEntityUserDataSet(long handle, ClAmsEntityConfigT entity, Pointer data, int len);
	/**
	 * ***********************************<br>
	 *  \brief Associate arbitrary data with an AMF entity<br>
	 *  \param handle (in) The AMS handle returned from clAmsMgmtInitialize() API.<br>
	 *  \param entity (in) Name and type of the relevant entity<br>
	 *  \param data   (in) Buffer of data to associate<br>
	 *  \param len    (in) Length (bytes) of the data in the buffer<br>
	 * <br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_CID_AMS:CL_ERR_NOT_EXIST  The entity does not exist<br>
	 *  \par Description:<br>
	 *  This API persistently associates an arbitrary chunk of data with this entity.<br>
	 *  This data can be used by application code for any purpose.<br>
	 *  \sa clAmsMgmtEntityUserDataDelete(), clAmsMgmtEntityUserDataGet(), clAmsMgmtEntityUserDataSetKey()<br>
	 * Original signature : <code>int clAmsMgmtEntityUserDataSet(ClAmsMgmtHandleT, ClAmsEntityT*, ClCharT*, int)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3353</i>
	 */
	int clAmsMgmtEntityUserDataSet(long handle, ClAmsEntityConfigT entity, String data, int len);
	/**
	 * ***********************************<br>
	 *  \brief Associate arbitrary data with an AMF entity and a key<br>
	 *  \param handle (in) The AMS handle returned from clAmsMgmtInitialize() API.<br>
	 *  \param entity (in) Name and type of the relevant entity<br>
	 *  \param data   (in) Buffer of data to associate<br>
	 *  \param len    (in) Length (bytes) of the data in the buffer<br>
	 * <br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_CID_CNT:CL_ERR_NOT_EXIST  The key does not exist<br>
	 *  \retval CL_CID_AMS:CL_ERR_NOT_EXIST  The entity does not exist<br>
	 *  \par Description:<br>
	 *  This API persistently associates an arbitrary chunk of data with this entity.<br>
	 *  This data can be used by application code for any purpose.  This API allows<br>
	 *  multiple applications to store independent data through the use of a key.<br>
	 *  This is not meant to be a database!  A fixed and small # of key slots are available<br>
	 *  (can be sized by changing a constant and recompilation).<br>
	 *  \sa clAmsMgmtEntityUserDataDeleteKey(), clAmsMgmtEntityUserDataSet(), clAmsMgmtEntityUserDataGetKey()<br>
	 * Original signature : <code>int clAmsMgmtEntityUserDataSetKey(ClAmsMgmtHandleT, ClAmsEntityT*, ClNameT*, ClCharT*, int)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3381</i><br>
	 * @deprecated use the safer methods {@link #clAmsMgmtEntityUserDataSetKey(long, clAmsMgmtClientApi.ClAmsEntityConfigT, com.sun.jna.Pointer, java.nio.ByteBuffer, )} and {@link #clAmsMgmtEntityUserDataSetKey(long, clAmsMgmtClientApi.ClAmsEntityConfigT, com.sun.jna.Pointer, com.sun.jna.Pointer, )} instead
	 */
	@Deprecated 
	int clAmsMgmtEntityUserDataSetKey(long handle, ClAmsEntityConfigT entity, Pointer key, Pointer data, int len);
	/**
	 * ***********************************<br>
	 *  \brief Associate arbitrary data with an AMF entity and a key<br>
	 *  \param handle (in) The AMS handle returned from clAmsMgmtInitialize() API.<br>
	 *  \param entity (in) Name and type of the relevant entity<br>
	 *  \param data   (in) Buffer of data to associate<br>
	 *  \param len    (in) Length (bytes) of the data in the buffer<br>
	 * <br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_CID_CNT:CL_ERR_NOT_EXIST  The key does not exist<br>
	 *  \retval CL_CID_AMS:CL_ERR_NOT_EXIST  The entity does not exist<br>
	 *  \par Description:<br>
	 *  This API persistently associates an arbitrary chunk of data with this entity.<br>
	 *  This data can be used by application code for any purpose.  This API allows<br>
	 *  multiple applications to store independent data through the use of a key.<br>
	 *  This is not meant to be a database!  A fixed and small # of key slots are available<br>
	 *  (can be sized by changing a constant and recompilation).<br>
	 *  \sa clAmsMgmtEntityUserDataDeleteKey(), clAmsMgmtEntityUserDataSet(), clAmsMgmtEntityUserDataGetKey()<br>
	 * Original signature : <code>int clAmsMgmtEntityUserDataSetKey(ClAmsMgmtHandleT, ClAmsEntityT*, ClNameT*, ClCharT*, int)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3381</i>
	 */
	int clAmsMgmtEntityUserDataSetKey(long handle, ClAmsEntityConfigT entity, ClNameT key, String data, int len);
	/**
	 * ***********************************<br>
	 *  \brief Retrieve arbitrary data associated with an AMF entity<br>
	 *  \param handle (in) The AMS handle returned from clAmsMgmtInitialize() API.<br>
	 *  \param entity (in) Name and type of the relevant entity<br>
	 *  \param data   (out) pointer to buffer of data.  I will malloc.  Free using clHeapFree)<br>
	 *  \param len    (out) Length (bytes) of the data in the buffer<br>
	 * <br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_CID_CNT:CL_ERR_NOT_EXIST  The key does not exist<br>
	 *  \retval CL_CID_AMS:CL_ERR_NOT_EXIST  The entity does not exist<br>
	 *  \par Description:<br>
	 *  This API retrieves the arbitrary chunk of data associated with this entity.<br>
	 *  This data can be used by application code for any purpose.<br>
	 *  \sa clAmsMgmtEntityUserDataDelete(), clAmsMgmtEntityUserDataSet(), clAmsMgmtEntityUserDataGetKey()<br>
	 * Original signature : <code>int clAmsMgmtEntityUserDataGet(ClAmsMgmtHandleT, ClAmsEntityT*, ClCharT**, int*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3406</i>
	 */
	int clAmsMgmtEntityUserDataGet(long handle, ClAmsEntityConfigT entity, PointerByReference data, int len);
	/**
	 * ***********************************<br>
	 *  \brief Retrieve arbitrary data associated with an AMF entity and a key<br>
	 *  \param handle (in) The AMS handle returned from clAmsMgmtInitialize() API.<br>
	 *  \param entity (in) Name and type of the relevant entity<br>
	 *  \param data   (out) pointer to buffer of data.  I will malloc.  Free using clHeapFree)<br>
	 *  \param len    (out) Length (bytes) of the data in the buffer<br>
	 * <br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_CID_CNT:CL_ERR_NOT_EXIST  The key does not exist<br>
	 *  \retval CL_CID_AMS:CL_ERR_NOT_EXIST  The entity does not exist<br>
	 *  \par Description:<br>
	 *  This API retrieves the arbitrary chunk of data associated with this entity.<br>
	 *  This data can be used by application code for any purpose.  This API allows<br>
	 *  multiple applications to store independent data through the use of a key.<br>
	 *  This is not meant to be a database!  A fixed and small # of key slots are available<br>
	 *  (can be sized by changing a constant and recompilation).<br>
	 *  \sa clAmsMgmtEntityUserDataDeleteKey(), clAmsMgmtEntityUserDataSet(), clAmsMgmtEntityUserDataGetKey()<br>
	 * Original signature : <code>int clAmsMgmtEntityUserDataGetKey(ClAmsMgmtHandleT, ClAmsEntityT*, ClNameT*, ClCharT**, int*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3434</i>
	 */
	int clAmsMgmtEntityUserDataGetKey(long handle, ClAmsEntityConfigT entity, Pointer key, PointerByReference data, int len);
	/**
	 * ***********************************<br>
	 *  \brief Deletes the data for the default key associated with an AMF entity<br>
	 *  \param handle (in) The AMS handle returned from clAmsMgmtInitialize() API.<br>
	 *  \param entity (in) Name and type of the relevant entity <br>
	 * <br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_CID_AMS:CL_ERR_NOT_EXIST  The entity does not exist<br>
	 *  \par Description:<br>
	 *  This API deletes the arbitrary chunk of data for the default key associated with this entity.<br>
	 *  This data can be used by application code for any purpose.<br>
	 *  \sa clAmsMgmtEntityUserDataDeleteKey(), clAmsMgmtEntityUserDataSet(), clAmsMgmtEntityUserDataGetKey()<br>
	 * Original signature : <code>int clAmsMgmtEntityUserDataDelete(ClAmsMgmtHandleT, ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3456</i>
	 */
	int clAmsMgmtEntityUserDataDelete(long handle, ClAmsEntityConfigT entity);
	/**
	 * ***********************************<br>
	 *  \brief Deletes the arbitrary data associated with an AMF entity and a key<br>
	 *  \param handle (in) The AMS handle returned from clAmsMgmtInitialize() API.<br>
	 *  \param entity (in) Name and type of the relevant entity<br>
	 *  \param data   (out) pointer to buffer of data.  I will malloc.  Free using clHeapFree)<br>
	 *  \param len    (out) Length (bytes) of the data in the buffer<br>
	 * <br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_CID_CNT:CL_ERR_NOT_EXIST  The key does not exist<br>
	 *  \retval CL_CID_AMS:CL_ERR_NOT_EXIST  The entity does not exist<br>
	 *  \par Description:<br>
	 *  This API deletes the arbitrary chunk of data associated with this entity.<br>
	 *  This data can be used by application code for any purpose.  This API allows<br>
	 *  key-specific data to be deleted.<br>
	 *  This is not meant to be a database!  A fixed and small # of key slots are available<br>
	 *  (can be sized by changing a constant and recompilation).<br>
	 *  \sa clAmsMgmtEntityUserDataSetKey(), clAmsMgmtEntityUserDataGetKey()<br>
	 * Original signature : <code>int clAmsMgmtEntityUserDataDeleteKey(ClAmsMgmtHandleT, ClAmsEntityT*, ClNameT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3483</i>
	 */
	int clAmsMgmtEntityUserDataDeleteKey(long handle, ClAmsEntityConfigT entity, Pointer key);
	/**
	 * ***********************************<br>
	 *  \brief Deletes all the data associated with an AMF entity for all keys<br>
	 *  \param handle (in) The AMS handle returned from clAmsMgmtInitialize() API.<br>
	 *  \param entity (in) Name and type of the relevant entity <br>
	 * <br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_CID_AMS:CL_ERR_NOT_EXIST  The entity does not exist<br>
	 *  \par Description:<br>
	 *  This API deletes the arbitrary chunk of data for all the keys associated with this entity.<br>
	 *  This data can be used by application code for any purpose.<br>
	 *  \sa clAmsMgmtEntityUserDataDeleteKey(), clAmsMgmtEntityUserDataSet(), clAmsMgmtEntityUserDataGetKey()<br>
	 * Original signature : <code>int clAmsMgmtEntityUserDataDeleteAll(ClAmsMgmtHandleT, ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3505</i>
	 */
	int clAmsMgmtEntityUserDataDeleteAll(long handle, ClAmsEntityConfigT entity);
	/**
	 * ***********************************<br>
	 *  \brief Changes the 'Active' Service Unit.  All work (SIs) assigned active in the specified SU will be<br>
	 *  moved to another specified SU.<br>
	 *  \param handle (in) The AMS handle returned from clAmsMgmtInitialize() API.<br>
	 *  \param entity (in) A Node or SU that should become active <br>
	 *  \param entity (in) activeSU The currently active SU that will be deactivated.<br>
	 *                     NULL can be passed if this is obvious (1+1 redundancy, for example).<br>
	 * <br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_CID_AMS:CL_ERR_NOT_EXIST  The entity does not exist<br>
	 *  \par Description:<br>
	 *  This API deletes the arbitrary chunk of data for all the keys associated with this entity.<br>
	 *  This data can be used by application code for any purpose.<br>
	 *  \sa clAmsMgmtSIAssignSU<br>
	 * Original signature : <code>int clAmsMgmtSetActive(ClAmsMgmtHandleT, ClAmsEntityT*, ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3528</i>
	 */
	int clAmsMgmtSetActive(long handle, ClAmsEntityConfigT entity, ClAmsEntityConfigT activeSU);
	/**
	 * Original signature : <code>int clAmsMgmtSIAssignSU(const ClCharT*, const ClCharT*, const ClCharT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3530</i><br>
	 * @deprecated use the safer methods {@link #clAmsMgmtSIAssignSU(java.nio.ByteBuffer, java.nio.ByteBuffer, java.nio.ByteBuffer)} and {@link #clAmsMgmtSIAssignSU(com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	int clAmsMgmtSIAssignSU(Pointer si, Pointer activeSU, Pointer standbySU);
	/**
	 * Original signature : <code>int clAmsMgmtSIAssignSU(const ClCharT*, const ClCharT*, const ClCharT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3530</i>
	 */
	int clAmsMgmtSIAssignSU(String si, String activeSU, String standbySU);
	/**
	 * Original signature : <code>int clAmsMgmtGetAspInstallInfo(ClAmsMgmtHandleT, const ClCharT*, ClCharT*, int)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3532</i><br>
	 * @deprecated use the safer methods {@link #clAmsMgmtGetAspInstallInfo(long, java.nio.ByteBuffer, java.nio.ByteBuffer, )} and {@link #clAmsMgmtGetAspInstallInfo(long, com.sun.jna.Pointer, com.sun.jna.Pointer, )} instead
	 */
	@Deprecated 
	int clAmsMgmtGetAspInstallInfo(long handle, Pointer nodeName, Pointer aspInstallInfo, int len);
	/**
	 * Original signature : <code>int clAmsMgmtGetAspInstallInfo(ClAmsMgmtHandleT, const ClCharT*, ClCharT*, int)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3532</i>
	 */
	int clAmsMgmtGetAspInstallInfo(long handle, String nodeName, String aspInstallInfo, int len);
	/**
	 * Original signature : <code>int clAmsMgmtFreeCompCSIRefBuffer(ClAmsCompCSIRefBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3535</i>
	 */
	int clAmsMgmtFreeCompCSIRefBuffer(ClAmsCompCSIRefBufferT buffer);
	/**
	 * Original signature : <code>int clAmsMgmtDBGet(ClAmsMgmtDBHandleT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3537</i>
	 */
	int clAmsMgmtDBGet(PointerByReference db);
	/**
	 * Original signature : <code>int clAmsMgmtDBGetNodeList(ClAmsMgmtDBHandleT, ClAmsEntityBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3539</i>
	 */
	int clAmsMgmtDBGetNodeList(Pointer db, ClAmsEntityBufferT.ByReference buffer);
	/**
	 * Original signature : <code>int clAmsMgmtDBGetSUList(ClAmsMgmtDBHandleT, ClAmsEntityBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3542</i>
	 */
	int clAmsMgmtDBGetSUList(Pointer db, ClAmsEntityBufferT.ByReference buffer);
	/**
	 * Original signature : <code>int clAmsMgmtDBGetSGList(ClAmsMgmtDBHandleT, ClAmsEntityBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3545</i>
	 */
	int clAmsMgmtDBGetSGList(Pointer db, ClAmsEntityBufferT.ByReference buffer);
	/**
	 * Original signature : <code>int clAmsMgmtDBGetSIList(ClAmsMgmtDBHandleT, ClAmsEntityBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3548</i>
	 */
	int clAmsMgmtDBGetSIList(Pointer db, ClAmsEntityBufferT.ByReference buffer);
	/**
	 * Original signature : <code>int clAmsMgmtDBGetCSIList(ClAmsMgmtDBHandleT, ClAmsEntityBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3551</i>
	 */
	int clAmsMgmtDBGetCSIList(Pointer db, ClAmsEntityBufferT.ByReference buffer);
	/**
	 * Original signature : <code>int clAmsMgmtDBGetCompList(ClAmsMgmtDBHandleT, ClAmsEntityBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3554</i>
	 */
	int clAmsMgmtDBGetCompList(Pointer db, ClAmsEntityBufferT.ByReference buffer);
	/**
	 * Original signature : <code>int clAmsMgmtDBGetEntityConfig(ClAmsMgmtDBHandleT, ClAmsEntityT*, ClAmsEntityConfigT**)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3557</i><br>
	 * use the safer method {@link #clAmsMgmtDBGetEntityConfig(com.sun.jna.Pointer, clAmsMgmtClientApi.ClAmsEntityConfigT, clAmsMgmtClientApi.ClAmsEntityConfigT.ByReference[])} instead
	 */
	//@Deprecated 
	int clAmsMgmtDBGetEntityConfig(Pointer db, ClAmsEntityConfigT entity, PointerByReference entityConfig);
	/**
	 * Original signature : <code>int clAmsMgmtDBGetEntityConfig(ClAmsMgmtDBHandleT, ClAmsEntityT*, ClAmsEntityConfigT**)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3557</i>
	 */
	//int clAmsMgmtDBGetEntityConfig(Pointer db, ClAmsEntityConfigT entity, ClAmsEntityConfigT.ByReference entityConfig[]);
	/**
	 * Original signature : <code>int clAmsMgmtDBGetEntityStatus(ClAmsMgmtDBHandleT, ClAmsEntityT*, ClAmsEntityStatusT**)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3560</i><br>
	 * use the safer method {@link #clAmsMgmtDBGetEntityStatus(com.sun.jna.Pointer, clAmsMgmtClientApi.ClAmsEntityConfigT, clAmsMgmtClientApi.ClAmsEntityStatusT.ByReference[])} instead
	 */
	//@Deprecated 
	int clAmsMgmtDBGetEntityStatus(Pointer db, ClAmsEntityConfigT entity, PointerByReference entityStatus);
	/**
	 * Original signature : <code>int clAmsMgmtDBGetEntityStatus(ClAmsMgmtDBHandleT, ClAmsEntityT*, ClAmsEntityStatusT**)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3560</i>
	 */
	//int clAmsMgmtDBGetEntityStatus(Pointer db, ClAmsEntityConfigT entity, clAmsMgmtClientApi.ClAmsEntityStatusT.ByReference entityStatus[]);
	/**
	 * Original signature : <code>int clAmsMgmtDBGetNodeSUList(ClAmsMgmtDBHandleT, ClAmsEntityT*, ClAmsEntityBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3563</i>
	 */
	int clAmsMgmtDBGetNodeSUList(Pointer db, ClAmsEntityConfigT entity, ClAmsEntityBufferT.ByReference buffer);
	/**
	 * Original signature : <code>int clAmsMgmtDBGetSGSUList(ClAmsMgmtDBHandleT, ClAmsEntityT*, ClAmsEntityBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3566</i>
	 */
	int clAmsMgmtDBGetSGSUList(Pointer db, ClAmsEntityConfigT entity, ClAmsEntityBufferT.ByReference buffer);
	/**
	 * Original signature : <code>int clAmsMgmtDBGetSGSIList(ClAmsMgmtDBHandleT, ClAmsEntityT*, ClAmsEntityBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3569</i>
	 */
	int clAmsMgmtDBGetSGSIList(Pointer db, ClAmsEntityConfigT entity, ClAmsEntityBufferT.ByReference buffer);
	/**
	 * Original signature : <code>int clAmsMgmtDBGetSICSIList(ClAmsMgmtDBHandleT, ClAmsEntityT*, ClAmsEntityBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3572</i>
	 */
	int clAmsMgmtDBGetSICSIList(Pointer db, ClAmsEntityConfigT entity, ClAmsEntityBufferT.ByReference buffer);
	/**
	 * Original signature : <code>int clAmsMgmtDBGetSUCompList(ClAmsMgmtDBHandleT, ClAmsEntityT*, ClAmsEntityBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3575</i>
	 */
	int clAmsMgmtDBGetSUCompList(Pointer db, ClAmsEntityConfigT entity, ClAmsEntityBufferT.ByReference buffer);
	/**
	 * Original signature : <code>int clAmsMgmtDBGetSUAssignedSIsList(ClAmsMgmtDBHandleT, ClAmsEntityT*, ClAmsSUSIExtendedRefBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3578</i>
	 */
	int clAmsMgmtDBGetSUAssignedSIsList(Pointer db, ClAmsEntityConfigT entity, ClAmsSUSIExtendedRefBufferT.ByReference buffer);
	/**
	 * Original signature : <code>int clAmsMgmtDBGetSISUList(ClAmsMgmtDBHandleT, ClAmsEntityT*, ClAmsSISUExtendedRefBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3581</i>
	 */
	int clAmsMgmtDBGetSISUList(Pointer db, ClAmsEntityConfigT entity, ClAmsSISUExtendedRefBufferT.ByReference buffer);
	/**
	 * Original signature : <code>int clAmsMgmtDBGetCompCSIList(ClAmsMgmtDBHandleT, ClAmsEntityT*, ClAmsCompCSIRefBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3584</i>
	 */
	int clAmsMgmtDBGetCompCSIList(Pointer db, ClAmsEntityConfigT entity, ClAmsCompCSIRefBufferT.ByReference buffer);
	/**
	 * Original signature : <code>int clAmsMgmtDBGetNodeCompList(ClAmsMgmtDBHandleT, const ClCharT*, ClAmsEntityBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3587</i><br>
	 * @deprecated use the safer methods {@link #clAmsMgmtDBGetNodeCompList(com.sun.jna.Pointer, java.nio.ByteBuffer, clAmsMgmtClientApi.ClAmsEntityBufferT)} and {@link #clAmsMgmtDBGetNodeCompList(com.sun.jna.Pointer, com.sun.jna.Pointer, clAmsMgmtClientApi.ClAmsEntityBufferT)} instead
	 */
	@Deprecated 
	int clAmsMgmtDBGetNodeCompList(Pointer cache, Pointer nodeName, ClAmsEntityBufferT compList);
	/**
	 * Original signature : <code>int clAmsMgmtDBGetNodeCompList(ClAmsMgmtDBHandleT, const ClCharT*, ClAmsEntityBufferT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3587</i>
	 */
	int clAmsMgmtDBGetNodeCompList(Pointer cache, String nodeName, ClAmsEntityBufferT.ByReference compList);
	/**
	 * Original signature : <code>int clAmsMgmtDBCacheDump(ClAmsMgmtDBHandleT)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3592</i>
	 */
	int clAmsMgmtDBCacheDump(Pointer db);
	/**
	 * Original signature : <code>int clAmsMgmtDBFinalize(ClAmsMgmtDBHandleT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3594</i>
	 */
	int clAmsMgmtDBFinalize(PointerByReference db);
	/**
	 * Original signature : <code>int clAmsMgmtComputedAdminStateGet(ClAmsMgmtHandleT, ClAmsEntityT*, ClAmsAdminStateT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3596</i>
	 */
	int clAmsMgmtComputedAdminStateGet(long handle, ClAmsEntityConfigT entity, IntByReference adminState);
	/**
	 * AMS mgmt CCB batch apis.<br>
	 * Original signature : <code>int clAmsMgmtCCBBatchInitialize(ClAmsMgmtHandleT, ClAmsMgmtCCBBatchHandleT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3604</i>
	 */
	int clAmsMgmtCCBBatchInitialize(long mgmtHandle, PointerByReference batchHandle);
	/**
	 * Original signature : <code>int clAmsMgmtCCBBatchFinalize(ClAmsMgmtCCBBatchHandleT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3606</i>
	 */
	int clAmsMgmtCCBBatchFinalize(PointerByReference batchHandle);
	/**
	 * Original signature : <code>int clAmsMgmtCCBBatchEntityCreate(ClAmsMgmtCCBBatchHandleT, const ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3608</i>
	 */
	int clAmsMgmtCCBBatchEntityCreate(Pointer batchHandle, ClAmsEntityConfigT entity);
	/**
	 * Original signature : <code>int clAmsMgmtCCBBatchEntityDelete(ClAmsMgmtCCBBatchHandleT, const ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3611</i>
	 */
	int clAmsMgmtCCBBatchEntityDelete(Pointer batchHandle, ClAmsEntityConfigT entity);
	/**
	 * Original signature : <code>int clAmsMgmtCCBBatchEntitySetConfig(ClAmsMgmtCCBBatchHandleT, ClAmsEntityConfigT*, ClUint64T)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3614</i>
	 */
	int clAmsMgmtCCBBatchEntitySetConfig(Pointer batchHandle, ClAmsEntityConfigT entityConfig, long bitmask);
	/**
	 * Original signature : <code>int clAmsMgmtCCBBatchCSISetNVP(ClAmsMgmtCCBBatchHandleT, ClAmsEntityT*, ClAmsCSINVPT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3618</i>
	 */
	int clAmsMgmtCCBBatchCSISetNVP(Pointer batchHandle, ClAmsEntityConfigT csiName, ClAmsCSINameValuePairT nvp);
	/**
	 * Original signature : <code>int clAmsMgmtCCBBatchCSIDeleteNVP(ClAmsMgmtCCBBatchHandleT, ClAmsEntityT*, ClAmsCSINVPT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3622</i>
	 */
	int clAmsMgmtCCBBatchCSIDeleteNVP(Pointer batchHandle, ClAmsEntityConfigT csiName, ClAmsCSINameValuePairT nvp);
	/**
	 * Original signature : <code>int clAmsMgmtCCBBatchSetNodeDependency(ClAmsMgmtCCBBatchHandleT, ClAmsEntityT*, ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3627</i>
	 */
	int clAmsMgmtCCBBatchSetNodeDependency(Pointer batchHandle, ClAmsEntityConfigT nodeName, ClAmsEntityConfigT dependencyNodeName);
	/**
	 * Original signature : <code>int clAmsMgmtCCBBatchDeleteNodeDependency(ClAmsMgmtCCBBatchHandleT, ClAmsEntityT*, ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3632</i>
	 */
	int clAmsMgmtCCBBatchDeleteNodeDependency(Pointer batchHandle, ClAmsEntityConfigT nodeName, ClAmsEntityConfigT dependencyNodeName);
	/**
	 * Original signature : <code>int clAmsMgmtCCBBatchSetNodeSUList(ClAmsMgmtCCBBatchHandleT, ClAmsEntityT*, ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3637</i>
	 */
	int clAmsMgmtCCBBatchSetNodeSUList(Pointer batchHandle, ClAmsEntityConfigT nodeName, ClAmsEntityConfigT suName);
	/**
	 * Original signature : <code>int clAmsMgmtCCBBatchDeleteNodeSUList(ClAmsMgmtCCBBatchHandleT, ClAmsEntityT*, ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3642</i>
	 */
	int clAmsMgmtCCBBatchDeleteNodeSUList(Pointer batchHandle, ClAmsEntityConfigT nodeName, ClAmsEntityConfigT suName);
	/**
	 * Original signature : <code>int clAmsMgmtCCBBatchSetSGSUList(ClAmsMgmtCCBBatchHandleT, ClAmsEntityT*, ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3647</i>
	 */
	int clAmsMgmtCCBBatchSetSGSUList(Pointer batchHandle, ClAmsEntityConfigT sgName, ClAmsEntityConfigT suName);
	/**
	 * Original signature : <code>int clAmsMgmtCCBBatchDeleteSGSUList(ClAmsMgmtCCBBatchHandleT, ClAmsEntityT*, ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3652</i>
	 */
	int clAmsMgmtCCBBatchDeleteSGSUList(Pointer batchHandle, ClAmsEntityConfigT sgName, ClAmsEntityConfigT suName);
	/**
	 * Original signature : <code>int clAmsMgmtCCBBatchSetSGSIList(ClAmsMgmtCCBBatchHandleT, ClAmsEntityT*, ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3657</i>
	 */
	int clAmsMgmtCCBBatchSetSGSIList(Pointer batchHandle, ClAmsEntityConfigT sgName, ClAmsEntityConfigT siName);
	/**
	 * Original signature : <code>int clAmsMgmtCCBBatchDeleteSGSIList(ClAmsMgmtCCBBatchHandleT, ClAmsEntityT*, ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3662</i>
	 */
	int clAmsMgmtCCBBatchDeleteSGSIList(Pointer batchHandle, ClAmsEntityConfigT sgName, ClAmsEntityConfigT siName);
	/**
	 * Original signature : <code>int clAmsMgmtCCBBatchSetSUCompList(ClAmsMgmtCCBBatchHandleT, ClAmsEntityT*, ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3667</i>
	 */
	int clAmsMgmtCCBBatchSetSUCompList(Pointer batchHandle, ClAmsEntityConfigT suName, ClAmsEntityConfigT compName);
	/**
	 * Original signature : <code>int clAmsMgmtCCBBatchDeleteSUCompList(ClAmsMgmtCCBBatchHandleT, ClAmsEntityT*, ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3672</i>
	 */
	int clAmsMgmtCCBBatchDeleteSUCompList(Pointer batchHandle, ClAmsEntityConfigT suName, ClAmsEntityConfigT compName);
	/**
	 * Original signature : <code>int clAmsMgmtCCBBatchSetSISURankList(ClAmsMgmtCCBBatchHandleT, ClAmsEntityT*, ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3677</i>
	 */
	int clAmsMgmtCCBBatchSetSISURankList(Pointer batchHandle, ClAmsEntityConfigT siName, ClAmsEntityConfigT suName);
	/**
	 * Original signature : <code>int clAmsMgmtCCBBatchDeleteSISURankList(ClAmsMgmtCCBBatchHandleT, ClAmsEntityT*, ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3682</i>
	 */
	int clAmsMgmtCCBBatchDeleteSISURankList(Pointer batchHandle, ClAmsEntityConfigT siName, ClAmsEntityConfigT suName);
	/**
	 * Original signature : <code>int clAmsMgmtCCBBatchSetSIDependency(ClAmsMgmtCCBBatchHandleT, ClAmsEntityT*, ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3687</i>
	 */
	int clAmsMgmtCCBBatchSetSIDependency(Pointer batchHandle, ClAmsEntityConfigT siName, ClAmsEntityConfigT dependencySIName);
	/**
	 * Original signature : <code>int clAmsMgmtCCBBatchDeleteSIDependency(ClAmsMgmtCCBBatchHandleT, ClAmsEntityT*, ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3692</i>
	 */
	int clAmsMgmtCCBBatchDeleteSIDependency(Pointer batchHandle, ClAmsEntityConfigT siName, ClAmsEntityConfigT dependencySIName);
	/**
	 * Original signature : <code>int clAmsMgmtCCBBatchSetCSIDependency(ClAmsMgmtCCBBatchHandleT, ClAmsEntityT*, ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3697</i>
	 */
	int clAmsMgmtCCBBatchSetCSIDependency(Pointer batchHandle, ClAmsEntityConfigT csiName, ClAmsEntityConfigT dependencyCSIName);
	/**
	 * Original signature : <code>int clAmsMgmtCCBBatchDeleteCSIDependency(ClAmsMgmtCCBBatchHandleT, ClAmsEntityT*, ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3702</i>
	 */
	int clAmsMgmtCCBBatchDeleteCSIDependency(Pointer batchHandle, ClAmsEntityConfigT csiName, ClAmsEntityConfigT dependencyCSIName);
	/**
	 * Original signature : <code>int clAmsMgmtCCBBatchSetSICSIList(ClAmsMgmtCCBBatchHandleT, ClAmsEntityT*, ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3707</i>
	 */
	int clAmsMgmtCCBBatchSetSICSIList(Pointer batchHandle, ClAmsEntityConfigT siName, ClAmsEntityConfigT csiName);
	/**
	 * Original signature : <code>int clAmsMgmtCCBBatchDeleteSICSIList(ClAmsMgmtCCBBatchHandleT, ClAmsEntityT*, ClAmsEntityT*)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3712</i>
	 */
	int clAmsMgmtCCBBatchDeleteSICSIList(Pointer batchHandle, ClAmsEntityConfigT siName, ClAmsEntityConfigT csiName);
	/**
	 * Original signature : <code>int clAmsMgmtCCBBatchCommit(ClAmsMgmtCCBBatchHandleT)</code><br>
	 * <i>native declaration : clAmsMgmtClientApi.h:3717</i>
	 */
	int clAmsMgmtCCBBatchCommit(Pointer batchHandle);	
}
