package clCkptApi;
import com.sun.jna.Callback;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.Pointer;
import com.sun.jna.PointerType;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.LongByReference;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import java.nio.LongBuffer;
import clUtils.ClUtilsLibrary;
/**
 * JNA Wrapper for library <b>clCkpt</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface ClCkptLibrary extends Library {
	public static final String JNA_LIBRARY_NAME = "ClCkpt";
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(ClCkptLibrary.JNA_LIBRARY_NAME);
	public static final ClCkptLibrary INSTANCE = (ClCkptLibrary)Native.load(ClCkptLibrary.JNA_LIBRARY_NAME, ClCkptLibrary.class);
	/**
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h</i><br>
	 * enum values
	 */
	public static interface ClCkptSectionStateT {
		/**
		 * Indicates that the section is fine.<br>
		 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h:236</i>
		 */
		public static final int CL_CKPT_SECTION_VALID = 1;
		/**
		 * Indicates that the section has been corrupted.<br>
		 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h:241</i>
		 */
		public static final int CL_CKPT_SECTION_CORRUPTED = 2;
	};
	/**
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h</i><br>
	 * enum values
	 */
	public static interface ClCkptSectionsChosenT {
		/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h:282</i> */
		public static final int CL_CKPT_SECTIONS_FOREVER = 1;
		/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h:287</i> */
		public static final int CL_CKPT_SECTIONS_LEQ_EXPIRATION_TIME = 2;
		/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h:292</i> */
		public static final int CL_CKPT_SECTIONS_GEQ_EXPIRATION_TIME = 3;
		/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h:296</i> */
		public static final int CL_CKPT_SECTIONS_CORRUPTED = 4;
		/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h:300</i> */
		public static final int CL_CKPT_SECTIONS_ANY = 5;
	};
	/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h</i> */
	public static final int CL_CKPT_WR_ALL_REPLICAS = (int)0X1;
	/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h</i> */
	public static final int CL_CKPT_WR_ACTIVE_REPLICA = (int)0X2;
	/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h</i> */
	public static final int CL_CKPT_WR_ACTIVE_REPLICA_WEAK = (int)0X4;
	/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h</i> */
	public static final int CL_CKPT_CHECKPOINT_COLLOCATED = (int)0X8;
	/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h</i> */
	public static final int CL_CKPT_DISTRIBUTED = (int)0X10;
	/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h</i> */
	public static final int CL_CKPT_WR_ALL_SAFE = (int)0X20;
	/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h</i> */
	public static final int CL_CKPT_ALL_OPEN_ARE_REPLICAS = (int)0x40;
	/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h</i> */
	public static final int CL_CKPT_PEER_TO_PEER_REPLICA = (int)0x80;
	/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h</i> */
	public static final int CL_CKPT_PEER_TO_PEER_CACHE_DISABLE = (int)0x100;
	/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h</i> */
	public static final int CL_CKPT_CHECKPOINT_READ = (int)0X1;
	/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h</i> */
	public static final int CL_CKPT_CHECKPOINT_WRITE = (int)0X2;
	/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h</i> */
	public static final int CL_CKPT_CHECKPOINT_CREATE = (int)0X4;
	/**
	 * ***********************************<br>
	 *  \brief This function gets called whenever a checkpoint is getting updated  <br>
	 *   on the local server. Provided the application has been registered for the <br>
	 *   checkpoint update.<br>
	 * *  \par Header File:<br>
	 *  clCkptApi.h<br>
	 * *  \param ckptHdl (in) Handle of the updated checkpoint.  <br>
	 * *  \param pName (in) Name of the checkpoint has been updated locally. <br>
	 * *  \param pIoVector (in) List of updated sections and data of the checkpoint. <br>
	 * *  \param numSections (in) Number of sections are being updated on this checkpoint. <br>
	 * *  \param pCookie (in) Cookie which got from clCkptImmediateConsumptionRegister will be given back to <br>
	 *                      application via this variable.<br>
	 * *  \retval  CL_OK The Log stream is opened successfully. <br>
	 * *  \retval  CL_ERR_TIMEOUT An implementation defined timeout occurred before the call<br>
	 *  could complete.<br>
	 * *  \retval  CL_ERR_NO_MEMORY Either the Ckpt Service library or some other module of <br>
	 *  Ckpt Service is out of memory. Thus service can not be provided at this time. This<br>
	 *  may be a transient problem.<br>
	 * *  \par Description:<br>
	 *  This notification callback is getting called, whenever the particular <br>
	 *  checkpoint has been updated on the local server.This callback will be called<br>
	 *  for whoever registers for the checkpoint update. Thie notication callback will be <br>
	 *  registered through clCkptImmediateConsumptionRegister() call. This function carries <br>
	 *  information about all updated sections and number of sections. This is mainly used<br>
	 *  for HOT stanby applications on which the stanby application will be notified <br>
	 *  immediately.  <br>
	 * *  \par Library File:<br>
	 *  ClCkpt<br>
	 * *  \sa clCkptImmediateConsumptionRegister<br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h:400</i>
	 */
	/*public interface ClRcT extends Callback {
		ClCkptLibrary.ClRcT_callback apply(Pointer ClCkptNotificationCallbackT);
	};*/
	
	/*public interface ClCkptNotificationCallbackT extends Callback {
		void apply(long ckptHdl, clUtils.ClUtilsLibrary.ClNameT name, );
	};*/
	
	/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h</i> */
	public interface ClCkptCheckpointOpenCallbackT extends Callback {
		void apply(long invocation, long checkpointHandle, int error);
	};
	/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h</i> */
	public interface ClCkptCheckpointSynchronizeCallbackT extends Callback {
		void apply(long invocation, int error);
	};
	/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h</i> */
	public interface ClCkptNotificationCallbackT extends Callback {
		int apply(long ckptHdl, clUtils.ClUtilsLibrary.ClNameT pName, ClCkptIOVectorElementT pIOVector, int numSections, Pointer pCookie);
	};
	/**
	 * ***********************************<br>
	 *  \brief  Initializes the checkpoint service client and registers the various callbacks.<br>
	 *  \par Header File:<br>
	 *  clCkptApi.h<br>
	 *  \param ckptSvcHandle (out) Checkpoint service handle created by the checkpoint client<br>
	 *  and returned to the application. This handle designates this particular initialization of the<br>
	 *  the Checkpoint Service. The application must not modify or interpret this.<br>
	 *  \param callbacks Optional callbacks for applications which use asynchronous checkpoints.<br>
	 *  \param version (in/out)  As an input parameter, version is a pointer to the required<br>
	 *  Checkpoint Service version.  As an output parameter, the version actually supported by the<br>
	 *  Checkpoint Service is delivered.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_TRY_AGAIN System is in a transitory unstable state, please try later.<br>
	 *  \retval CL_ERR_NULL_POINTER<br>
	 *  \retval CL_ERR_VERSION_MISMATCH<br>
	 *  \par Description:<br>
	 *  This function initializes the Checkpoint library for the invoking process and registers<br>
	 *  the various callback functions. This function must be invoked prior to the invocation of<br>
	 *  any other Checkpoint Service functionality. The handle \e ckptSvcHandle is returned as the<br>
	 *  reference to this association between the process and the Checkpoint Service. The<br>
	 *  process uses this handle in subsequent communication with the Checkpoint Service.<br>
	 * *x<br>
	 *  \par Library File:<br>
	 *  ClCkpt<br>
	 *  \sa clCkptFinalize()<br>
	 * Checkpoint service handle<br>
	 * Original signature : <code>ClRcT clCkptInitialize(ClCkptSvcHdlT*, const ClCkptCallbacksT*, ClVersionT*)</code><br>
	 * @param ckptSvcHandle Checkpoint service handle<br>
	 * @param callbacks Optional callbacks<br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h:565</i><br>
	 * @deprecated use the safer methods {@link #clCkptInitialize(java.nio.LongBuffer, clCkptApi.ClCkptCallbacksT, com.sun.jna.Pointer)} and {@link #clCkptInitialize(com.sun.jna.ptr.LongByReference, clCkptApi.ClCkptCallbacksT, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	int clCkptInitialize(LongByReference ckptSvcHandle, ClCkptCallbacksT callbacks, Pointer version);
	/**
	 * ***********************************<br>
	 *  \brief  Initializes the checkpoint service client and registers the various callbacks.<br>
	 *  \par Header File:<br>
	 *  clCkptApi.h<br>
	 *  \param ckptSvcHandle (out) Checkpoint service handle created by the checkpoint client<br>
	 *  and returned to the application. This handle designates this particular initialization of the<br>
	 *  the Checkpoint Service. The application must not modify or interpret this.<br>
	 *  \param callbacks Optional callbacks for applications which use asynchronous checkpoints.<br>
	 *  \param version (in/out)  As an input parameter, version is a pointer to the required<br>
	 *  Checkpoint Service version.  As an output parameter, the version actually supported by the<br>
	 *  Checkpoint Service is delivered.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_TRY_AGAIN System is in a transitory unstable state, please try later.<br>
	 *  \retval CL_ERR_NULL_POINTER<br>
	 *  \retval CL_ERR_VERSION_MISMATCH<br>
	 *  \par Description:<br>
	 *  This function initializes the Checkpoint library for the invoking process and registers<br>
	 *  the various callback functions. This function must be invoked prior to the invocation of<br>
	 *  any other Checkpoint Service functionality. The handle \e ckptSvcHandle is returned as the<br>
	 *  reference to this association between the process and the Checkpoint Service. The<br>
	 *  process uses this handle in subsequent communication with the Checkpoint Service.<br>
	 * *x<br>
	 *  \par Library File:<br>
	 *  ClCkpt<br>
	 *  \sa clCkptFinalize()<br>
	 * Checkpoint service handle<br>
	 * Original signature : <code>ClRcT clCkptInitialize(ClCkptSvcHdlT*, const ClCkptCallbacksT*, ClVersionT*)</code><br>
	 * @param ckptSvcHandle Checkpoint service handle<br>
	 * @param callbacks Optional callbacks<br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h:565</i>
	 */
	int clCkptInitialize(LongBuffer ckptSvcHandle, ClCkptCallbacksT callbacks, Pointer version);
	/**
	 * ***********************************<br>
	 *  \brief  Closes the checkpoint service client and cancels all pending callbacks related to the handle.<br>
	 *  \par Header File:<br>
	 *  clCkptApi.h<br>
	 *  \param ckptHandle The handle, obtained through the clCkptInitialize() function,<br>
	 *   designating this particular initialization of the Checkpoint Service.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \par Description:<br>
	 *  The clCkptFinalize() function closes the association, represented by the \e ckptHandle<br>
	 *  parameter, between the invoking process and the Checkpoint Service. The process<br>
	 *  must have invoked clCkptInitialize() before it invokes this function. A process must<br>
	 *  invoke this function once for each handle acquired by invoking  clCkptInitialize(). <br>
	 *  \par <br>
	 *  If the clCkptFinalize() function returns successfully, the clCkptFinalize() function<br>
	 *  releases all resources acquired when clCkptInitialize() was called. Moreover, it<br>
	 *  closes all checkpoints that are open for the particular handle. Furthermore, it cancels<br>
	 *  all pending callbacks related to the particular handle. <br>
	 *  \par <br>
	 *  After clCkptFinalize() is called, the selection object is no longer valid. Note that<br>
	 *  because the callback invocation is asynchronous, it is still possible that some callback<br>
	 *  calls are processed after this call returns successfully.<br>
	 *  \par Library File:<br>
	 *  ClCkpt<br>
	 *  \sa clCkptInitialize()<br>
	 * Original signature : <code>ClRcT clCkptFinalize(ClCkptSvcHdlT)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h:608</i>
	 */
	int clCkptFinalize(long ckptHandle);
	/**
	 * ***********************************<br>
	 *  \brief Opens an existing checkpoint. If there is no existing checkpoint, <br>
	 *   then this function creates a new checkpoint and opens it.<br>
	 *  \par Header File:<br>
	 *  clCkptApi.h<br>
	 *  \param ckptHandle The handle, obtained through the clCkptInitialize() function,<br>
	 *   designating this particular initialization of the Checkpoint Service.<br>
	 *  \param ckeckpointName Name of the checkpoint to be opened.<br>
	 *  \param  checkpointCreationAttributes A pointer to the create attributes of a the checkpoint.<br>
	 *  Refer to ClCkptCheckpointCreationAttributesT structure. This parameter must be filled<br>
	 *  only when the \c CREATE flag is set.<br>
	 *  \param checkpointOpenFlags  Flags to indicate the desired mode to open. It can have the following values:<br>
	 *  \arg \c CL_CKPT_CHECKPOINT_READ<br>
	 *  \arg \c CL_CKPT_CHECKPOINT_WRITE<br>
	 *  \arg \c CL_CKPT_CHECKPOINT_CREATE<br>
	 *  \param timeout clCkptCheckpointOpen is considered to be failed if not completed within the timeout.<br>
	 *  A checkpoint replica may still be created. [It is not supported currently]<br>
	 *  \param checkpointHandle (out) A pointer to the checkpoint handle, allocated in the address<br>
	 *  space of the invoking process. If the checkpoint is opened successfully, the Checkpoint<br>
	 *  Service stores in \e checkpointHandle the handle that the process uses to access<br>
	 *  the checkpoint in subsequent invocations of the functions of the Checkpoint Service.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER  When the parameters passed are NULL pointers.<br>
	 *  \retval CL_ERR_NOT_INITIALIZED If the checkpoint server is not completely initialized.<br>
	 *  \retval CL_ERR_ALREADY_EXIST If the checkpoint is already existing.<br>
	 *  \retval CL_ERR_NO_MEMORY If there is not enough memory.<br>
	 *  \retval CL_ERR_TRY_AGAIN System is in a transitory unstable state, please try later.<br>
	 *  \par Description:<br>
	 *  The clCkptCheckpointOpen() function opens a checkpoint.<br>
	 *  If the checkpoint does not exist, the checkpoint is created first.<br>
	 *  An invocation of clCkptCheckpointOpen() is blocking. A new checkpoint handle is<br>
	 *  returned upon completion. A checkpoint can be opened multiple times for reading<br>
	 *  and/or writing in the same process or in different processes. <br>
	 *  \par <br>
	 *  When a checkpoint is opened using the clCkptCheckpointOpen() or<br>
	 *  clCkptCheckpointOpenAsync() function, some combination of the creation flags,<br>
	 *  defined in ClCkptCheckpointCreationFlagsT, are bitwise OR-ed together to provide<br>
	 *  the value of the \e creationFlags field of the \e checkpointCreationAttributes parameter.<br>
	 *  \par Library File:<br>
	 *  ClCkpt<br>
	 *  \sa clCkptCheckpointOpenAsync(), clCkptCheckpointClose()<br>
	 * Service handle<br>
	 * Original signature : <code>ClRcT clCkptCheckpointOpen(ClCkptSvcHdlT, const ClNameT*, const ClCkptCheckpointCreationAttributesT*, ClCkptOpenFlagsT, ClTimeT, ClCkptHdlT*)</code><br>
	 * @param ckptHandle Service handle<br>
	 * @param ckeckpointName Name of the checkpoint<br>
	 * @param checkpointOpenFlags Open flags<br>
	 * @param timeout Time out<br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h:667</i><br>
	 * @deprecated use the safer methods {@link #clCkptCheckpointOpen(long, com.sun.jna.Pointer, clCkptApi.ClCkptCheckpointCreationAttributesT, int, long, java.nio.LongBuffer)} and {@link #clCkptCheckpointOpen(long, com.sun.jna.Pointer, clCkptApi.ClCkptCheckpointCreationAttributesT, int, long, com.sun.jna.ptr.LongByReference)} instead
	 */
	@Deprecated 
	int clCkptCheckpointOpen(long ckptHandle, Pointer ckeckpointName, ClCkptCheckpointCreationAttributesT checkpointCreationAttributes, int checkpointOpenFlags, long timeout, LongByReference checkpointHandle);
	/**
	 * ***********************************<br>
	 *  \brief Opens an existing checkpoint. If there is no existing checkpoint, <br>
	 *   then this function creates a new checkpoint and opens it.<br>
	 *  \par Header File:<br>
	 *  clCkptApi.h<br>
	 *  \param ckptHandle The handle, obtained through the clCkptInitialize() function,<br>
	 *   designating this particular initialization of the Checkpoint Service.<br>
	 *  \param ckeckpointName Name of the checkpoint to be opened.<br>
	 *  \param  checkpointCreationAttributes A pointer to the create attributes of a the checkpoint.<br>
	 *  Refer to ClCkptCheckpointCreationAttributesT structure. This parameter must be filled<br>
	 *  only when the \c CREATE flag is set.<br>
	 *  \param checkpointOpenFlags  Flags to indicate the desired mode to open. It can have the following values:<br>
	 *  \arg \c CL_CKPT_CHECKPOINT_READ<br>
	 *  \arg \c CL_CKPT_CHECKPOINT_WRITE<br>
	 *  \arg \c CL_CKPT_CHECKPOINT_CREATE<br>
	 *  \param timeout clCkptCheckpointOpen is considered to be failed if not completed within the timeout.<br>
	 *  A checkpoint replica may still be created. [It is not supported currently]<br>
	 *  \param checkpointHandle (out) A pointer to the checkpoint handle, allocated in the address<br>
	 *  space of the invoking process. If the checkpoint is opened successfully, the Checkpoint<br>
	 *  Service stores in \e checkpointHandle the handle that the process uses to access<br>
	 *  the checkpoint in subsequent invocations of the functions of the Checkpoint Service.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER  When the parameters passed are NULL pointers.<br>
	 *  \retval CL_ERR_NOT_INITIALIZED If the checkpoint server is not completely initialized.<br>
	 *  \retval CL_ERR_ALREADY_EXIST If the checkpoint is already existing.<br>
	 *  \retval CL_ERR_NO_MEMORY If there is not enough memory.<br>
	 *  \retval CL_ERR_TRY_AGAIN System is in a transitory unstable state, please try later.<br>
	 *  \par Description:<br>
	 *  The clCkptCheckpointOpen() function opens a checkpoint.<br>
	 *  If the checkpoint does not exist, the checkpoint is created first.<br>
	 *  An invocation of clCkptCheckpointOpen() is blocking. A new checkpoint handle is<br>
	 *  returned upon completion. A checkpoint can be opened multiple times for reading<br>
	 *  and/or writing in the same process or in different processes. <br>
	 *  \par <br>
	 *  When a checkpoint is opened using the clCkptCheckpointOpen() or<br>
	 *  clCkptCheckpointOpenAsync() function, some combination of the creation flags,<br>
	 *  defined in ClCkptCheckpointCreationFlagsT, are bitwise OR-ed together to provide<br>
	 *  the value of the \e creationFlags field of the \e checkpointCreationAttributes parameter.<br>
	 *  \par Library File:<br>
	 *  ClCkpt<br>
	 *  \sa clCkptCheckpointOpenAsync(), clCkptCheckpointClose()<br>
	 * Service handle<br>
	 * Original signature : <code>ClRcT clCkptCheckpointOpen(ClCkptSvcHdlT, const ClNameT*, const ClCkptCheckpointCreationAttributesT*, ClCkptOpenFlagsT, ClTimeT, ClCkptHdlT*)</code><br>
	 * @param ckptHandle Service handle<br>
	 * @param ckeckpointName Name of the checkpoint<br>
	 * @param checkpointOpenFlags Open flags<br>
	 * @param timeout Time out<br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h:667</i>
	 */
	int clCkptCheckpointOpen(long ckptHandle, Pointer ckeckpointName, ClCkptCheckpointCreationAttributesT checkpointCreationAttributes, int checkpointOpenFlags, long timeout, LongBuffer checkpointHandle);
	/**
	 * ***********************************<br>
	 *  \brief Creates and opens a checkpoint asynchronously.<br>
	 *  \par Header File:<br>
	 *  clCkptApi.h<br>
	 *  \param ckptHandle The handle, obtained through the clCkptInitialize() function,<br>
	 *   designating this particular initialization of the Checkpoint Service.<br>
	 *  \param invocation This parameter is used by the application to identify the callback.<br>
	 *  \param checkpointName Name of the checkpoint to be opened.<br>
	 *  \param checkpointCreationAttributes Pointer to the create attributes of a the checkpoint.<br>
	 *  Refer to ClCkptCheckpointCreationAttributesT structure.<br>
	 *  \param checkpointOpenFlags  Flags to indicate the desired mode to open. It can have the following values:<br>
	 *  \arg \c CL_CKPT_CHECKPOINT_READ<br>
	 *  \arg \c CL_CKPT_CHECKPOINT_WRITE<br>
	 *  \arg \c CL_CKPT_CHECKPOINT_CREATE<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_TRY_AGAIN System is in a transitory unstable state, please try later.<br>
	 *  \par Description:<br>
	 *  This function is used to create and open a checkpoint asynchronously.<br>
	 * *<br>
	 *  \par Library File:<br>
	 *  ClCkpt<br>
	 *  \sa clCkptCheckpointOpen(), clCkptCheckpointClose()<br>
	 * Original signature : <code>ClRcT clCkptCheckpointOpenAsync(ClCkptSvcHdlT, ClInvocationT, const ClNameT*, const ClCkptCheckpointCreationAttributesT*, ClCkptOpenFlagsT)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h:711</i>
	 */
	int clCkptCheckpointOpenAsync(long ckptHandle, long invocation, Pointer checkpointName, ClCkptCheckpointCreationAttributesT checkpoiNtCreationAttributes, int checkpointOpenFlags);
	/**
	 * ***********************************<br>
	 *  \brief Closes the checkpoint designated by the \e checkpointHandle.<br>
	 *  \par Header File:<br>
	 *  clCkptApi.h<br>
	 *  \param checkpointHandle The handle \e checkpointHandle must have been obtained<br>
	 *   previously by the invocation of the clCkptCheckpointOpen() function.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NOT_INITIALIZED If the checkpoint server is not completely initialized.<br>
	 *  \retval CL_ERR_NO_MEMORY On memory allocation failure.<br>
	 *  \par Description:<br>
	 *  This function closes the checkpoint, designated by \e checkpointHandle, which was<br>
	 *  opened by an earlier invocation of the clCkptCheckpointOpen() or<br>
	 *  clCkptCheckpointOpenAsync() function. <br>
	 *  \par <br>
	 *  After this invocation, the handle \e checkpointHandle is no longer valid.<br>
	 *  The deletion of a checkpoint frees all resources allocated by the Checkpoint Service<br>
	 *  for it. When a process is terminated, all of its opened checkpoints are closed.<br>
	 *  This call cancels all pending callbacks that refer directly or indirectly to the handle<br>
	 *  \e checkpointHandle.<br>
	 *  \par <br>
	 *  In case  clCkptCheckpointDelete() has already been called, then by calling the clCkptCheckpointClose()<br>
	 *  function, the reference count to this checkpoint becomes zero and the checkpoint is deleted.<br>
	 *  After this call, if the reference count becomes 0, and clCkptCheckpointDelete() has not been called,<br>
	 *  then the retention timer associated with the checkpoint [ and provided during invocation of<br>
	 *  clCkptCheckpointOpenAsync() or clCkptCheckpointOpen() functions ] is started. On expiration of the timer<br>
	 *  the checkpoint is deleted.<br>
	 *  \par Library File:<br>
	 *  ClCkpt<br>
	 *  \sa clCkptCheckpointOpen(), clCkptCheckpointOpenAsync(), clCkptCheckpointDelete()<br>
	 * Original signature : <code>ClRcT clCkptCheckpointClose(ClCkptHdlT)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h:758</i>
	 */
	int clCkptCheckpointClose(long checkpointHandle);
	/**
	 * ***********************************<br>
	 *  \brief Removes the checkpoint from the system and frees all resources allocated to it.<br>
	 *  \par Header File:<br>
	 *  clCkptApi.ht<br>
	 *  \param ckptHandle The handle, obtained through the clCkptInitialize() function,<br>
	 *   designating this particular initialization of the Checkpoint Service.<br>
	 *  \param checkpointName Pointer to the name of the checkpoint to be deleted.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER  If the parameters passed are NULL pointers.<br>
	 *  \retval CL_ERR_NOT_INITIALIZED If the checkpoint server is not completely initialized.<br>
	 *  \retval CL_ERR_NO_MEMORY On memory allocation failure.<br>
	 *  \retval CL_ERR_INUSE If the checkpoint is already in use.<br>
	 *  \par Description:<br>
	 *  This function deletes an existing checkpoint, identified by \e checkpointName from the<br>
	 *  cluster. <br>
	 *  \par<br>
	 *  After completion of the invocation,<br>
	 *  \arg The name \e checkpointName is no longer valid, that is, any invocation of a function<br>
	 *  of the Checkpoint Service that uses the checkpoint name returns an error,<br>
	 *  unless a checkpoint is re-created with this name. The checkpoint is re-created<br>
	 *  by specifying the same name of the checkpoint to be unlinked in an open call<br>
	 *  with the \c CL_CKPT_CHECKPOINT_CREATE flag set. This way, a new instance<br>
	 *  of the checkpoint is created, while the old instance of the checkpoint is<br>
	 *  not yet finally deleted. Note that this is similar to the way POSIX treats files.<br>
	 *  \arg If no process has the checkpoint open when clCkptCheckpointDelete() is<br>
	 *  invoked, the checkpoint is immediately deleted.<br>
	 *  \arg Any process that has the checkpoint open can still continue to access it. Deletion<br>
	 *  of the checkpoint will occur when the last clCkptCheckpointClose() operation is<br>
	 *  performed. <br>
	 *  \par<br>
	 *  The deletion of a checkpoint frees all resources allocated by the Checkpoint Service<br>
	 *  for it. This function can be invoked by any process, and the invoking process need not be the<br>
	 *  creator or opener of the checkpoint.<br>
	 *  \par Library File:<br>
	 *  ClCkpt<br>
	 *  \sa clCkptCheckpointOpen(), clCkptCheckpointOpenAsync(), clCkptCheckpointClose()<br>
	 * checkpoint svc handle<br>
	 * Original signature : <code>ClRcT clCkptCheckpointDelete(ClCkptSvcHdlT, const ClNameT*)</code><br>
	 * @param ckptHandle checkpoint svc handle<br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h:808</i>
	 */
	int clCkptCheckpointDelete(long ckptHandle, Pointer checkpointName);
	/**
	 * ***********************************<br>
	 *  \brief Sets the retention duration of a checkpoint.<br>
	 *  \par Header File:<br>
	 *  clCkptApi.h<br>
	 *  \param checkpointHandle The checkpoint whose retention time is being set. This handle<br>
	 *  is obtained by invoking clCkptCheckpointOpen() function.<br>
	 *  \param retentionDuration Duration for which the checkpoint can be retained in nanoseconds.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \par Description:<br>
	 *  This function is used to set the retention duration of a checkpoint.<br>
	 *  If by invocation of clCkptCheckpointClose(), the reference count becomes 0, and clCkptCheckpointDelete() has not been<br>
	 *  called, then the retention timer associated with the checkpoint ( and provided during invocation of<br>
	 *  clCkptCheckpointOpenAsync() or clCkptCheckpointOpen() functions ) is started. On expiration of the timer, the checkpoint<br>
	 *  is deleted.<br>
	 *  \par Library File:<br>
	 *  ClCkpt<br>
	 * Original signature : <code>ClRcT clCkptCheckpointRetentionDurationSet(ClCkptHdlT, ClTimeT)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h:835</i>
	 */
	int clCkptCheckpointRetentionDurationSet(long checkpointHandle, long retentionDuration);
	/**
	 * ***********************************<br>
	 *  \brief Sets the local replica to be active replica.<br>
	 *  \par Header File:<br>
	 *  clCkptApi.h<br>
	 *  \param checkpointHandle The handle \e checkpointHandle obtained by invoking<br>
	 *   clCkptCheckpointOpen() function.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_TRY_AGAIN System is in a transitory unstable state, please try later.<br>
	 *  \par Description:<br>
	 *  This function is used to set the local replica to be active replica<br>
	 *  if no active replica has been set for the checkpoint.<br>
	 *  \par Library File:<br>
	 *  ClCkpt<br>
	 * Original signature : <code>ClRcT clCkptActiveReplicaSet(ClCkptHdlT)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h:859</i>
	 */
	int clCkptActiveReplicaSet(long checkpointHandle);
	/**
	 * ***********************************<br>
	 *  \brief  Returns the status and the various attributes of the checkpoint.<br>
	 *  \par Header File:<br>
	 *  clCkptApi.ht<br>
	 *  \param checkpointHandle  The handle of the checkpoint obtained by invoking<br>
	 *   clCkptCheckpointOpen() function.<br>
	 *  \param checkpointStatus (out) Pointer to checkpoint descriptor in the address space of<br>
	 *   the invoking process, that contains the checkpoint status information to be returned.<br>
	 *   Refer to ClCkptCheckpointDescriptorT structure.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER  If the \e checkpointStatus parameter passed is a NULL pointer.<br>
	 *  \retval CL_ERR_NOT_INITIALIZED If the checkpoint server is not completely initialized.<br>
	 *  \retval CL_ERR_NO_MEMORY On memory allocation failure.<br>
	 *  \retval CL_ERR_TRY_AGAIN System is in a transitory unstable state, please try later.<br>
	 *  \par Description:<br>
	 *  This function is used to return the status and the various attributes of the checkpoint.<br>
	 *  The list of attributes are defined by the ClCkptCheckpointDescriptorT structure.<br>
	 *  This function retrieves the \e checkpointStatus of the checkpoint designated by<br>
	 *  checkpointHandle. <br>
	 *  \par<br>
	 *  If the checkpoint was created using either \c CL_CKPT_WR_ACTIVE_REPLICA or<br>
	 *  \c CL_CKPT_WR_ACTIVE_REPLICA_WEAK option, the checkpoint status is obtained<br>
	 *  from the active replica. If the checkpoint was created using the<br>
	 *  \c CL_CKPT_WR_ALL_REPLICAS option, the Checkpoint Service determines the replica<br>
	 *  from which to obtain the checkpoint status.<br>
	 *  \par Library File:<br>
	 *  ClCkpt<br>
	 * Original signature : <code>ClRcT clCkptCheckpointStatusGet(ClCkptHdlT, ClCkptCheckpointDescriptorT*)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h:897</i>
	 */
	int clCkptCheckpointStatusGet(long checkpointHandle, ClCkptCheckpointDescriptorT checkpointStatus);
	/**
	 * ***********************************<br>
	 *  \brief Creates a section in the checkpoint.<br>
	 *  \par Header File:<br>
	 *  clCkptApi.h<br>
	 *  \param checkpointHandle The handle \e checkpointHandle obtained by invoking<br>
	 *   clCkptCheckpointOpen() function.<br>
	 *  \param sectionCreationAttributes A pointer to a ClCkptSectionCreationAttributesT<br>
	 *  structure, that contains the (in/out) field \e sectionId and the (in) field \e expirationTime.<br>
	 *  \param initialData Pointer to the location in the address space of the invoking<br>
	 *  process that contains the initial data of the section to be created.<br>
	 *  \param initialDataSize The size in bytes of the initial data of the section to be created.<br>
	 *  Initial size can be at most \e maxSectionSize, as specified by the checkpoint creation<br>
	 *  attributes in clCkptCheckpointOpen().<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER  When either of the parameters \e sectionCreationAttributes<br>
	 *  or initialData passed are NULL pointers.<br>
	 *  \retval CL_ERR_NOT_INITIALIZED If the checkpoint server is not completely initialized.<br>
	 *  \retval CL_ERR_ALREADY_EXIST If the checkpoint is already existing.<br>
	 *  \retval CL_ERR_NO_MEMORY On memory allocation failure.<br>
	 *  \retval CL_ERR_TRY_AGAIN System is in a transitory unstable state, please try later.<br>
	 *  \par Description:<br>
	 *  This function creates a new section in the checkpoint referred to by checkpointHandle<br>
	 *  as long as the total number of existing sections is less than the maximum number of<br>
	 *  sections specified by the clCkptCheckpointOpen() or<br>
	 *  clCkptCheckpointOpenAsync() function call. Unlike a checkpoint, a section<br>
	 *  need not be opened for access. The section will be deleted by the Checkpoint Service<br>
	 *  when its expiration time is reached. <br>
	 *  \par<br>
	 *  If a checkpoint is created to have only one section,<br>
	 *  it is not necessary to create that section. The default section is identified by the<br>
	 *  special identifier \c CL_CKPT_DEFAULT_SECTION_ID. If the checkpoint was created<br>
	 *  with the \c CL_CKPT_WR_ALL_REPLICAS property, the section is created in all of the<br>
	 *  checkpoint replicas when the invocation returns; otherwise, the section has been created<br>
	 *  at least in the active checkpoint replica, when the invocation returns and will be<br>
	 *  created asynchronously in the other checkpoint replicas.<br>
	 *  \par Library File:<br>
	 *  ClCkpt<br>
	 *  \sa<br>
	 *  clCkptSectionDelete(),<br>
	 *  clCkptSectionExpirationTimeSet(),<br>
	 *  clCkptSectionIterationInitialize(),<br>
	 *  clCkptSectionIterationNext(),<br>
	 *  clCkptSectionIterationFinalize(),<br>
	 *  clCkptCheckpointWrite(),<br>
	 *  clCkptSectionOverwrite()<br>
	 * Original signature : <code>ClRcT clCkptSectionCreate(ClCkptHdlT, ClCkptSectionCreationAttributesT*, const ClUint8T*, ClSizeT)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h:957</i><br>
	 * @deprecated use the safer methods {@link #clCkptSectionCreate(long, clCkptApi.ClCkptSectionCreationAttributesT, java.nio.ByteBuffer, long)} and {@link #clCkptSectionCreate(long, clCkptApi.ClCkptSectionCreationAttributesT, com.sun.jna.Pointer, long)} instead
	 */
	@Deprecated 
	int clCkptSectionCreate(long checkpointHandle, ClCkptSectionCreationAttributesT sectionCreationAttributes, Pointer initialData, long initialDataSize);
	/**
	 * ***********************************<br>
	 *  \brief Creates a section in the checkpoint.<br>
	 *  \par Header File:<br>
	 *  clCkptApi.h<br>
	 *  \param checkpointHandle The handle \e checkpointHandle obtained by invoking<br>
	 *   clCkptCheckpointOpen() function.<br>
	 *  \param sectionCreationAttributes A pointer to a ClCkptSectionCreationAttributesT<br>
	 *  structure, that contains the (in/out) field \e sectionId and the (in) field \e expirationTime.<br>
	 *  \param initialData Pointer to the location in the address space of the invoking<br>
	 *  process that contains the initial data of the section to be created.<br>
	 *  \param initialDataSize The size in bytes of the initial data of the section to be created.<br>
	 *  Initial size can be at most \e maxSectionSize, as specified by the checkpoint creation<br>
	 *  attributes in clCkptCheckpointOpen().<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER  When either of the parameters \e sectionCreationAttributes<br>
	 *  or initialData passed are NULL pointers.<br>
	 *  \retval CL_ERR_NOT_INITIALIZED If the checkpoint server is not completely initialized.<br>
	 *  \retval CL_ERR_ALREADY_EXIST If the checkpoint is already existing.<br>
	 *  \retval CL_ERR_NO_MEMORY On memory allocation failure.<br>
	 *  \retval CL_ERR_TRY_AGAIN System is in a transitory unstable state, please try later.<br>
	 *  \par Description:<br>
	 *  This function creates a new section in the checkpoint referred to by checkpointHandle<br>
	 *  as long as the total number of existing sections is less than the maximum number of<br>
	 *  sections specified by the clCkptCheckpointOpen() or<br>
	 *  clCkptCheckpointOpenAsync() function call. Unlike a checkpoint, a section<br>
	 *  need not be opened for access. The section will be deleted by the Checkpoint Service<br>
	 *  when its expiration time is reached. <br>
	 *  \par<br>
	 *  If a checkpoint is created to have only one section,<br>
	 *  it is not necessary to create that section. The default section is identified by the<br>
	 *  special identifier \c CL_CKPT_DEFAULT_SECTION_ID. If the checkpoint was created<br>
	 *  with the \c CL_CKPT_WR_ALL_REPLICAS property, the section is created in all of the<br>
	 *  checkpoint replicas when the invocation returns; otherwise, the section has been created<br>
	 *  at least in the active checkpoint replica, when the invocation returns and will be<br>
	 *  created asynchronously in the other checkpoint replicas.<br>
	 *  \par Library File:<br>
	 *  ClCkpt<br>
	 *  \sa<br>
	 *  clCkptSectionDelete(),<br>
	 *  clCkptSectionExpirationTimeSet(),<br>
	 *  clCkptSectionIterationInitialize(),<br>
	 *  clCkptSectionIterationNext(),<br>
	 *  clCkptSectionIterationFinalize(),<br>
	 *  clCkptCheckpointWrite(),<br>
	 *  clCkptSectionOverwrite()<br>
	 * Original signature : <code>ClRcT clCkptSectionCreate(ClCkptHdlT, ClCkptSectionCreationAttributesT*, const ClUint8T*, ClSizeT)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h:957</i>
	 */
	int clCkptSectionCreate(long checkpointHandle, ClCkptSectionCreationAttributesT sectionCreationAttributes, ByteBuffer initialData, long initialDataSize);
	/**
	 * ***********************************<br>
	 *  \brief  Deletes a section in the given checkpoint.<br>
	 *  \par Header File:<br>
	 *  clCkptApi.ht<br>
	 *  \param checkpointHandle  The handle to the checkpoint holding the section<br>
	 *   to be deleted. The handle to the checkpoint holding the section to<br>
	 *   be deleted. The handle \e checkpointHandle obtained by invoking<br>
	 *   clCkptCheckpointOpen() function.<br>
	 *  \param sectionId A pointer to the identifier of the section to be deleted.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER  When the parameter \e sectionId passed is a NULL pointer.<br>
	 *  \retval CL_ERR_NOT_INITIALIZED If the checkpoint server is not completely initialized.<br>
	 *  \retval CL_ERR_NO_MEMORY On memory allocation failure.<br>
	 *  \retval CL_ERR_TRY_AGAIN System is in a transitory unstable state, please try later.<br>
	 *  \par Description:<br>
	 *  This function deletes a section in the checkpoint referred to by \e checkpointHandle. If<br>
	 *  the checkpoint was created with the \c CL_CKPT_WR_ALL_REPLICAS property, the<br>
	 *  section has been deleted in all of the checkpoint replicas when the invocation returns;<br>
	 *  otherwise, the section has been deleted at least in the active checkpoint replica when<br>
	 *  the invocation returns. The default section, identified by<br>
	 *  \c CL_CKPT_DEFAULT_SECTION_ID, cannot be deleted by invoking the<br>
	 *  clCkptSectionDelete() function.<br>
	 *  \par Library File:<br>
	 *  ClCkpt<br>
	 *  \sa<br>
	 *   clCkptSectionCreate(),<br>
	 *   clCkptSectionExpirationTimeSet(),<br>
	 *   clCkptSectionIterationInitialize(),<br>
	 *   clCkptSectionIterationNext(),<br>
	 *   clCkptSectionIterationFinalize(),<br>
	 *   clCkptCheckpointWrite(),<br>
	 *   clCkptSectionOverwrite()<br>
	 * Original signature : <code>ClRcT clCkptSectionDelete(ClCkptHdlT, const ClCkptSectionIdT*)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h:1003</i>
	 */
	int clCkptSectionDelete(long checkpointHandle, ClCkptSectionIdT sectionId);
	/**
	 * ***********************************<br>
	 *  \brief Sets the expiration time of a section.<br>
	 *  \par Header File:<br>
	 *  clCkptApi.h<br>
	 *  \param checkpointHandle The handle \e checkpointHandle obtained by invoking<br>
	 *   clCkptCheckpointOpen() function.<br>
	 *  \param sectionId Section identifier.<br>
	 *  \param expirationTime Expiration time of the section.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_TRY_AGAIN System is in a transitory unstable state, please try later.<br>
	 *  \par Description:<br>
	 *  This function is used to set the expiration time of a section.<br>
	 *  \par Library File:<br>
	 *  ClCkpt<br>
	 *  \sa<br>
	 *   clCkptSectionCreate(),<br>
	 *   clCkptSectionDelete(),<br>
	 *   clCkptSectionIterationInitialize(),<br>
	 *   clCkptSectionIterationNext(),<br>
	 *   clCkptSectionIterationFinalize(),<br>
	 *   clCkptCheckpointWrite(),<br>
	 *   clCkptSectionOverwrite()<br>
	 * Original signature : <code>ClRcT clCkptSectionExpirationTimeSet(ClCkptHdlT, const ClCkptSectionIdT*, ClTimeT)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h:1037</i>
	 */
	int clCkptSectionExpirationTimeSet(long checkpointHandle, ClCkptSectionIdT sectionId, long expirationTime);
	/**
	 * ***********************************<br>
	 *  \brief Enables the application to iterate through sections in a checkpoint.<br>
	 *  \par Header File:<br>
	 *  clCkptApi.h<br>
	 *  \param checkpointHandle  The handle \e checkpointHandle obtained by invoking<br>
	 *   clCkptCheckpointOpen() function.<br>
	 *  \param sectionsChosen Rule for the iteration.<br>
	 *   Refer the ClCkptSectionChosenT enum.<br>
	 *  \param expirationTime Expiration time used along with the rule.<br>
	 *  \param sectionIterationHandle (out) Handle used to identify a present section.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_TRY_AGAIN System is in a transitory unstable state, please try later.<br>
	 *  \par Description:<br>
	 *   This function is used to enable the application to iterate through the sections in a checkpoint.<br>
	 * *<br>
	 *  \par Library File:<br>
	 *  ClCkpt<br>
	 *  \sa<br>
	 *  clCkptSectionCreate(),<br>
	 *  clCkptSectionDelete(),<br>
	 *  clCkptSectionExpirationTimeSet(),<br>
	 *  clCkptSectionIterationNext(),<br>
	 *  clCkptSectionIterationFinalize(),<br>
	 *  clCkptCheckpointWrite(),<br>
	 *  clCkptSectionOverwrite()<br>
	 * Original signature : <code>ClRcT clCkptSectionIterationInitialize(ClCkptHdlT, ClCkptSectionsChosenT, ClTimeT, ClHandleT*)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h:1074</i><br>
	 * @deprecated use the safer methods {@link #clCkptSectionIterationInitialize(long, int, long, java.nio.LongBuffer)} and {@link #clCkptSectionIterationInitialize(long, int, long, com.sun.jna.ptr.LongByReference)} instead
	 */
	@Deprecated 
	int clCkptSectionIterationInitialize(long checkpointHandle, int sectionsChosen, long expirationTime, LongByReference sectionIterationHandle);
	/**
	 * ***********************************<br>
	 *  \brief Enables the application to iterate through sections in a checkpoint.<br>
	 *  \par Header File:<br>
	 *  clCkptApi.h<br>
	 *  \param checkpointHandle  The handle \e checkpointHandle obtained by invoking<br>
	 *   clCkptCheckpointOpen() function.<br>
	 *  \param sectionsChosen Rule for the iteration.<br>
	 *   Refer the ClCkptSectionChosenT enum.<br>
	 *  \param expirationTime Expiration time used along with the rule.<br>
	 *  \param sectionIterationHandle (out) Handle used to identify a present section.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_TRY_AGAIN System is in a transitory unstable state, please try later.<br>
	 *  \par Description:<br>
	 *   This function is used to enable the application to iterate through the sections in a checkpoint.<br>
	 * *<br>
	 *  \par Library File:<br>
	 *  ClCkpt<br>
	 *  \sa<br>
	 *  clCkptSectionCreate(),<br>
	 *  clCkptSectionDelete(),<br>
	 *  clCkptSectionExpirationTimeSet(),<br>
	 *  clCkptSectionIterationNext(),<br>
	 *  clCkptSectionIterationFinalize(),<br>
	 *  clCkptCheckpointWrite(),<br>
	 *  clCkptSectionOverwrite()<br>
	 * Original signature : <code>ClRcT clCkptSectionIterationInitialize(ClCkptHdlT, ClCkptSectionsChosenT, ClTimeT, ClHandleT*)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h:1074</i>
	 */
	int clCkptSectionIterationInitialize(long checkpointHandle, int sectionsChosen, long expirationTime, LongBuffer sectionIterationHandle);
	/**
	 * ***********************************<br>
	 *  \brief  Returns the next section in the list of sections.<br>
	 *  \par Header File:<br>
	 *  clCkptApi.h<br>
	 *  \param sectionIterationHandle Checkpoint handle returned as part of clCkptCheckpointOpen().<br>
	 *  \param sectionDescriptor (out) Pointer to the descriptor of a section.<br>
	 *   Refer the ClCkptSectionDescriptorT structure.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_TRY_AGAIN System is in a transitory unstable state, please try later.<br>
	 *  \par Description:<br>
	 *  This function is used to retrieve the next section in the list of sections matching the<br>
	 *  clCkptSectionIterationInitialize() call.<br>
	 *  \par Library File:<br>
	 *  ClCkpt<br>
	 *  \sa<br>
	 *  clCkptSectionCreate(),<br>
	 *  clCkptSectionDelete(),<br>
	 *  clCkptSectionExpirationTimeSet(),<br>
	 *  clCkptSectionIterationInitialize(),<br>
	 *  clCkptSectionIterationFinalize(),<br>
	 *  clCkptCheckpointWrite(),<br>
	 *  clCkptSectionOverwrite<br>
	 * Original signature : <code>ClRcT clCkptSectionIterationNext(ClHandleT, ClCkptSectionDescriptorT*)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h:1110</i>
	 */
	int clCkptSectionIterationNext(long sectionIterationHandle, ClCkptSectionDescriptorT sectionDescriptor);
	/**
	 * ***********************************<br>
	 *  \brief Frees resources associated with the iteration.<br>
	 *  \par Header File:<br>
	 *  clCkptApi.h<br>
	 *  \param sectionIterationHandle Handle of the iteration.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \par Description:<br>
	 *  This function is used to free resources associated with the iteration <br>
	 *  identified by the sectionIterationHandle.<br>
	 *  \par Library File:<br>
	 *  ClCkpt<br>
	 *  \sa<br>
	 *  clCkptSectionCreate(),<br>
	 *  clCkptSectionDelete(),<br>
	 *  clCkptSectionExpirationTimeSet(),<br>
	 *  clCkptSectionIterationInitialize(),<br>
	 *  clCkptSectionIterationNext(),<br>
	 *  clCkptCheckpointWrite(),<br>
	 *  clCkptSectionOverwrite()<br>
	 * Original signature : <code>ClRcT clCkptSectionIterationFinalize(ClHandleT)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h:1141</i>
	 */
	int clCkptSectionIterationFinalize(long sectionIterationHandle);
	/**
	 * ***********************************<br>
	 *  \brief  Writes multiple sections on to a given checkpoint.<br>
	 *  \par Header File:<br>
	 *  clCkptApi.h<br>
	 *  \param checkpointHandle The handle to the checkpoint that is to be written to.<br>
	 *  The handle \e checkpointHandle obtained by invoking either<br>
	 *  clCkptCheckpointOpen() or clCkptCheckpointOpenAsync() function.<br>
	 *  \param ioVector Pointer to the IO Vector containing the section IDs and the data to be written.<br>
	 *  \param numberOfElements Total number of elements in \e ioVector.<br>
	 *  \param erroneousVectorIndex (out) A pointer to an index, stored in the caller's address<br>
	 *  space, of the first iovector element that makes the invocation fail. If the index is set to<br>
	 *  NULL or if the invocation succeeds, the field remains unchanged.<br>
	 *  Updated if the clCkptCheckpointWrite() call fails.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER  When the parameters passed are NULL pointers.<br>
	 *  \retval CL_ERR_NOT_INITIALIZED If the checkpoint server is not completely initialized.<br>
	 *  \retval CL_ERR_NO_MEMORY On memory allocation failure.<br>
	 *  \par Description:<br>
	 *  This function writes data from the memory regions specified by \e ioVector into a checkpoint:<br>
	 *  \arg If this checkpoint is created with the \c CL_CKPT_WR_ALL_REPLICAS<br>
	 *  property, all of the checkpoint replicas gets updated when the invocation<br>
	 *  returns. If the invocation does not complete or returns with an error, nothing<br>
	 *  is written at all.<br>
	 *  \arg If the checkpoint is created with the<br>
	 *  \c CL_CKPT_WR_ACTIVE_REPLICA property, the active checkpoint replica<br>
	 *  gets updated when the invocation returns. Other checkpoint replicas are<br>
	 *  updated asynchronously. If the invocation does not complete or returns with<br>
	 *  an error, nothing is written.<br>
	 *  \arg If the checkpoint is created with the<br>
	 *  \c CL_CKPT_WR_ACTIVE_REPLICA_WEAK property, the active checkpoint<br>
	 *  replica gets updated when the invocation returns. Other checkpoint replicas<br>
	 *  are updated asynchronously. If the invocation returns with an error, nothing<br>
	 *  is written at all. However, if the invocation does not complete, the<br>
	 *  operation may be partially completed and some sections may be corrupted in<br>
	 *  the active checkpoint replica.<br>
	 *  \par<br>
	 *  In a single invocation, several sections and several portions of sections can be<br>
	 *  updated simultaneously. The elements of the \e ioVectors are written in order from<br>
	 *  \e ioVector[0] to \e ioVector [numberOfElements - 1]. As a result of this invocation, some<br>
	 *  sections may grow.<br>
	 *  \par Library File:<br>
	 *  ClCkpt<br>
	 *  \sa<br>
	 *  clCkptSectionCreate(),<br>
	 *  clCkptSectionDelete(),<br>
	 *  clCkptSectionExpirationTimeSet(),<br>
	 *  clCkptSectionIterationInitialize(),<br>
	 *  clCkptSectionIterationNext(),<br>
	 *  clCkptSectionIterationFinalize(),<br>
	 *  clCkptSectionOverwrite()<br>
	 * Original signature : <code>ClRcT clCkptCheckpointWrite(ClCkptHdlT, const ClCkptIOVectorElementT*, ClUint32T, ClUint32T*)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h:1203</i><br>
	 * @deprecated use the safer methods {@link #clCkptCheckpointWrite(long, clCkptApi.ClCkptIOVectorElementT, int, java.nio.IntBuffer)} and {@link #clCkptCheckpointWrite(long, clCkptApi.ClCkptIOVectorElementT, int, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	int clCkptCheckpointWrite(long checkpointHandle, ClCkptIOVectorElementT ioVector, int numberOfElements, IntByReference erroneousVectorIndex);
	/**
	 * ***********************************<br>
	 *  \brief  Writes multiple sections on to a given checkpoint.<br>
	 *  \par Header File:<br>
	 *  clCkptApi.h<br>
	 *  \param checkpointHandle The handle to the checkpoint that is to be written to.<br>
	 *  The handle \e checkpointHandle obtained by invoking either<br>
	 *  clCkptCheckpointOpen() or clCkptCheckpointOpenAsync() function.<br>
	 *  \param ioVector Pointer to the IO Vector containing the section IDs and the data to be written.<br>
	 *  \param numberOfElements Total number of elements in \e ioVector.<br>
	 *  \param erroneousVectorIndex (out) A pointer to an index, stored in the caller's address<br>
	 *  space, of the first iovector element that makes the invocation fail. If the index is set to<br>
	 *  NULL or if the invocation succeeds, the field remains unchanged.<br>
	 *  Updated if the clCkptCheckpointWrite() call fails.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER  When the parameters passed are NULL pointers.<br>
	 *  \retval CL_ERR_NOT_INITIALIZED If the checkpoint server is not completely initialized.<br>
	 *  \retval CL_ERR_NO_MEMORY On memory allocation failure.<br>
	 *  \par Description:<br>
	 *  This function writes data from the memory regions specified by \e ioVector into a checkpoint:<br>
	 *  \arg If this checkpoint is created with the \c CL_CKPT_WR_ALL_REPLICAS<br>
	 *  property, all of the checkpoint replicas gets updated when the invocation<br>
	 *  returns. If the invocation does not complete or returns with an error, nothing<br>
	 *  is written at all.<br>
	 *  \arg If the checkpoint is created with the<br>
	 *  \c CL_CKPT_WR_ACTIVE_REPLICA property, the active checkpoint replica<br>
	 *  gets updated when the invocation returns. Other checkpoint replicas are<br>
	 *  updated asynchronously. If the invocation does not complete or returns with<br>
	 *  an error, nothing is written.<br>
	 *  \arg If the checkpoint is created with the<br>
	 *  \c CL_CKPT_WR_ACTIVE_REPLICA_WEAK property, the active checkpoint<br>
	 *  replica gets updated when the invocation returns. Other checkpoint replicas<br>
	 *  are updated asynchronously. If the invocation returns with an error, nothing<br>
	 *  is written at all. However, if the invocation does not complete, the<br>
	 *  operation may be partially completed and some sections may be corrupted in<br>
	 *  the active checkpoint replica.<br>
	 *  \par<br>
	 *  In a single invocation, several sections and several portions of sections can be<br>
	 *  updated simultaneously. The elements of the \e ioVectors are written in order from<br>
	 *  \e ioVector[0] to \e ioVector [numberOfElements - 1]. As a result of this invocation, some<br>
	 *  sections may grow.<br>
	 *  \par Library File:<br>
	 *  ClCkpt<br>
	 *  \sa<br>
	 *  clCkptSectionCreate(),<br>
	 *  clCkptSectionDelete(),<br>
	 *  clCkptSectionExpirationTimeSet(),<br>
	 *  clCkptSectionIterationInitialize(),<br>
	 *  clCkptSectionIterationNext(),<br>
	 *  clCkptSectionIterationFinalize(),<br>
	 *  clCkptSectionOverwrite()<br>
	 * Original signature : <code>ClRcT clCkptCheckpointWrite(ClCkptHdlT, const ClCkptIOVectorElementT*, ClUint32T, ClUint32T*)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h:1203</i>
	 */
	int clCkptCheckpointWrite(long checkpointHandle, ClCkptIOVectorElementT ioVector, int numberOfElements, IntBuffer erroneousVectorIndex);
	/**
	 * ***********************************<br>
	 *  \brief  Writes a single section in a given checkpoint.<br>
	 *  \par Header File:<br>
	 *  clCkptApi.h<br>
	 *  \param checkpointHandle The handle that designates the checkpoint that is written to.<br>
	 *  The handle \e checkpointHandle is obtained by invoking either<br>
	 *  clCkptCheckpointOpen() or clCkptCheckpointOpenAsync() functions.<br>
	 *  \param sectionId A pointer to an identifier for the section that is to be overwritten.<br>
	 *   If this pointer points to \c CL_CKPT_DEFAULT_SECTION_ID, the default section is updated.<br>
	 *  \param dataBuffer Pointer to the buffer from where the data is being copied.<br>
	 *  \param dataSize The size in bytes of the data to be written, which becomes<br>
	 *   the new size for this section.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER  When the parameters \e sectionId and \e dataBuffer<br>
	 *  passed are NULL pointers.<br>
	 *  \retval CL_ERR_NOT_INITIALIZED If the checkpoint server is not completely initialized.<br>
	 *  \retval CL_ERR_NO_MEMORY On memory allocation failure.<br>
	 *  \retval CL_ERR_TRY_AGAIN System is in a transitory unstable state, please try later.<br>
	 *  \par Description:<br>
	 *  This function is used to write a single section in a given checkpoint.<br>
	 *  This function is similar to clCkptCheckpointWrite() except that it overwrites only a<br>
	 *  single section. As a result of this invocation, the previous data and size of the section<br>
	 *  will change. This function may be invoked, even if there was no prior invocation of<br>
	 *  clCkptCheckpointWrite().<br>
	 *  \par Library File:<br>
	 *  ClCkpt<br>
	 *  \sa<br>
	 *  clCkptSectionCreate(),<br>
	 *  clCkptSectionDelete(),<br>
	 *  clCkptSectionExpirationTimeSet(),<br>
	 *  clCkptSectionIterationInitialize(),<br>
	 *  clCkptSectionIterationNext(),<br>
	 *  clCkptSectionIterationFinalize(),<br>
	 *  clCkptCheckpointWrite()<br>
	 * Original signature : <code>ClRcT clCkptSectionOverwrite(ClCkptHdlT, const ClCkptSectionIdT*, const void*, ClSizeT)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h:1251</i>
	 */
	int clCkptSectionOverwrite(long checkpointHandle, ClCkptSectionIdT sectionId, Pointer dataBuffer, long dataSize);
	/**
	 * ***********************************<br>
	 *  \brief Reads multiple sections at a time.<br>
	 *  \par Header File:<br>
	 *  clCkptApi.h<br>
	 *  \param checkpointHandle The handle to the checkpoint that is to be read. The handle<br>
	 *  \e checkpointHandle obtained by invoking either<br>
	 *  clCkptCheckpointOpen() or clCkptCheckpointOpenCallback() function.<br>
	 *  \param ioVector Pointer to an IO Vector containing the section IDs and the data to be written.<br>
	 *  \param numberOfElements  Total number of elements in \e ioVector.<br>
	 *  Each element is of the type<br>
	 *  ClCkptIOVectorElementT, and containing the following fields:<br>
	 *  \arg sectionId: The identifier of the section to be read from.<br>
	 *  \arg dataBuffer: (in/out)  A pointer to a buffer containing the data to be read to. If<br>
	 *  \e dataBuffer is NULL, the value of \e datasize provided by the invoker is ignored<br>
	 *  and the buffer is provided by the Checkpoint Service library. The buffer must<br>
	 *  be deallocated by the invoker.<br>
	 *  \arg dataSize: Size of the data to be read to the buffer designated by<br>
	 *  \e dataBuffer. The size is at most \e maxSectionSize, as specified in the creation<br>
	 *  attributes of the checkpoint.<br>
	 *  \arg dataOffset: Offset in the section that marks the start of the data that is to<br>
	 *  be read.<br>
	 *  \arg readSize: (out) Used by clCkptCheckpointRead() to record the number of<br>
	 *  bytes of data that have been read; otherwise, this field is not used.<br>
	 *  \param erroneousVectorIndex (out) Pointer to the index for errors in \e ioVector.<br>
	 *  This is an index in the caller's address space, of<br>
	 *  the first vector element that causes the invocation to fail. If the invocation succeeds,<br>
	 *  then \e erroneousVectorIndex is \c NULL and should be ignored.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER  When the parameters passed are NULL pointers.<br>
	 *  \retval CL_ERR_NOT_INITIALIZED If the checkpoint server is not completely initialized.<br>
	 *  \retval CL_ERR_NO_MEMORY On memory allocation failure.<br>
	 *  \retval CL_ERR_TRY_AGAIN System is in a transitory unstable state, please try later.<br>
	 *  \par Description:<br>
	 *  This function is used to read multiple sections at a time. It can be used to <br>
	 *  read a single section.<br>
	 *  \par Library File:<br>
	 *  ClCkpt<br>
	 * Original signature : <code>ClRcT clCkptCheckpointRead(ClCkptHdlT, ClCkptIOVectorElementT*, ClUint32T, ClUint32T*)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h:1304</i><br>
	 * @deprecated use the safer methods {@link #clCkptCheckpointRead(long, clCkptApi.ClCkptIOVectorElementT, int, java.nio.IntBuffer)} and {@link #clCkptCheckpointRead(long, clCkptApi.ClCkptIOVectorElementT, int, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	int clCkptCheckpointRead(long checkpointHandle, ClCkptIOVectorElementT ioVector, int numberOfElements, IntByReference erroneousVectorIndex);
	/**
	 * ***********************************<br>
	 *  \brief Reads multiple sections at a time.<br>
	 *  \par Header File:<br>
	 *  clCkptApi.h<br>
	 *  \param checkpointHandle The handle to the checkpoint that is to be read. The handle<br>
	 *  \e checkpointHandle obtained by invoking either<br>
	 *  clCkptCheckpointOpen() or clCkptCheckpointOpenCallback() function.<br>
	 *  \param ioVector Pointer to an IO Vector containing the section IDs and the data to be written.<br>
	 *  \param numberOfElements  Total number of elements in \e ioVector.<br>
	 *  Each element is of the type<br>
	 *  ClCkptIOVectorElementT, and containing the following fields:<br>
	 *  \arg sectionId: The identifier of the section to be read from.<br>
	 *  \arg dataBuffer: (in/out)  A pointer to a buffer containing the data to be read to. If<br>
	 *  \e dataBuffer is NULL, the value of \e datasize provided by the invoker is ignored<br>
	 *  and the buffer is provided by the Checkpoint Service library. The buffer must<br>
	 *  be deallocated by the invoker.<br>
	 *  \arg dataSize: Size of the data to be read to the buffer designated by<br>
	 *  \e dataBuffer. The size is at most \e maxSectionSize, as specified in the creation<br>
	 *  attributes of the checkpoint.<br>
	 *  \arg dataOffset: Offset in the section that marks the start of the data that is to<br>
	 *  be read.<br>
	 *  \arg readSize: (out) Used by clCkptCheckpointRead() to record the number of<br>
	 *  bytes of data that have been read; otherwise, this field is not used.<br>
	 *  \param erroneousVectorIndex (out) Pointer to the index for errors in \e ioVector.<br>
	 *  This is an index in the caller's address space, of<br>
	 *  the first vector element that causes the invocation to fail. If the invocation succeeds,<br>
	 *  then \e erroneousVectorIndex is \c NULL and should be ignored.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER  When the parameters passed are NULL pointers.<br>
	 *  \retval CL_ERR_NOT_INITIALIZED If the checkpoint server is not completely initialized.<br>
	 *  \retval CL_ERR_NO_MEMORY On memory allocation failure.<br>
	 *  \retval CL_ERR_TRY_AGAIN System is in a transitory unstable state, please try later.<br>
	 *  \par Description:<br>
	 *  This function is used to read multiple sections at a time. It can be used to <br>
	 *  read a single section.<br>
	 *  \par Library File:<br>
	 *  ClCkpt<br>
	 * Original signature : <code>ClRcT clCkptCheckpointRead(ClCkptHdlT, ClCkptIOVectorElementT*, ClUint32T, ClUint32T*)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h:1304</i>
	 */
	int clCkptCheckpointRead(long checkpointHandle, ClCkptIOVectorElementT ioVector, int numberOfElements, IntBuffer erroneousVectorIndex);
	/**
	 * ***********************************<br>
	 *  \brief Synchronizes the replicas of a checkpoint.<br>
	 *  \par Header File:<br>
	 *  clCkptApi.h<br>
	 *  \param checkpointHandle Checkpoint handle returned as part of clCkptCheckpointOpen.<br>
	 *  \param  timeout Time-out to execute the operation.[It is not supported currently]<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_TRY_AGAIN System is in a transitory unstable state, please try later.<br>
	 *  \par Description:<br>
	 *  This function is used to synchronize the replicas of a checkpoint.<br>
	 *  \par Library File:<br>
	 *  ClCkpt<br>
	 *  \sa clCkptCheckpointSynchronizeAsync()<br>
	 * Original signature : <code>ClRcT clCkptCheckpointSynchronize(ClCkptHdlT, ClTimeT)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h:1331</i>
	 */
	int clCkptCheckpointSynchronize(long ckeckpointHandle, long timeout);
	/**
	 * ***********************************<br>
	 *  \brief Synchronizes the replicas of a Checkpoint asynchronously.<br>
	 *  \par Header File:<br>
	 *  clCkptApi.h<br>
	 *  \param checkpointHandle Checkpoint handle returned as part of clCkptCheckpointOpen().<br>
	 *  \param invocation Identifies the call when the callback is called.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \par Description:<br>
	 *  This function is used to synchronize the replicas of a Checkpoint asynchronously.<br>
	 *  \par Library File:<br>
	 *  ClCkpt<br>
	 *  \sa clCkptCheckpointSynchronize()<br>
	 * Original signature : <code>ClRcT clCkptCheckpointSynchronizeAsync(ClCkptHdlT, ClInvocationT)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h:1354</i>
	 */
	int clCkptCheckpointSynchronizeAsync(long checkpointHandle, long invocation);
	/**
	 * ***********************************<br>
	 *  \brief Registers a callback function to be called to notify change in the checkpoint data.<br>
	 *  \par Header File:<br>
	 *  clCkptApi.h<br>
	 *  \param checkpointHandle Checkpoint handle returned as part of clCkptCheckpointOpen().<br>
	 *  \param <br>
	 *  \param invocation Identifies the call when the callback is called.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \par Description:<br>
	 *  This function is used to register a callback function that is called.<br>
	 *  whenever the specified checkpoint data is updated.<br>
	 *  \par Library File:<br>
	 *  ClCkpt<br>
	 * Original signature : <code>ClRcT clCkptImmediateConsumptionRegister(ClCkptHdlT, ClCkptNotificationCallbackT, ClPtrT)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h:1377</i>
	 */
	int clCkptImmediateConsumptionRegister(long checkpointHandle, ClCkptLibrary.ClCkptNotificationCallbackT callback, Pointer pCookie);
	/**
	 * ***********************************<br>
	 *  \brief  Helps detect pending callbacks.<br>
	 *  \par Header File:<br>
	 *  clCkptApi.h<br>
	 *  \param ckptHandle The handle, obtained through the clCkptInitialize()<br>
	 *   function, designating this particular initialization of the Ckpt Service.<br>
	 *  \param pSelectionObject (out) A pointer to the operating system handle that<br>
	 *  the invoking EO can use to detect pending callbacks.<br>
	 *  \retval CL_OK The function completed successfully.<br>
	 *  \retval CL_ERR_NOT_INITIALIZED On initialization failure.<br>
	 *  \retval CL_ERR_INVALID_HANDLE On passing an invalid handle.<br>
	 *  \retval CL_ERR_INVALID_PARAMETER On passing an invalid parameter.<br>
	 *  \par Description:<br>
	 *  This function returns the operating system handle, \e pSelectionObject,<br>
	 *  associated with the handle \e ckptHandle. The invoking EO can use<br>
	 *  this handle to detect pending callbacks, instead of repeatedly<br>
	 *  invoking clCkptDispatch() for this purpose.<br>
	 *  \par<br>
	 *  The \e pSelectionObject returned by this function, is a file descriptor<br>
	 *  that can be used with poll() or select() systems call detect incoming<br>
	 *  callbacks. <br>
	 *  \par<br>
	 *  The \e selectionObject returned by this function is valid until<br>
	 *  clCkptFinalize() is invoked on the same handle \e ckptHandle.<br>
	 *  \par Library File:<br>
	 *   ClCkpt<br>
	 *  \sa clCkptDispatch()<br>
	 * Original signature : <code>ClRcT clCkptSelectionObjectGet(ClCkptSvcHdlT, ClSelectionObjectT*)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h:1419</i><br>
	 * @deprecated use the safer methods {@link #clCkptSelectionObjectGet(long, java.nio.LongBuffer)} and {@link #clCkptSelectionObjectGet(long, com.sun.jna.ptr.LongByReference)} instead
	 */
	@Deprecated 
	int clCkptSelectionObjectGet(long ckptHandle, LongByReference selectionObject);
	/**
	 * ***********************************<br>
	 *  \brief  Helps detect pending callbacks.<br>
	 *  \par Header File:<br>
	 *  clCkptApi.h<br>
	 *  \param ckptHandle The handle, obtained through the clCkptInitialize()<br>
	 *   function, designating this particular initialization of the Ckpt Service.<br>
	 *  \param pSelectionObject (out) A pointer to the operating system handle that<br>
	 *  the invoking EO can use to detect pending callbacks.<br>
	 *  \retval CL_OK The function completed successfully.<br>
	 *  \retval CL_ERR_NOT_INITIALIZED On initialization failure.<br>
	 *  \retval CL_ERR_INVALID_HANDLE On passing an invalid handle.<br>
	 *  \retval CL_ERR_INVALID_PARAMETER On passing an invalid parameter.<br>
	 *  \par Description:<br>
	 *  This function returns the operating system handle, \e pSelectionObject,<br>
	 *  associated with the handle \e ckptHandle. The invoking EO can use<br>
	 *  this handle to detect pending callbacks, instead of repeatedly<br>
	 *  invoking clCkptDispatch() for this purpose.<br>
	 *  \par<br>
	 *  The \e pSelectionObject returned by this function, is a file descriptor<br>
	 *  that can be used with poll() or select() systems call detect incoming<br>
	 *  callbacks. <br>
	 *  \par<br>
	 *  The \e selectionObject returned by this function is valid until<br>
	 *  clCkptFinalize() is invoked on the same handle \e ckptHandle.<br>
	 *  \par Library File:<br>
	 *   ClCkpt<br>
	 *  \sa clCkptDispatch()<br>
	 * Original signature : <code>ClRcT clCkptSelectionObjectGet(ClCkptSvcHdlT, ClSelectionObjectT*)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h:1419</i>
	 */
	int clCkptSelectionObjectGet(long ckptHandle, LongBuffer selectionObject);
	/**
	 * ***********************************<br>
	 *  \brief Invokes the pending callback in context of the EO.<br>
	 *  \par Header File:<br>
	 *  clCkptApi.h<br>
	 *  \param ckptHandle The handle, obtained through the clCkptInitialize()<br>
	 *   function, designating this particular initialization of the Ckpt Service.<br>
	 *  \param dispatchFlags Flags that specify the callback execution behavior<br>
	 *  clCkptDispatch() function, which have the values \c CL_DISPATCH_ONE,<br>
	 *  \c CL_DISPATCH_ALL or \c CL_DISPATCH_BLOCKING, as defined in clCommon.h.<br>
	 *  \retval CL_OK The function completed successfully.<br>
	 *  \retval CL_ERR_NOT_INITIALIZED On initialization failure.<br>
	 *  \retval CL_ERR_INVALID_HANDLE On passing an invalid handle.<br>
	 *  \retval CL_ERR_INVALID_PARAMETER On passing an invalid parameter.<br>
	 *  \par Description:<br>
	 *  This function invokes, in the context of the calling EO, pending callbacks for<br>
	 *  handle \e ckptHandle in a way that is specified by the \e dispatchFlags<br>
	 *  parameter.<br>
	 *  \par Library File:<br>
	 *   ClCkpt<br>
	 *  \sa clCkptSelectionObjectGet()<br>
	 * Original signature : <code>ClRcT clCkptDispatch(ClCkptSvcHdlT, ClDispatchFlagsT)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/ckpt/include/clCkptApi.h:1453</i>
	 */
	int clCkptDispatch(long ckptHandle, int dispatchFlags);
	/*public static class ClCkptNotificationCallbackT extends PointerType {
		public ClCkptNotificationCallbackT(Pointer address) {
			super(address);
		}
		public ClCkptNotificationCallbackT() {
			super();
		}
	};*/
}
