package clLogApi;
import clLogApi.ClLogFilterT.ByValue;
import com.sun.jna.Callback;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.Pointer;
import com.sun.jna.PointerType;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.LongByReference;
import com.sun.jna.ptr.PointerByReference;
import com.sun.jna.ptr.ShortByReference;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import java.nio.LongBuffer;
import java.nio.ShortBuffer;
import clUtils.ClUtilsLibrary;
/**
 * JNA Wrapper for library <b>ClLogClient</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface ClLogClientLibrary extends Library {
	public static final String JNA_LIBRARY_NAME = "ClLogClient";
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(ClLogClientLibrary.JNA_LIBRARY_NAME);
	public static final ClLogClientLibrary INSTANCE = (ClLogClientLibrary)Native.load(ClLogClientLibrary.JNA_LIBRARY_NAME, ClLogClientLibrary.class);
	/**
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h</i><br>
	 * enum values
	 */
	public static interface ClLogStreamScopeT {
		/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:88</i> */
		public static final int CL_LOG_STREAM_GLOBAL = 0;
		/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:92</i> */
		public static final int CL_LOG_STREAM_LOCAL = 1;
	};
	
	public static interface ClLogStreamOpenFlagsT {		
		public static final int CL_LOG_STREAM_CREATE = 1;		
	};
	/**
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h</i><br>
	 * enum values
	 */
	public static interface ClLogFileFullActionT {
		/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:108</i> */
		public static final int CL_LOG_FILE_FULL_ACTION_ROTATE = 0;
		/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:113</i> */
		public static final int CL_LOG_FILE_FULL_ACTION_WRAP = 1;
		/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:117</i> */
		public static final int CL_LOG_FILE_FULL_ACTION_HALT = 2;
	};
	/**
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h</i><br>
	 * enum values
	 */
	public static interface ClLogSeverityT {
		/**
		 * setting severity as EMERGENCY.<br>
		 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:253</i>
		 */
		public static final int CL_LOG_SEV_EMERGENCY = 0x1;
		/**
		 * setting severity as ALERT.<br>
		 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:257</i>
		 */
		public static final int CL_LOG_SEV_ALERT = (0x1 + 1);
		/**
		 * setting severity as CRITICAL.<br>
		 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:261</i>
		 */
		public static final int CL_LOG_SEV_CRITICAL = (0x1 + 2);
		/**
		 * setting severity as ERROR.<br>
		 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:265</i>
		 */
		public static final int CL_LOG_SEV_ERROR = (0x1 + 3);
		/**
		 * setting severity as WARNING.<br>
		 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:269</i>
		 */
		public static final int CL_LOG_SEV_WARNING = (0x1 + 4);
		/**
		 * setting severity as NOTICE.<br>
		 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:273</i>
		 */
		public static final int CL_LOG_SEV_NOTICE = (0x1 + 5);
		/**
		 * setting severity as INFORMATION.<br>
		 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:277</i>
		 */
		public static final int CL_LOG_SEV_INFO = (0x1 + 6);
		/**
		 * setting severity as DEBUG.<br>
		 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:281</i>
		 */
		public static final int CL_LOG_SEV_DEBUG = (0x1 + 7);
		/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:282</i> */
		public static final int CL_LOG_SEV_DEBUG1 = (int)ClLogClientLibrary.ClLogSeverityT.CL_LOG_SEV_DEBUG;
		/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:283</i> */
		public static final int CL_LOG_SEV_DEBUG2 = ((int)ClLogClientLibrary.ClLogSeverityT.CL_LOG_SEV_DEBUG + 1);
		/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:284</i> */
		public static final int CL_LOG_SEV_DEBUG3 = ((int)ClLogClientLibrary.ClLogSeverityT.CL_LOG_SEV_DEBUG + 2);
		/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:285</i> */
		public static final int CL_LOG_SEV_DEBUG4 = ((int)ClLogClientLibrary.ClLogSeverityT.CL_LOG_SEV_DEBUG + 3);
		/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:286</i> */
		public static final int CL_LOG_SEV_DEBUG5 = ((int)ClLogClientLibrary.ClLogSeverityT.CL_LOG_SEV_DEBUG + 4);
		/**
		 * setting severity as DEBUG.<br>
		 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:290</i>
		 */
		public static final int CL_LOG_SEV_TRACE = (int)ClLogClientLibrary.ClLogSeverityT.CL_LOG_SEV_DEBUG5;
		/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:291</i> */
		public static final int CL_LOG_SEV_DEBUG6 = ((int)ClLogClientLibrary.ClLogSeverityT.CL_LOG_SEV_DEBUG5 + 1);
		/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:292</i> */
		public static final int CL_LOG_SEV_DEBUG7 = ((int)ClLogClientLibrary.ClLogSeverityT.CL_LOG_SEV_DEBUG5 + 2);
		/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:293</i> */
		public static final int CL_LOG_SEV_DEBUG8 = ((int)ClLogClientLibrary.ClLogSeverityT.CL_LOG_SEV_DEBUG5 + 3);
		/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:294</i> */
		public static final int CL_LOG_SEV_DEBUG9 = ((int)ClLogClientLibrary.ClLogSeverityT.CL_LOG_SEV_DEBUG5 + 4);
		/**
		 * Maximum severity level.<br>
		 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:298</i>
		 */
		public static final int CL_LOG_SEV_MAX = (int)ClLogClientLibrary.ClLogSeverityT.CL_LOG_SEV_DEBUG9;
	};
	/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h</i> */
	public static final int CL_LOG_STREAM_NAME_MAX_LENGTH = (int)128;
	/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h</i> */
	public static final int CL_LOG_SLINE_MSG_LEN = (int)256;
	/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h</i> */
	public static final int CL_LOG_STREAM_CREATE = (int)0x1;
	/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h</i> */
	public static final int CL_LOG_HANDLER_WILL_ACK = (int)0x1;
	/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h</i> */
	public static final int CL_LOG_FILTER_ASSIGN = (int)0x1;
	/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h</i> */
	public static final int CL_LOG_FILTER_MERGE_ADD = (int)0x2;
	/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h</i> */
	public static final int CL_LOG_FILTER_MERGE_DELETE = (int)0x3;
	/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h</i> */
	public static final int CL_LOG_MSGID_BUFFER = (int)0;
	/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h</i> */
	public static final int CL_LOG_MSGID_PRINTF_FMT = (int)1;
	/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h</i> */
	public static final int CL_LOG_TAG_TERMINATE = (int)0;
	/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h</i> */
	public static final int CL_LOG_TAG_BASIC_SIGNED = (int)0x1;
	/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h</i> */
	public static final int CL_LOG_TAG_BASIC_UNSIGNED = (int)0x2;
	/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h</i> */
	public static final int CL_LOG_TAG_STRING = (int)0x3;
	/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h</i> */
	public static final String CL_LOG_PRNT_FMT_STR = (String)"%-26s [%s:%d] (%.*s.%d : %s.%3s.%3s";
	/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h</i> */
	public static final String CL_LOG_PRNT_FMT_STR_CONSOLE = (String)"%-26s [%s:%d] (%.*s.%d : %s.%3s.%3s.%05d : %6s) ";
	/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h</i> */
	public static final String CL_LOG_PRNT_FMT_STR_WO_FILE = (String)"%-26s (%.*s.%d : %s.%3s.%3s";
	/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h</i> */
	public static final String CL_LOG_PRNT_FMT_STR_WO_FILE_CONSOLE = (String)"%-26s (%.*s.%d : %s.%3s.%3s.%05d : %6s) ";
	/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h</i> */
	public interface ClLogStreamOpenCallbackT extends Callback {
		void apply(long invocation, long hStream, int rc);
	};
	/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h</i> */
	public interface ClLogFilterSetCallbackT extends Callback {
		void apply(long hStream, ClLogFilterT.ByValue filter);
	};
	/** <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h</i> */
	public interface ClLogRecordDeliveryCallbackT extends Callback {
		void apply(long hStream, long seqNum, int numRecords, Pointer pRecords);
	};
	
	/**
	 * ***********************************<br>
	 *  \brief  Initializes the Log service for the calling process and ensures<br>
	 *  the version compatability.<br>
	 *  \par Header File:<br>
	 *  clLogApi.h<br>
	 *  \param phLog (out) Handle returned by the Log Service. This handle is used<br>
	 *  by the calling process for subsequent invocation LogAPIs. Each invocation of<br>
	 *  clLogInitialize() returns the new log handle.<br>
	 *  \param pLogCallbacks (in) contains callback functions which can be invoked<br>
	 *  on calling process.<br>
	 *  \param pVersion (in/out)  As an input parameter, version is a pointer to the required<br>
	 *  Log Service version.  As an output parameter, the version actually supported by the<br>
	 *  Log Service is delivered.<br>
	 *  \retval  CL_OK The Log Service is initialized successfully.<br>
	 *  \retval  CL_ERR_VERSION_MISMATCH The supplied version is not supported by current<br>
	 *  implementation.<br>
	 *  \retval  CL_ERR_TIMEOUT An implementation defined timeout occurred before the call<br>
	 *  could complete.<br>
	 *  \retval  CL_ERR_TRY_AGAIN The service could not be provided at this time. <br>
	 *  The process may try later.<br>
	 *  \retval  CL_ERR_NULL_POINTER Either phLog or pVersion is passed as NULL.<br>
	 *  \retval  CL_ERR_NO_MEMORY Either the Log Service library or some other module of <br>
	 *  Log Service is out of memory. Thus service can not be provided at this time. This<br>
	 *  may be a transient problem.<br>
	 *  \retval  CL_ERR_NO_RESOURCE Either the Log Service library or some other module <br>
	 *  of Log Service is out of resources (other than memory). Thus, service can not be<br>
	 *  provided at this time. This may be a transient problem.<br>
	 *  \par Description:<br>
	 *  This function initializes the Log Service for the invoking process, performs<br>
	 *  version compatibility checks and registers various callbacks provided. This<br>
	 *  function must be invoked before any other function of Log Service API. The<br>
	 *  handle phLog is returned as the reference to this association of the process<br>
	 *  and Log Service. The process uses this handle in subsequent interaction with<br>
	 *  Log Service.<br>
	 *  \par Library File:<br>
	 *  ClLogClient<br>
	 *  \sa clLogFinalize()<br>
	 * Original signature : <code>ClRcT clLogInitialize(ClLogHandleT*, const ClLogCallbacksT*, ClVersionT*)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:705</i><br>
	 * use the safer methods {@link #clLogInitialize(java.nio.LongBuffer, ClLogClient.ClLogCallbacksT, com.sun.jna.Pointer)} and {@link #clLogInitialize(com.sun.jna.ptr.LongByReference, ClLogClient.ClLogCallbacksT, com.sun.jna.Pointer)} instead
	 */
	//@Deprecated 
	int clLogInitialize(LongByReference phLog, ClLogCallbacksT pLogCallbacks, Pointer pVersion);
	/**
	 * ***********************************<br>
	 *  \brief  Initializes the Log service for the calling process and ensures<br>
	 *  the version compatability.<br>
	 *  \par Header File:<br>
	 *  clLogApi.h<br>
	 *  \param phLog (out) Handle returned by the Log Service. This handle is used<br>
	 *  by the calling process for subsequent invocation LogAPIs. Each invocation of<br>
	 *  clLogInitialize() returns the new log handle.<br>
	 *  \param pLogCallbacks (in) contains callback functions which can be invoked<br>
	 *  on calling process.<br>
	 *  \param pVersion (in/out)  As an input parameter, version is a pointer to the required<br>
	 *  Log Service version.  As an output parameter, the version actually supported by the<br>
	 *  Log Service is delivered.<br>
	 *  \retval  CL_OK The Log Service is initialized successfully.<br>
	 *  \retval  CL_ERR_VERSION_MISMATCH The supplied version is not supported by current<br>
	 *  implementation.<br>
	 *  \retval  CL_ERR_TIMEOUT An implementation defined timeout occurred before the call<br>
	 *  could complete.<br>
	 *  \retval  CL_ERR_TRY_AGAIN The service could not be provided at this time. <br>
	 *  The process may try later.<br>
	 *  \retval  CL_ERR_NULL_POINTER Either phLog or pVersion is passed as NULL.<br>
	 *  \retval  CL_ERR_NO_MEMORY Either the Log Service library or some other module of <br>
	 *  Log Service is out of memory. Thus service can not be provided at this time. This<br>
	 *  may be a transient problem.<br>
	 *  \retval  CL_ERR_NO_RESOURCE Either the Log Service library or some other module <br>
	 *  of Log Service is out of resources (other than memory). Thus, service can not be<br>
	 *  provided at this time. This may be a transient problem.<br>
	 *  \par Description:<br>
	 *  This function initializes the Log Service for the invoking process, performs<br>
	 *  version compatibility checks and registers various callbacks provided. This<br>
	 *  function must be invoked before any other function of Log Service API. The<br>
	 *  handle phLog is returned as the reference to this association of the process<br>
	 *  and Log Service. The process uses this handle in subsequent interaction with<br>
	 *  Log Service.<br>
	 *  \par Library File:<br>
	 *  ClLogClient<br>
	 *  \sa clLogFinalize()<br>
	 * Original signature : <code>ClRcT clLogInitialize(ClLogHandleT*, const ClLogCallbacksT*, ClVersionT*)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:705</i>
	 */
	//int clLogInitialize(LongBuffer phLog, ClLogCallbacksT pLogCallbacks, Pointer pVersion);
	/**
	 * ***********************************<br>
	 *  \brief  Finalize the Log service for the calling process and ensures<br>
	 *  to release all the resources.<br>
	 *  \par Header File:<br>
	 *  clLogApi.h<br>
	 *  \param hLog (in) Handle obtained by the previous invocation<br>
	 *  clLogInitialize. This handle identifies the association to be closed<br>
	 *  between the calling process and LogService.<br>
	 *  \retval  CL_OK The Log Service is finalized successfully.<br>
	 *  \retval  CL_ERR_INVALID_HANDLE The passed handle is either not obtained<br>
	 *  through clLogInitialize() or this handle association has been already closed<br>
	 *  by another invocation clLogFinalize(). <br>
	 *  \retval  CL_ERR_TIMEOUT An implementation defined timeout occurred before the call<br>
	 *  could complete.<br>
	 *  \retval  CL_ERR_TRY_AGAIN The service could not be provided at this time. <br>
	 *  The process may try later.<br>
	 *  \retval  CL_ERR_NO_MEMORY Either the Log Service library or some other module of <br>
	 *  Log Service is out of memory. Thus service can not be provided at this time. This<br>
	 *  may be a transient problem.<br>
	 *  \retval  CL_ERR_NO_RESOURCE Either the Log Service library or some other module <br>
	 *  of Log Service is out of resources (other than memory). Thus, service can not be<br>
	 *  provided at this time. This may be a transient problem.<br>
	 *  \par Description:<br>
	 *  This function closes the association between the Log Service and the invoking<br>
	 *  process, identified by the handle hLog, and frees up all the resource<br>
	 *  acquired by this association. Other functions of Log Service API function<br>
	 *  must not be invoked after a successful invocation to this function. Process<br>
	 *  must have acquired hLog through a previous successful invocation to<br>
	 *  clLogInitialize(). For each successful invocation to clLogInitialize(), the<br>
	 *  process must invoke clLogFinalize() before going down gracefully. On<br>
	 *  successful completion, this function frees up all the resources acquired by<br>
	 *  this association. All opened Log Stream are closed, all registrations for Log<br>
	 *  Stream Handlers are de-registered, and all opened Log File handles are<br>
	 *  closed. <br>
	 *  \par Library File:<br>
	 *  ClLogClient<br>
	 *  \sa clLogInitialize()<br>
	 * Original signature : <code>ClRcT clLogFinalize(ClLogHandleT)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:761</i>
	 */
	int clLogFinalize(long hLog);
	/**
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:879</i><br>
	 * Conversion Error : struct ClNameT {<br>
	 * 	unsigned short length;<br>
	 * 	char[256] value;<br>
	 * }
	 */
	 
	 int clLogStreamOpen(long hLog, clUtils.ClUtilsLibrary.ClNameT.ByValue streamName, int streamScope, ClLogStreamAttributesT pStreamAttr, int streamOpenFlags, long timeout, LongByReference phStream);
	 
	/**
	 * ***********************************<br>
	 *  \brief Close the stream opened for logging. <br>
	 *  \par Header File:<br>
	 *  clLogApi.h<br>
	 *  \param hStream (in) Handle obtained by the previous invocation<br>
	 *  clLogStreamOpen(). This handle identifies the log stream to be closed. <br>
	 *  \retval  CL_OK The Log Stream is closed successfully.<br>
	 *  \retval  CL_ERR_INVALID_HANDLE The passed Log Stream handle is not valid. <br>
	 *  Either it is not received through a previous invocation to clLogStreamOpen() <br>
	 *  or it has already been closed through an invocation to clLogStreamClose(). <br>
	 *  \retval  CL_ERR_TIMEOUT An implementation defined timeout occurred before the call<br>
	 *  could complete.<br>
	 *  \retval  CL_ERR_TRY_AGAIN The service could not be provided at this time. <br>
	 *  The process may try later.<br>
	 *  \retval  CL_ERR_NO_MEMORY Either the Log Service library or some other module of <br>
	 *  Log Service is out of memory. Thus service can not be provided at this time. This<br>
	 *  may be a transient problem.<br>
	 *  \retval  CL_ERR_NO_RESOURCE Either the Log Service library or some other module <br>
	 *  of Log Service is out of resources (other than memory). Thus, service can not be<br>
	 *  provided at this time. This may be a transient problem.<br>
	 *  \par Description:<br>
	 *  This function closes a Log Stream identified by \e hStream. \e hStream must have<br>
	 *  been obtained through a previous invocation of either clLogStreamOpen() <br>
	 *  or clLogStreamOpenAsync(). After successful completion of this function or a<br>
	 *  failure with return value CL_ERR_TIMEOUT, hStream is no longer valid and must<br>
	 *  not be used for any other stream related operations. If hStream represents a<br>
	 *  Log Stream which is not pre-defined and that Log Stream is not opened by any<br>
	 *  process in the cluster, the Log Stream is deleted. When all the Log Streams<br>
	 *  being persisted in the same Log File are deleted, the Log File is closed.<br>
	 *  Closing a Log Stream releases all the resources allocated by Log Service to<br>
	 *  this instance of opening. If a process terminates without closing Log Streams<br>
	 *  opened by it, Log Service implicitly closes all such Log Streams.<br>
	 *  On successful completion of this call, all pending callbacks referring to<br>
	 *  this hStream are cancelled. Since the invocation of callbacks is an<br>
	 *  asynchronous operation, some callbacks may still be delivered after this call<br>
	 *  returns successfully.<br>
	 *  \par Library File:<br>
	 *  ClLogClient<br>
	 *  \sa clLogStreamOpen()<br>
	 * Original signature : <code>ClRcT clLogStreamClose(ClLogStreamHandleT)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:940</i>
	 */
	int clLogStreamClose(long hStream);
	/**
	 * ***********************************<br>
	 *  \brief Logs a Log Record in the specified Log Stream. <br>
	 *  \par Header File:<br>
	 *  clLogApi.h, clLogErrors.h<br>
	 *  \param hStream (in) Handle obtained by the previous invocation<br>
	 *  clLogStreamOpen(). This handle identifies the Log Stream on which the log<br>
	 *  record to be placed.<br>
	 *  \param severity (in) This field must be set to one of the values defined. <br>
	 *  It defines the severity level of the Log Record being written.<br>
	 *  \param serviceId (in) This field identifies the module within the process<br>
	 *  which is generating this Log Record. If the Log Record message is a generic<br>
	 *  one like out of memory, this field can be used to narrow down on the module <br>
	 *  impacted. For ASP client libraries, these values are defined in clCommon.h.<br>
	 *  For application modules, it is up-to the application developer to define the<br>
	 *  values and scope of those values.<br>
	 *  \param msgId (in) This field identifies the actual message to be Logged. <br>
	 *  This is typically an identifier for a string message which the viewer is aware<br>
	 *  of through off-line mechanism. Rest of the arguments of this function are<br>
	 *  interpreted by the viewer based on this identifier. For application Log<br>
	 *  Streams, the values and scope of each value is defined by the application<br>
	 *  developer. Following two values are pre-defined:<br>
	 *  \arg \c CL_LOG_MSGID_BUFFER   <br>
	 *  \arg \c CL_LOG_MSGID_PRINTF_FMT<br>
	 *  <br>
	 *  In case, msgId is passed as CL_LOG_MSGID_BUFFER, it is followed by two<br>
	 *  parameters:<br>
	 *  \arg \c First one is of type ClUint32T. It is the number of bytes in the buffer<br>
	 *  pointed by the second parameter.<br>
	 *  \arg \c Second one is a pointer to a buffer. It is of type ClPtrT. The buffer may<br>
	 *  contain binary or ASCII data. The number of bytes of useful data is indicated<br>
	 *  by previous parameter. In case the buffer contains ASCII data, if the buffer<br>
	 *  is NULL terminated, the length must include the NULL termination byte. This<br>
	 *  buffer is not freed by the Log Service.<br>
	 *  In case, msgId is passed as \c CL_LOG_MSGID_PRINTF_FMT, the next argument is<br>
	 *  treated as format string of printf (3). Rest of the arguments are interpreted<br>
	 *  as per this format string.<br>
	 *  For other values of msgId, rest of arguments are treated as a set of 3-tuples.<br>
	 *  Each of these tuple is of the form <Tag, Length, Value Pointer>. The tuple of<br>
	 *  3 arguments is interpreted as follows<br>
	 *  First one is of type ClUint16T. It is treated as the tag to identify contents<br>
	 *  of third argument in this tuple.<br>
	 *  Second one is of type ClUint16T. It is treated as number of bytes in the<br>
	 *  buffer pointed by third argument.<br>
	 *  Third one is of type ::ClPtrT. The buffer may contain binary or ASCII data,<br>
	 *  which is defined by the tag (first argument in this tuple). The Log Service<br>
	 *  does not interpret this buffer. Only the Log Consumer interprets it and must<br>
	 *  be aware of the semantic meaning of its contents. It simply copies this buffer<br>
	 *  in the Log Record. In case of ASCII data, if the buffer is NULL terminated,<br>
	 *  the length must include the NULL termination byte. This buffer is not freed by<br>
	 *  the Log Service.<br>
	 *  End of this set of tuple is indicated by a special tag \c CL_LOG_TAG_TERMINATE.<br>
	 *  Thus, the variable part of this argument list will always have 3*n + 1, <br>
	 *  where n is the number of parameters to be logged. Following tag values are <br>
	 *  defined by Log Service, rests are defined by the application.<br>
	 *  \arg \c CL_LOG_TAG_TERMINATE        <br>
	 *  \arg \c CL_LOG_TAG_BASIC_SIGNED    <br>
	 *  \arg \c CL_LOG_TAG_BASIC_UNSIGNED <br>
	 *  \arg \c CL_LOG_TAG_STRING        <br>
	 *  Log Service also defines following macros to ease the use of this function.<br>
	 *  \arg \c CL_LOG_TLV_UINT8(var)             <br>
	 *  \arg \c CL_LOG_TLV_INT8(var)               <br>
	 *  \arg \c CL_LOG_TLV_UINT16(var)           <br>
	 *  \arg \c CL_LOG_TLV_INT16(var)           <br>
	 *  \arg \c CL_LOG_TLV_UINT32(var)             <br>
	 *  \arg \c CL_LOG_TLV_INT32(var)             <br>
	 *  \arg \c CL_LOG_TLV_UINT64(var)          <br>
	 *  \arg \c CL_LOG_TLV_INT64(var)          <br>
	 *  \arg \c CL_LOG_TLV_STRING(var)        <br>
	 *  \retval  CL_OK The Log Record is recorded successfully. But this does not<br>
	 *  mean that the record has been persisted in the Log File.<br>
	 *  \retval  CL_ERR_INVALID_HANDLE The passed Log Stream handle is not valid. <br>
	 *  Either it is not received through a previous invocation to clLogStreamOpen() <br>
	 *  or it has already been closed through an invocation to clLogStreamClose(). <br>
	 *  \retval  CL_ERR_TIMEOUT An implementation defined timeout occurred before the call<br>
	 *  could complete.<br>
	 *  \retval  CL_ERR_TRY_AGAIN The service could not be provided at this time. <br>
	 *  The process may try later.<br>
	 *  \retval  CL_ERR_NO_MEMORY Either the Log Service library or some other module of <br>
	 *  Log Service is out of memory. Thus service can not be provided at this time. This<br>
	 *  may be a transient problem.<br>
	 *  \retval  CL_ERR_NO_RESOURCE Either the Log Service library or some other module <br>
	 *  of Log Service is out of resources (other than memory). Thus, service can not be<br>
	 *  provided at this time. This may be a transient problem.<br>
	 *  \retval  CL_LOG_ERR_FILE_FULL Log Stream identified by \e hStream was created with<br>
	 *  fileFullAction attribute set to CL_LOG_FILE_FULL_ACTION_HALT and the Log File<br>
	 *  has become full. Thus no more Log Records can be logged into this stream. The<br>
	 *  Stream must be closed.<br>
	 *  \par Description:<br>
	 *     This function puts a Log Record in the Log Stream identified by hStream.<br>
	 *  An invocation to this function is non-blocking. When this function returns,<br>
	 *  it is guaranteed that the record has been recorded into Log Stream, but the<br>
	 *  record might not be persisted in the Log File. Timing of persistence of this<br>
	 *  Log Record in the Log File depends on the flushFreq and flushInterval<br>
	 *  attributes of the Log Stream.<br>
	 *  \par <br>
	 *      This function accepts variable number of arguments. Actual number of<br>
	 *  arguments and their types depend on msgId parameter. If the value of msgId is<br>
	 *  CL_LOG_MSGID_BUFFER, then two more arguments are expected which are length of<br>
	 *  buffer and pointer to the buffer. If the value of msgId is CL_LOG_MSGID_PRINTF_FMT,<br>
	 *  then next argument is treated as a C printf style format string and rest of the<br>
	 *  arguments are interpreted as per the format string. <br>
	 *  For all other values, the variable number of arguments are treated as<br>
	 *  a set of 3-tuples. They should be 3*n+1, where n is the number of parameters<br>
	 *  to be logged along with the msgId. For each such parameter, a tag identifying<br>
	 *  the type of the parameter, a length denoting number of bytes in the parameter<br>
	 *  and a pointer to the parameter are passed. The last argument must be a<br>
	 *  special tag CL_LOG_TAG_TERMINATE. Values of msgId and tags, other than<br>
	 *  defined by Log Service are not interpreted and the data is just copied into<br>
	 *  the Log Record. It is the responsibility of Log Consumer to get the semantic<br>
	 *  meaning of these and interpret the Log Record properly.<br>
	 *  \par <br>
	 *     Certain other information like Log Timestamp and Component Id are also<br>
	 *  recorded in the Log Record by the Log Service. Log Timestamp is the wall<br>
	 *  clock time at the time of invocation to this function on the host where the<br>
	 *  Logger is running. Component Id is the unique identifier identifying this<br>
	 *  instance of the application. This is issued by Component Manager and remains<br>
	 *  unchanged across process restart or cluster restart.The Log Record is written<br>
	 *  in the Log Stream in an atomic fashion. Thus,concurrent recording by multiple<br>
	 *  threads of the same process or multiple processes in the cluster is properly <br>
	 *  handled.None of the buffers passed to this function are freed by this function.<br>
	 *  It is the responsibility of the Logger to free those buffers. Thus, pointers to<br>
	 *  stack variables can also be passed as pointers to this function without any<br>
	 *  adverse side-effect.<br>
	 *  \par Library File:<br>
	 *  ClLogClient<br>
	 *  \sa clLogStreamOpen(), clLogStreamClose()<br>
	 * Original signature : <code>ClRcT clLogWriteAsync(ClLogStreamHandleT, ClLogSeverityT, ClUint16T, ClUint16T, null)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:1087</i>
	 */
	int clLogWriteAsync(long hStream, int severity, short serviceId, short msgId, Object... varArgs1);
	/**
	 * Original signature : <code>ClRcT clLogWriteAsyncWithHeader(ClLogStreamHandleT, ClLogSeverityT, ClUint16T, ClUint16T, null)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:1094</i>
	 */
	int clLogWriteAsyncWithHeader(long hStream, int severity, short serviceId, short msgId, Object... varArgs1);
	/**
	 * Original signature : <code>ClRcT clLogWriteAsyncWithContextHeader(ClLogStreamHandleT, ClLogSeverityT, const ClCharT*, const ClCharT*, ClUint16T, ClUint16T, null)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:1101</i><br>
	 * @deprecated use the safer methods {@link #clLogWriteAsyncWithContextHeader(long, int, java.nio.ByteBuffer, java.nio.ByteBuffer, short, short, java.lang.Object)} and {@link #clLogWriteAsyncWithContextHeader(long, int, com.sun.jna.Pointer, com.sun.jna.Pointer, short, short, java.lang.Object)} instead
	 */
	@Deprecated 
	int clLogWriteAsyncWithContextHeader(long hStream, int severity, Pointer pArea, Pointer pContext, short serviceId, short msgId, Object... varArgs1);
	/**
	 * Original signature : <code>ClRcT clLogWriteAsyncWithContextHeader(ClLogStreamHandleT, ClLogSeverityT, const ClCharT*, const ClCharT*, ClUint16T, ClUint16T, null)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:1101</i>
	 */
	int clLogWriteAsyncWithContextHeader(long hStream, int severity, String pArea, String pContext, short serviceId, short msgId, Object... varArgs1);
	/**
	 * *********************************************************************<br>
	 *  \brief Changes the filter settings of a Log Stream.<br>
	 *  \par Header File:<br>
	 *  clLogApi.h, clLogErrors.h<br>
	 *  \param hStream (in) Handle obtained by the previous invocation<br>
	 *  clLogStreamOpen(). This handle identifies the Log Stream whose filter<br>
	 *  setting have to be changed.<br>
	 *  \param logFilterFlags (in) This parameter identifies the way in which <br>
	 *  filter parameter should be used. This filter can overwrite any previous <br>
	 *  filter set or it can be used to modify a previous filter. To clear a <br>
	 *  previous filter, this field should be set to CL_LOG_FILTER_ASSIGN and all<br>
	 *  other fields should be set to zero.<br>
	 *  \param filter (in) Filter settings to be applied.<br>
	 *  \retval  CL_OK Changes in the filter settings have been done successfully.<br>
	 *  \retval  CL_ERR_INVALID_HANDLE The passed Log Stream handle is not valid. <br>
	 *  Either it is not received through a previous invocation to clLogStreamOpen() <br>
	 *  or it has already been closed through an invocation to clLogStreamClose(). <br>
	 *  \retval  CL_ERR_TIMEOUT An implementation defined timeout occurred before the call<br>
	 *  could complete.<br>
	 *  \retval  CL_ERR_TRY_AGAIN The service could not be provided at this time. <br>
	 *  The process may try later.<br>
	 *  \retval  CL_ERR_NO_MEMORY Either the Log Service library or some other module of <br>
	 *  Log Service is out of memory. Thus service can not be provided at this time. This<br>
	 *  may be a transient problem.<br>
	 *  \retval  CL_ERR_NO_RESOURCE Either the Log Service library or some other module <br>
	 *  of Log Service is out of resources (other than memory). Thus, service can not be<br>
	 *  provided at this time. This may be a transient problem.<br>
	 *  \par Description:<br>
	 *  This function sets the filter on the stream identified by \e hStream. This<br>
	 *  filter can be used to overwrite or clear or modify a previously set filter.<br>
	 *  The logFilterFlags parameter is used to identify the correct operation. The<br>
	 *  logSeverityFilter field of filter parameter is used to set filter setting<br>
	 *  based on severity of the Log Record. All Log Records with severity bits set<br>
	 *  in the filter maintained by Log Service on a per Log Stream basis enter the<br>
	 *  Log Stream. Similarly, pLogMsgIdSet and pLogCompIdSet is used to specify<br>
	 *  filter based on message ID and component ID respectively. Here the msgId and<br>
	 *  the compId to be masked, that is, not allowed to enter the Log Stream should<br>
	 *  be specified.To clear a previously set filter, all the fields of filter should<br>
	 *  be set to zero and logFilterFlags should be set to CL_LOG_FILTER_ASSIGN.<br>
	 *  \par Library File:<br>
	 *  ClLogClient<br>
	 *  \sa clLogStreamOpen(), clLogWriteAsync(), clLogStreamClose()<br>
	 * Original signature : <code>ClRcT clLogFilterSet(ClLogStreamHandleT, ClLogFilterFlagsT, ClLogFilterT)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:1168</i>
	 */
	int clLogFilterSet(long hStream, byte filterFlags, ClLogFilterT.ByValue filter);
	/**
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:1240</i><br>
	 * Conversion Error : struct ClNameT {<br>
	 * 	unsigned short length;<br>
	 * 	char[256] value;<br>
	 * }
	 */
	/**
	 * *********************************************************************<br>
	 *  \brief Deregisters the calling process as handler for the specified<br>
	 *   stream.<br>
	 *  \par Header File:<br>
	 *  clLogApi.h<br>
	 *  \param hStream (in) Handle obtained through a previous invocation to<br>
	 *  clLogHandlerRegister(). This handle identifies the registration of handler<br>
	 *  for a stream which is being deregistered.<br>
	 *  \retval  CL_OK The handle has been deregistered successfully.<br>
	 *  \retval  CL_ERR_INVALID_HANDLE The passed Log Stream handle is not valid.<br>
	 *  Either it is not received through a previous invocation to clLogHandlerRegister()<br>
	 *  or it has already been deregistered through an invocation to clLogHandlerDeregister()<br>
	 *  or hLog supplied to clLogHandlerRegister() during registration of the handler has<br>
	 *  been finalized.<br>
	 *  \retval  CL_ERR_TIMEOUT An implementation defined timeout occurred before the call<br>
	 *  could complete.<br>
	 *  \retval  CL_ERR_TRY_AGAIN The service could not be provided at this time. <br>
	 *  The process may try later.<br>
	 *  \retval  CL_ERR_NO_MEMORY Either the Log Service library or some other module of <br>
	 *  Log Service is out of memory. Thus service can not be provided at this time. This<br>
	 *  may be a transient problem.<br>
	 *  \retval  CL_ERR_NO_RESOURCE Either the Log Service library or some other module <br>
	 *  of Log Service is out of resources (other than memory). Thus, service can not be<br>
	 *  provided at this time. This may be a transient problem.<br>
	 *  \par Description:<br>
	 *  This function deregisters interest of the calling process in handling the<br>
	 *  Log Stream. Once the interest has been deregistered, the calling process will<br>
	 *  stop getting clLogRecordDeliverCallback. This call cancels all the pending<br>
	 *  clLogRecordDeliverCallback callbacks. Since callback invocation is<br>
	 *  asynchronous, the process may still get some pending callbacks. After this<br>
	 *  invocation, hStream is no longer valid. If the handler process terminates<br>
	 *  without deregistering its interest, Log Service will implicitly deregisters<br>
	 *  the process. If the Log Service handle \e hLog used during clLogHandlerRegister<br>
	 *  invocation is finalized without explicitly deregistering the interest in<br>
	 *  handling the stream, Log Service will implicitly deregisters the process.<br>
	 *  \par Library File:<br>
	 *  ClLogClient<br>
	 *  \sa clLogHandlerRegister()<br>
	 * Original signature : <code>ClRcT clLogHandlerDeregister(ClLogStreamHandleT)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:1299</i>
	 */
	int clLogHandlerDeregister(long hStream);
	/**
	 * *********************************************************************<br>
	 *  \brief Function to acknowledge, receipt of Log Records, to the sender <br>
	 *  of the Log Records.<br>
	 *  \par Header File:<br>
	 *  clLogApi.h<br>
	 *  \param hStream (in) Handle obtained through a previous invocation to<br>
	 *  clLogHandlerRegister(). This handle identifies the registration of handler<br>
	 *  for a stream which is records are being acknowledged<br>
	 *  \param sequenceNumber (in) Number identifying the set of Log Records <br>
	 *  received.This number is obtained from ClLogRecordDeliverCallbackT.<br>
	 *  \param numRecords (in) Number of records received successfully by <br>
	 *  the handler<br>
	 *  \retval  CL_OK The api has successfully sent the acknowledgement.<br>
	 *  \retval  CL_ERR_INVALID_HANDLE The passed Log Stream handle is not valid. <br>
	 *  Either it is not received through a previous invocation to<br>
	 *  clLogHandlerRegister() or it has already been closed through an invocation<br>
	 *  to clLogHandlerDeregister(). <br>
	 *  \retval  CL_ERR_TIMEOUT An implementation defined timeout occurred before the call<br>
	 *  could complete.<br>
	 *  \retval  CL_ERR_TRY_AGAIN The service could not be provided at this time. <br>
	 *  The process may try later.<br>
	 *  \retval  CL_ERR_NO_MEMORY Either the Log Service library or some other module of <br>
	 *  Log Service is out of memory. Thus service can not be provided at this time. This<br>
	 *  may be a transient problem.<br>
	 *  \retval  CL_ERR_NO_RESOURCE Either the Log Service library or some other module <br>
	 *  of Log Service is out of resources (other than memory). Thus, service can not be<br>
	 *  provided at this time. This may be a transient problem.<br>
	 *  \retval CL_ERR_BAD_FLAG \c CL_LOG_HANDLER_WILL_ACK flag was not set while registering<br>
	 *  the handler.<br>
	 *  \par Description:<br>
	 *  This function acknowledges the receipt of Log Records for the Log Stream that<br>
	 *  this handler is interested in. Handler should acknowledge only if it<br>
	 *  registered with the flag \c CL_LOG_HANDLER_WILL_ACK in the previous invocation<br>
	 *  of function, clLogHandlerRegister. The sender of the Log Records treat the<br>
	 *  records as lost if the acknowledgement is not received in specified time<br>
	 *  limit.<br>
	 *  \par Library File:<br>
	 *  ClLogClient<br>
	 *  \sa clLogHandlerRegister()<br>
	 * Original signature : <code>ClRcT clLogHandlerRecordAck(ClLogStreamHandleT, ClUint64T, ClUint32T)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:1358</i>
	 */
	int clLogHandlerRecordAck(long hStream, long sequenceNumber, int numRecords);
	/**
	 * *********************************************************************<br>
	 *  \brief Opens the current logical log file for reading the log records. <br>
	 *  \par Header File:<br>
	 *  clLogApi.h<br>
	 *  \param hLog (in) Handle obtained by the previous invocation<br>
	 *  clLogInitialize(). This handle identifies the association between the<br>
	 *  calling process and the Log service.<br>
	 *  \param fileName (in) Name of the file that the process wants to open for<br>
	 *  reading the records.<br>
	 *  \param fileLocation (in) Location where the file exists. <br>
	 *   refer ::ClLogStreamAttributesT.<br>
	 *  \param isDelete (in) Parmeter that tell the log service to delete the records<br>
	 *  read by this file handler from the file for new records.<br>
	 *  \param phFile (out) Pointer to memory area where the handle to the Log File<br>
	 *  is returned. This handle must be used for further operations on this Log File.<br>
	 *  \retval  CL_OK The api has successfully opened file for reading.<br>
	 *  \retval  CL_ERR_INVALID_HANDLE The passed Log handle is not valid. <br>
	 *  Either it is not received through a previous invocation to<br>
	 *  clLogInitialize() or it has already been closed through an invocation<br>
	 *  to clLogFinalize(). <br>
	 *  \retval CL_ERR_NULL_POINTER \e phFile parameter is passed as NULL.<br>
	 *  \retval CL_ERR_NOT_EXITS The Log File identified by filename and fileLocation<br>
	 *  does not exist.<br>
	 *  \retval  CL_ERR_TIMEOUT An implementation defined timeout occurred before the call<br>
	 *  could complete.<br>
	 *  \retval  CL_ERR_TRY_AGAIN The service could not be provided at this time. <br>
	 *  The process may try later.<br>
	 *  \retval  CL_ERR_NO_MEMORY Either the Log Service library or some other module of <br>
	 *  Log Service is out of memory. Thus service can not be provided at this time. This<br>
	 *  may be a transient problem.<br>
	 *  \retval  CL_ERR_NO_RESOURCE Either the Log Service library or some other module <br>
	 *  of Log Service is out of resources (other than memory). Thus, service can not be<br>
	 *  provided at this time. This may be a transient problem.<br>
	 *  \par Description:<br>
	 *  This function opens a logical log file for the process to get records and<br>
	 *  metadata. Once the file is opened the metadata can be obtained by invoking<br>
	 *  clLogFileMetadataGet() and records can be obtained by invocation of<br>
	 *  clLogFileRecordsGet() Memory for phFIle is allocated and freed by the <br>
	 *  calling process. Each invocation of this call returns a new handle and will <br>
	 *  start reading the records from the oldest record available.<br>
	 *  \par Library File:<br>
	 *  ClLogClient<br>
	 *  \sa clLogInitialize<br>
	 * Original signature : <code>ClRcT clLogFileOpen(ClLogHandleT, ClCharT*, ClCharT*, ClBoolT, ClLogFileHandleT*)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:1426</i><br>
	 * @deprecated use the safer methods {@link #clLogFileOpen(long, java.nio.ByteBuffer, java.nio.ByteBuffer, short, java.nio.LongBuffer)} and {@link #clLogFileOpen(long, com.sun.jna.Pointer, com.sun.jna.Pointer, short, com.sun.jna.ptr.LongByReference)} instead
	 */
	@Deprecated 
	int clLogFileOpen(long hLog, Pointer fileName, Pointer fileLocation, short isDelete, LongByReference phFile);
	/**
	 * *********************************************************************<br>
	 *  \brief Opens the current logical log file for reading the log records. <br>
	 *  \par Header File:<br>
	 *  clLogApi.h<br>
	 *  \param hLog (in) Handle obtained by the previous invocation<br>
	 *  clLogInitialize(). This handle identifies the association between the<br>
	 *  calling process and the Log service.<br>
	 *  \param fileName (in) Name of the file that the process wants to open for<br>
	 *  reading the records.<br>
	 *  \param fileLocation (in) Location where the file exists. <br>
	 *   refer ::ClLogStreamAttributesT.<br>
	 *  \param isDelete (in) Parmeter that tell the log service to delete the records<br>
	 *  read by this file handler from the file for new records.<br>
	 *  \param phFile (out) Pointer to memory area where the handle to the Log File<br>
	 *  is returned. This handle must be used for further operations on this Log File.<br>
	 *  \retval  CL_OK The api has successfully opened file for reading.<br>
	 *  \retval  CL_ERR_INVALID_HANDLE The passed Log handle is not valid. <br>
	 *  Either it is not received through a previous invocation to<br>
	 *  clLogInitialize() or it has already been closed through an invocation<br>
	 *  to clLogFinalize(). <br>
	 *  \retval CL_ERR_NULL_POINTER \e phFile parameter is passed as NULL.<br>
	 *  \retval CL_ERR_NOT_EXITS The Log File identified by filename and fileLocation<br>
	 *  does not exist.<br>
	 *  \retval  CL_ERR_TIMEOUT An implementation defined timeout occurred before the call<br>
	 *  could complete.<br>
	 *  \retval  CL_ERR_TRY_AGAIN The service could not be provided at this time. <br>
	 *  The process may try later.<br>
	 *  \retval  CL_ERR_NO_MEMORY Either the Log Service library or some other module of <br>
	 *  Log Service is out of memory. Thus service can not be provided at this time. This<br>
	 *  may be a transient problem.<br>
	 *  \retval  CL_ERR_NO_RESOURCE Either the Log Service library or some other module <br>
	 *  of Log Service is out of resources (other than memory). Thus, service can not be<br>
	 *  provided at this time. This may be a transient problem.<br>
	 *  \par Description:<br>
	 *  This function opens a logical log file for the process to get records and<br>
	 *  metadata. Once the file is opened the metadata can be obtained by invoking<br>
	 *  clLogFileMetadataGet() and records can be obtained by invocation of<br>
	 *  clLogFileRecordsGet() Memory for phFIle is allocated and freed by the <br>
	 *  calling process. Each invocation of this call returns a new handle and will <br>
	 *  start reading the records from the oldest record available.<br>
	 *  \par Library File:<br>
	 *  ClLogClient<br>
	 *  \sa clLogInitialize<br>
	 * Original signature : <code>ClRcT clLogFileOpen(ClLogHandleT, ClCharT*, ClCharT*, ClBoolT, ClLogFileHandleT*)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:1426</i>
	 */
	int clLogFileOpen(long hLog, String fileName, String fileLocation, short isDelete, LongByReference phFile);
	/**
	 * *********************************************************************<br>
	 *  \brief Close the file which was opened for reading. <br>
	 *  \par Header File:<br>
	 *  clLogApi.h<br>
	 *  \param hFile (in) Handle obtained through a previous invocation to <br>
	 *  clLogFileOpen(). This handle identifies the Log File opened.<br>
	 *  \retval  CL_OK The api has successfully opened file for reading.<br>
	 *  \retval  CL_ERR_INVALID_HANDLE The passed file handle is not valid. <br>
	 *  Either it is not received through a previous invocation to<br>
	 *  clLogFileOpen() or it has already been closed through an invocation<br>
	 *  to clLogFileClose(). <br>
	 *  \retval  CL_ERR_TIMEOUT An implementation defined timeout occurred before <br>
	 *  the call could complete.<br>
	 *  \retval  CL_ERR_TRY_AGAIN The service could not be provided at this time. <br>
	 *  The process may try later.<br>
	 *  \retval  CL_ERR_NO_MEMORY Either the Log Service library or some other module of <br>
	 *  Log Service is out of memory. Thus service can not be provided at this time. This<br>
	 *  may be a transient problem.<br>
	 *  \retval  CL_ERR_NO_RESOURCE Either the Log Service library or some other module <br>
	 *  of Log Service is out of resources (other than memory). Thus, service can <br>
	 *  not be provided at this time. This may be a transient problem.<br>
	 *  \par Description:<br>
	 *  This function closes the Log File opened by the process for reading the log<br>
	 *  records, once the file is closed no more records can be read from it.<br>
	 *  Metadata of the file cannot be read after that. <br>
	 *  \par Library File:<br>
	 *  ClLogClient<br>
	 *  \sa clLogFileOpen<br>
	 * Original signature : <code>ClRcT clLogFileClose(ClLogFileHandleT)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:1475</i>
	 */
	int clLogFileClose(long hFileHdlr);
	/**
	 * *********************************************************************<br>
	 *  \brief Gets the metadata of the file. <br>
	 *  \par Header File:<br>
	 *  clLogApi.h<br>
	 *  \param hFile (in) Handle obtained through a previous invocation to<br>
	 *  clLogFileOpen().This handle identifies the Log File whose meta data<br>
	 *  is to be obtained.<br>
	 *  \param streamAttr (out) Attributes of all the stream that are being<br>
	 *  persisted into the file identified by hFile<br>
	 *  \param pNumStreams (out) Number of streams whose records are currently<br>
	 *  being persisted into the Log File identified by hFile. This indicates <br>
	 *  the number of entries in ppLogStreams. Memory for pNumStreams is allocated<br>
	 *  and freed by the calling process.<br>
	 *  \param ppLogStreams (out) Pointer to a memory area where pointer to array<br>
	 *  of Log Stream information will be stored. Each entry in this array <br>
	 *  corresponds to one Log Stream in the File. Memory for ppLogStreams is <br>
	 *  allocated and freed by the calling process, whereas, memory for <br>
	 *  \e *ppLogStreams is allocated by the Log Service and freed by the calling<br>
	 *  process.<br>
	 *  \retval  CL_OK The api has been successfully executed.<br>
	 *  \retval  CL_ERR_INVALID_HANDLE The passed file handle is not valid. <br>
	 *  Either it is not received through a previous invocation to<br>
	 *  clLogFileOpen() or it has already been closed through an invocation<br>
	 *  to clLogFileClose(). <br>
	 *  \retval CL_ERR_TIMEOUT An implementation defined timeout occurred before <br>
	 *  the call could complete.<br>
	 *  \retval CL_ERR_NULL_POINTER Either pNumRecords or pLogRecords are passed<br>
	 *  as NULL.<br>
	 *  \retval  CL_ERR_TRY_AGAIN The service could not be provided at this time. <br>
	 *  The process may try later.<br>
	 *  \retval  CL_ERR_NO_MEMORY Either the Log Service library or some other module of <br>
	 *  Log Service is out of memory. Thus service can not be provided at this time. This<br>
	 *  may be a transient problem.<br>
	 *  \retval  CL_ERR_NO_RESOURCE Either the Log Service library or some other module <br>
	 *  of Log Service is out of resources (other than memory). Thus, service can <br>
	 *  not be provided at this time. This may be a transient problem.<br>
	 *  \par Description:<br>
	 *  The function returns the Log Records from the file identified by hFile.<br>
	 *  Function returns the set of record starting from the oldest record written in<br>
	 *  the Log File. After sending the set, the records are cleaned up from the<br>
	 *  file, that is, these records are no longer available, thus creating space for<br>
	 *  new records<br>
	 *  \par Library File:<br>
	 *  ClLogClient<br>
	 *  \sa clLogFileOpen<br>
	 * Original signature : <code>ClRcT clLogFileMetaDataGet(ClLogFileHandleT, ClLogStreamAttributesT*, ClUint32T*, ClLogStreamMapT**)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:1542</i><br>
	 * @deprecated use the safer methods {@link #clLogFileMetaDataGet(long, ClLogClient.ClLogStreamAttributesT, java.nio.IntBuffer, ClLogClient.ClLogStreamMapT.ByReference[])} and {@link #clLogFileMetaDataGet(long, ClLogClient.ClLogStreamAttributesT, com.sun.jna.ptr.IntByReference, ClLogClient.ClLogStreamMapT.ByReference[])} instead
	 */
	@Deprecated 
	int clLogFileMetaDataGet(long hFileHdlr, ClLogStreamAttributesT pStreamAttr, IntByReference pNumStreams, PointerByReference ppLogStreams);
	/**
	 * *********************************************************************<br>
	 *  \brief Gets the metadata of the file. <br>
	 *  \par Header File:<br>
	 *  clLogApi.h<br>
	 *  \param hFile (in) Handle obtained through a previous invocation to<br>
	 *  clLogFileOpen().This handle identifies the Log File whose meta data<br>
	 *  is to be obtained.<br>
	 *  \param streamAttr (out) Attributes of all the stream that are being<br>
	 *  persisted into the file identified by hFile<br>
	 *  \param pNumStreams (out) Number of streams whose records are currently<br>
	 *  being persisted into the Log File identified by hFile. This indicates <br>
	 *  the number of entries in ppLogStreams. Memory for pNumStreams is allocated<br>
	 *  and freed by the calling process.<br>
	 *  \param ppLogStreams (out) Pointer to a memory area where pointer to array<br>
	 *  of Log Stream information will be stored. Each entry in this array <br>
	 *  corresponds to one Log Stream in the File. Memory for ppLogStreams is <br>
	 *  allocated and freed by the calling process, whereas, memory for <br>
	 *  \e *ppLogStreams is allocated by the Log Service and freed by the calling<br>
	 *  process.<br>
	 *  \retval  CL_OK The api has been successfully executed.<br>
	 *  \retval  CL_ERR_INVALID_HANDLE The passed file handle is not valid. <br>
	 *  Either it is not received through a previous invocation to<br>
	 *  clLogFileOpen() or it has already been closed through an invocation<br>
	 *  to clLogFileClose(). <br>
	 *  \retval CL_ERR_TIMEOUT An implementation defined timeout occurred before <br>
	 *  the call could complete.<br>
	 *  \retval CL_ERR_NULL_POINTER Either pNumRecords or pLogRecords are passed<br>
	 *  as NULL.<br>
	 *  \retval  CL_ERR_TRY_AGAIN The service could not be provided at this time. <br>
	 *  The process may try later.<br>
	 *  \retval  CL_ERR_NO_MEMORY Either the Log Service library or some other module of <br>
	 *  Log Service is out of memory. Thus service can not be provided at this time. This<br>
	 *  may be a transient problem.<br>
	 *  \retval  CL_ERR_NO_RESOURCE Either the Log Service library or some other module <br>
	 *  of Log Service is out of resources (other than memory). Thus, service can <br>
	 *  not be provided at this time. This may be a transient problem.<br>
	 *  \par Description:<br>
	 *  The function returns the Log Records from the file identified by hFile.<br>
	 *  Function returns the set of record starting from the oldest record written in<br>
	 *  the Log File. After sending the set, the records are cleaned up from the<br>
	 *  file, that is, these records are no longer available, thus creating space for<br>
	 *  new records<br>
	 *  \par Library File:<br>
	 *  ClLogClient<br>
	 *  \sa clLogFileOpen<br>
	 * Original signature : <code>ClRcT clLogFileMetaDataGet(ClLogFileHandleT, ClLogStreamAttributesT*, ClUint32T*, ClLogStreamMapT**)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:1542</i>
	 */
	int clLogFileMetaDataGet(long hFileHdlr, ClLogStreamAttributesT.ByReference pStreamAttr, IntByReference pNumStreams, PointerByReference ppLogStreams);
	/**
	 * *********************************************************************<br>
	 *  \brief Gets the metadata of the file. <br>
	 *  \par Header File:<br>
	 *  clLogApi.h<br>
	 *  \param hFile (in) Handle obtained through a previous invocation to<br>
	 *  clLogFileOpen().This handle identifies the Log File whose meta data<br>
	 *  is to be obtained.<br>
	 *  \param streamAttr (out) Attributes of all the stream that are being<br>
	 *  persisted into the file identified by hFile<br>
	 *  \param pNumStreams (out) Number of streams whose records are currently<br>
	 *  being persisted into the Log File identified by hFile. This indicates <br>
	 *  the number of entries in ppLogStreams. Memory for pNumStreams is allocated<br>
	 *  and freed by the calling process.<br>
	 *  \param ppLogStreams (out) Pointer to a memory area where pointer to array<br>
	 *  of Log Stream information will be stored. Each entry in this array <br>
	 *  corresponds to one Log Stream in the File. Memory for ppLogStreams is <br>
	 *  allocated and freed by the calling process, whereas, memory for <br>
	 *  \e *ppLogStreams is allocated by the Log Service and freed by the calling<br>
	 *  process.<br>
	 *  \retval  CL_OK The api has been successfully executed.<br>
	 *  \retval  CL_ERR_INVALID_HANDLE The passed file handle is not valid. <br>
	 *  Either it is not received through a previous invocation to<br>
	 *  clLogFileOpen() or it has already been closed through an invocation<br>
	 *  to clLogFileClose(). <br>
	 *  \retval CL_ERR_TIMEOUT An implementation defined timeout occurred before <br>
	 *  the call could complete.<br>
	 *  \retval CL_ERR_NULL_POINTER Either pNumRecords or pLogRecords are passed<br>
	 *  as NULL.<br>
	 *  \retval  CL_ERR_TRY_AGAIN The service could not be provided at this time. <br>
	 *  The process may try later.<br>
	 *  \retval  CL_ERR_NO_MEMORY Either the Log Service library or some other module of <br>
	 *  Log Service is out of memory. Thus service can not be provided at this time. This<br>
	 *  may be a transient problem.<br>
	 *  \retval  CL_ERR_NO_RESOURCE Either the Log Service library or some other module <br>
	 *  of Log Service is out of resources (other than memory). Thus, service can <br>
	 *  not be provided at this time. This may be a transient problem.<br>
	 *  \par Description:<br>
	 *  The function returns the Log Records from the file identified by hFile.<br>
	 *  Function returns the set of record starting from the oldest record written in<br>
	 *  the Log File. After sending the set, the records are cleaned up from the<br>
	 *  file, that is, these records are no longer available, thus creating space for<br>
	 *  new records<br>
	 *  \par Library File:<br>
	 *  ClLogClient<br>
	 *  \sa clLogFileOpen<br>
	 * Original signature : <code>ClRcT clLogFileMetaDataGet(ClLogFileHandleT, ClLogStreamAttributesT*, ClUint32T*, ClLogStreamMapT**)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:1542</i>
	 */
	int clLogFileMetaDataGet(long hFileHdlr, ClLogStreamAttributesT pStreamAttr, IntByReference pNumStreams, ClLogStreamMapT.ByReference ppLogStreams[]);
	/**
	 * *********************************************************************<br>
	 *  \brief Gets the records from the file. <br>
	 *  \par Header File:<br>
	 *  clLogApi.h<br>
	 *  \param hFile (in) Handle obtained through a previous invocation to <br>
	 *  clLogFileOpen().This handle identifies the Log File whose records are<br>
	 *  to be read.<br>
	 *  \param pStartTime (out) Its the lowest timestamp in the set of <br>
	 *  records being returned in this call in pLogRecords. It identifies the <br>
	 *  oldest record in the current set. Memory for pStartTime is allocated <br>
	 *  and freed by the calling process.<br>
	 *  \param pEndTime (out) Its the highest timestamp in the set of records <br>
	 *  being returned in this call in pLogRecords. It identifies the freshest<br>
	 *  record in the current set. Memory for pEndTime is allocated and freed <br>
	 *  by the calling process.<br>
	 *  \param pNumRecords (in-out) Caller specifies the number of records it <br>
	 *  wants.Function returns the actual number of records that are read. <br>
	 *  Function always read from the oldest record written into the file, which<br>
	 *  is not read till now. It reads till the number of records requested or <br>
	 *  number of records available, whichever is smaller. Memory for \e pNumStreams<br>
	 *  is allocated and freed by the calling process.<br>
	 *  \param pLogRecords (out) Pointer to a memory area where the Log Records <br>
	 *  read will be stored. Total number of Log Records stored will be specified <br>
	 *  by the value of \e pNumRecords. Memory for pLogRecords is allocated and freed <br>
	 *  by the calling process.<br>
	 *  \retval  CL_OK The api has been successfully executed.<br>
	 *  \retval  CL_ERR_INVALID_HANDLE The passed file handle is not valid. <br>
	 *  Either it is not received through a previous invocation to<br>
	 *  clLogFileOpen() or it has already been closed through an invocation<br>
	 *  to clLogFileClose(). <br>
	 *  \retval CL_ERR_TIMEOUT An implementation defined timeout occurred before <br>
	 *  the call could complete.<br>
	 *  \retval CL_ERR_NULL_POINTER Either pNumRecords or pLogRecords are passed<br>
	 *  as NULL.<br>
	 *  \retval  CL_ERR_TRY_AGAIN The service could not be provided at this time. <br>
	 *  The process may try later.<br>
	 *  \retval  CL_ERR_NO_MEMORY Either the Log Service library or some other module of <br>
	 *  Log Service is out of memory. Thus service can not be provided at this time. This<br>
	 *  may be a transient problem.<br>
	 *  \retval  CL_ERR_NO_RESOURCE Either the Log Service library or some other module <br>
	 *  of Log Service is out of resources (other than memory). Thus, service can <br>
	 *  not be provided at this time. This may be a transient problem.<br>
	 *  \par Description:<br>
	 *  The function returns the Log Records from the file identified by hFile.<br>
	 *  Function returns the set of record starting from the oldest record written in<br>
	 *  the Log File. After sending the set, the records are cleaned up from the<br>
	 *  file, that is, these records are no longer available, thus creating space for<br>
	 *  new records<br>
	 *  \par Library File:<br>
	 *  ClLogClient<br>
	 *  \sa clLogFileOpen<br>
	 * Original signature : <code>ClRcT clLogFileRecordsGet(ClLogFileHandleT, ClTimeT*, ClTimeT*, ClUint32T*, ClPtrT*)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:1618</i><br>
	 * use the safer methods {@link #clLogFileRecordsGet(long, java.nio.LongBuffer, java.nio.LongBuffer, java.nio.IntBuffer, com.sun.jna.ptr.PointerByReference)} and {@link #clLogFileRecordsGet(long, com.sun.jna.ptr.LongByReference, com.sun.jna.ptr.LongByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.PointerByReference)} instead
	 */
	//@Deprecated 
	int clLogFileRecordsGet(long hFileHdlr, LongByReference pStarTime, LongByReference pEndTime, IntByReference pNumRecords, PointerByReference pLogRecords);
	/**
	 * *********************************************************************<br>
	 *  \brief Gets the records from the file. <br>
	 *  \par Header File:<br>
	 *  clLogApi.h<br>
	 *  \param hFile (in) Handle obtained through a previous invocation to <br>
	 *  clLogFileOpen().This handle identifies the Log File whose records are<br>
	 *  to be read.<br>
	 *  \param pStartTime (out) Its the lowest timestamp in the set of <br>
	 *  records being returned in this call in pLogRecords. It identifies the <br>
	 *  oldest record in the current set. Memory for pStartTime is allocated <br>
	 *  and freed by the calling process.<br>
	 *  \param pEndTime (out) Its the highest timestamp in the set of records <br>
	 *  being returned in this call in pLogRecords. It identifies the freshest<br>
	 *  record in the current set. Memory for pEndTime is allocated and freed <br>
	 *  by the calling process.<br>
	 *  \param pNumRecords (in-out) Caller specifies the number of records it <br>
	 *  wants.Function returns the actual number of records that are read. <br>
	 *  Function always read from the oldest record written into the file, which<br>
	 *  is not read till now. It reads till the number of records requested or <br>
	 *  number of records available, whichever is smaller. Memory for \e pNumStreams<br>
	 *  is allocated and freed by the calling process.<br>
	 *  \param pLogRecords (out) Pointer to a memory area where the Log Records <br>
	 *  read will be stored. Total number of Log Records stored will be specified <br>
	 *  by the value of \e pNumRecords. Memory for pLogRecords is allocated and freed <br>
	 *  by the calling process.<br>
	 *  \retval  CL_OK The api has been successfully executed.<br>
	 *  \retval  CL_ERR_INVALID_HANDLE The passed file handle is not valid. <br>
	 *  Either it is not received through a previous invocation to<br>
	 *  clLogFileOpen() or it has already been closed through an invocation<br>
	 *  to clLogFileClose(). <br>
	 *  \retval CL_ERR_TIMEOUT An implementation defined timeout occurred before <br>
	 *  the call could complete.<br>
	 *  \retval CL_ERR_NULL_POINTER Either pNumRecords or pLogRecords are passed<br>
	 *  as NULL.<br>
	 *  \retval  CL_ERR_TRY_AGAIN The service could not be provided at this time. <br>
	 *  The process may try later.<br>
	 *  \retval  CL_ERR_NO_MEMORY Either the Log Service library or some other module of <br>
	 *  Log Service is out of memory. Thus service can not be provided at this time. This<br>
	 *  may be a transient problem.<br>
	 *  \retval  CL_ERR_NO_RESOURCE Either the Log Service library or some other module <br>
	 *  of Log Service is out of resources (other than memory). Thus, service can <br>
	 *  not be provided at this time. This may be a transient problem.<br>
	 *  \par Description:<br>
	 *  The function returns the Log Records from the file identified by hFile.<br>
	 *  Function returns the set of record starting from the oldest record written in<br>
	 *  the Log File. After sending the set, the records are cleaned up from the<br>
	 *  file, that is, these records are no longer available, thus creating space for<br>
	 *  new records<br>
	 *  \par Library File:<br>
	 *  ClLogClient<br>
	 *  \sa clLogFileOpen<br>
	 * Original signature : <code>ClRcT clLogFileRecordsGet(ClLogFileHandleT, ClTimeT*, ClTimeT*, ClUint32T*, ClPtrT*)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:1618</i>
	 */
	//int clLogFileRecordsGet(long hFileHdlr, LongBuffer pStarTime, LongBuffer pEndTime, IntBuffer pNumRecords, PointerByReference pLogRecords);
	/**
	 * ***********************************<br>
	 *  \brief Gets the list of active streams available in the cluster.<br>
	 *  \par Header File:<br>
	 *  clLogApi.h, clLogErrors.h<br>
	 *  \param hLog (in) Handle obtained by the previous invocation<br>
	 *  clLogInitialize(). This handle identifies the association between the<br>
	 *  calling process and log service. <br>
	 *  \param pNumStreams (out) Number of streams that are currently open in the<br>
	 *  cluster. This indicates the number of entries in \e ppLogStreams. Memory for<br>
	 *  \e pNumStreams is allocated and freed by the calling process.<br>
	 *  \param ppLogStreams (out) Pointer to a memory area where pointer to array<br>
	 *  of Log Stream information will be stored. Each entry in this array corresponds<br>
	 *  to one Log Stream in the cluster. Memory for \e ppLogStreams is allocated and <br>
	 *  freed by the calling process, whereas, memory for \e *ppLogStreams is allocated <br>
	 *  by the Log Service and freed by the calling process.<br>
	 *  \retval  CL_OK The API has been successfully executed.<br>
	 *  \retval  CL_ERR_INVALID_HANDLE The passed handle(hLog) is either not obtained<br>
	 *  through clLogInitialize() or this handle association has been already closed<br>
	 *  by another invocation clLogFinalize(). <br>
	 *  \retval  CL_ERR_TIMEOUT An implementation defined timeout occurred before the call<br>
	 *  could complete.<br>
	 *  \retval  CL_ERR_TRY_AGAIN The service could not be provided at this time. <br>
	 *  The process may try later.<br>
	 *  \retval  CL_ERR_NULL_POINTER Either pNumStreams or ppLogStreams are passed <br>
	 *  as NULL.<br>
	 *  \retval  CL_ERR_NO_MEMORY Either the Log Service library or some other module of <br>
	 *  Log Service is out of memory. Thus service can not be provided at this time. This<br>
	 *  may be a transient problem.<br>
	 *  \retval  CL_ERR_NO_RESOURCE Either the Log Service library or some other module <br>
	 *  of Log Service is out of resources (other than memory). Thus, service can not be<br>
	 *  provided at this time. This may be a transient problem.<br>
	 *  \par Description:<br>
	 *  The function returns information about all the Log Streams in the cluster.<br>
	 *  It is used by Log Handlers to find out Log Streams in which they may be<br>
	 *  interested in.<br>
	 *  \par Library File:<br>
	 *  ClLogClient<br>
	 *  \sa clLogStreamOpen(), clLogStreamClose()<br>
	 * Original signature : <code>ClRcT clLogStreamListGet(ClLogHandleT, ClUint32T*, ClLogStreamInfoT**)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:1679</i><br>
	 * use the safer methods {@link #clLogStreamListGet(long, java.nio.IntBuffer, ClLogClient.ClLogStreamInfoT.ByReference[])} and {@link #clLogStreamListGet(long, com.sun.jna.ptr.IntByReference, ClLogClient.ClLogStreamInfoT.ByReference[])} instead
	 */
	//@Deprecated 
	int clLogStreamListGet(long hLog, IntByReference pNumStreams, PointerByReference ppLogStreams);
	/**
	 * ***********************************<br>
	 *  \brief Gets the list of active streams available in the cluster.<br>
	 *  \par Header File:<br>
	 *  clLogApi.h, clLogErrors.h<br>
	 *  \param hLog (in) Handle obtained by the previous invocation<br>
	 *  clLogInitialize(). This handle identifies the association between the<br>
	 *  calling process and log service. <br>
	 *  \param pNumStreams (out) Number of streams that are currently open in the<br>
	 *  cluster. This indicates the number of entries in \e ppLogStreams. Memory for<br>
	 *  \e pNumStreams is allocated and freed by the calling process.<br>
	 *  \param ppLogStreams (out) Pointer to a memory area where pointer to array<br>
	 *  of Log Stream information will be stored. Each entry in this array corresponds<br>
	 *  to one Log Stream in the cluster. Memory for \e ppLogStreams is allocated and <br>
	 *  freed by the calling process, whereas, memory for \e *ppLogStreams is allocated <br>
	 *  by the Log Service and freed by the calling process.<br>
	 *  \retval  CL_OK The API has been successfully executed.<br>
	 *  \retval  CL_ERR_INVALID_HANDLE The passed handle(hLog) is either not obtained<br>
	 *  through clLogInitialize() or this handle association has been already closed<br>
	 *  by another invocation clLogFinalize(). <br>
	 *  \retval  CL_ERR_TIMEOUT An implementation defined timeout occurred before the call<br>
	 *  could complete.<br>
	 *  \retval  CL_ERR_TRY_AGAIN The service could not be provided at this time. <br>
	 *  The process may try later.<br>
	 *  \retval  CL_ERR_NULL_POINTER Either pNumStreams or ppLogStreams are passed <br>
	 *  as NULL.<br>
	 *  \retval  CL_ERR_NO_MEMORY Either the Log Service library or some other module of <br>
	 *  Log Service is out of memory. Thus service can not be provided at this time. This<br>
	 *  may be a transient problem.<br>
	 *  \retval  CL_ERR_NO_RESOURCE Either the Log Service library or some other module <br>
	 *  of Log Service is out of resources (other than memory). Thus, service can not be<br>
	 *  provided at this time. This may be a transient problem.<br>
	 *  \par Description:<br>
	 *  The function returns information about all the Log Streams in the cluster.<br>
	 *  It is used by Log Handlers to find out Log Streams in which they may be<br>
	 *  interested in.<br>
	 *  \par Library File:<br>
	 *  ClLogClient<br>
	 *  \sa clLogStreamOpen(), clLogStreamClose()<br>
	 * Original signature : <code>ClRcT clLogStreamListGet(ClLogHandleT, ClUint32T*, ClLogStreamInfoT**)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:1679</i>
	 */
	//int clLogStreamListGet(long hLog, IntBuffer pNumStreams, ClLogClient.ClLogStreamInfoT.ByReference ppLogStreams[]);
	/**
	 * ***********************************<br>
	 *  \brief Gets the list of active streams available in the cluster.<br>
	 *  \par Header File:<br>
	 *  clLogApi.h, clLogErrors.h<br>
	 *  \param hLog (in) Handle obtained by the previous invocation<br>
	 *  clLogInitialize(). This handle identifies the association between the<br>
	 *  calling process and log service. <br>
	 *  \param pNumStreams (out) Number of streams that are currently open in the<br>
	 *  cluster. This indicates the number of entries in \e ppLogStreams. Memory for<br>
	 *  \e pNumStreams is allocated and freed by the calling process.<br>
	 *  \param ppLogStreams (out) Pointer to a memory area where pointer to array<br>
	 *  of Log Stream information will be stored. Each entry in this array corresponds<br>
	 *  to one Log Stream in the cluster. Memory for \e ppLogStreams is allocated and <br>
	 *  freed by the calling process, whereas, memory for \e *ppLogStreams is allocated <br>
	 *  by the Log Service and freed by the calling process.<br>
	 *  \retval  CL_OK The API has been successfully executed.<br>
	 *  \retval  CL_ERR_INVALID_HANDLE The passed handle(hLog) is either not obtained<br>
	 *  through clLogInitialize() or this handle association has been already closed<br>
	 *  by another invocation clLogFinalize(). <br>
	 *  \retval  CL_ERR_TIMEOUT An implementation defined timeout occurred before the call<br>
	 *  could complete.<br>
	 *  \retval  CL_ERR_TRY_AGAIN The service could not be provided at this time. <br>
	 *  The process may try later.<br>
	 *  \retval  CL_ERR_NULL_POINTER Either pNumStreams or ppLogStreams are passed <br>
	 *  as NULL.<br>
	 *  \retval  CL_ERR_NO_MEMORY Either the Log Service library or some other module of <br>
	 *  Log Service is out of memory. Thus service can not be provided at this time. This<br>
	 *  may be a transient problem.<br>
	 *  \retval  CL_ERR_NO_RESOURCE Either the Log Service library or some other module <br>
	 *  of Log Service is out of resources (other than memory). Thus, service can not be<br>
	 *  provided at this time. This may be a transient problem.<br>
	 *  \par Description:<br>
	 *  The function returns information about all the Log Streams in the cluster.<br>
	 *  It is used by Log Handlers to find out Log Streams in which they may be<br>
	 *  interested in.<br>
	 *  \par Library File:<br>
	 *  ClLogClient<br>
	 *  \sa clLogStreamOpen(), clLogStreamClose()<br>
	 * Original signature : <code>ClRcT clLogStreamListGet(ClLogHandleT, ClUint32T*, ClLogStreamInfoT**)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:1679</i>
	 */
	int clLogStreamListGet(long hLog, IntByReference pNumStreams, ClLogStreamInfoT.ByReference ppLogStreams[]);
	
	/**
	 * Original signature : <code>ClRcT clLogSeverityFilterToValueGet(ClLogSeverityFilterT, ClLogSeverityT*)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:1769</i><br>
	 * use the safer methods {@link #clLogSeverityFilterToValueGet(short, java.nio.IntBuffer)} and {@link #clLogSeverityFilterToValueGet(short, com.sun.jna.ptr.IntByReference)} instead
	 */
	//@Deprecated 
	int clLogSeverityFilterToValueGet(short filter, IntByReference pSeverity);
	/**
	 * Original signature : <code>ClRcT clLogSeverityFilterToValueGet(ClLogSeverityFilterT, ClLogSeverityT*)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:1769</i>
	 */
	//int clLogSeverityFilterToValueGet(short filter, IntBuffer pSeverity);
	/**
	 * Original signature : <code>ClRcT clLogSeverityValueToFilterGet(ClLogSeverityT, ClLogSeverityFilterT*)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:1770</i><br>
	 * use the safer methods {@link #clLogSeverityValueToFilterGet(int, java.nio.ShortBuffer)} and {@link #clLogSeverityValueToFilterGet(int, com.sun.jna.ptr.ShortByReference)} instead
	 */
	//@Deprecated 
	int clLogSeverityValueToFilterGet(int severity, ShortByReference pFilter);
	/**
	 * Original signature : <code>ClRcT clLogSeverityValueToFilterGet(ClLogSeverityT, ClLogSeverityFilterT*)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:1770</i>
	 */
	//int clLogSeverityValueToFilterGet(int severity, ShortBuffer pFilter);
	/**
	 * Original signature : <code>ClRcT clLogStreamFilterSet(ClNameT*, ClLogStreamScopeT, ClNameT*, ClLogFilterFlagsT, ClLogFilterT)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:1772</i>
	 */
	int clLogStreamFilterSet( clUtils.ClUtilsLibrary.ClNameT pStreamName, int streamScope,  clUtils.ClUtilsLibrary.ClNameT pStreamScopeNode, byte filterFlags, ClLogFilterT filter);
	/**
	 * Original signature : <code>ClRcT clLogStreamFilterGet(ClNameT*, ClLogStreamScopeT, ClNameT*, ClLogFilterT*)</code><br>
	 * <i>native declaration : /home/clovis/opt/sdk-6.1/src/SAFplus/components/log/include/clLogApi.h:1778</i>
	 */
	int clLogStreamFilterGet( clUtils.ClUtilsLibrary.ClNameT pStreamName, int streamScope,  clUtils.ClUtilsLibrary.ClNameT pStreamScopeNode, ClLogFilterT pFilter);
}
