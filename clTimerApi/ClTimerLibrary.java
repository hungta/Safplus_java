package clTimerApi;
import clTimerApi.ClTimerStats.ByReference;
import clTimerApi.ClTimerTimeOutT.ByValue;
import com.sun.jna.Callback;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.Pointer;
import com.sun.jna.PointerType;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.PointerByReference;
import com.sun.jna.ptr.ShortByReference;
import com.sun.jna.ptr.LongByReference;
import java.nio.IntBuffer;
import java.nio.ShortBuffer;
/**
 * JNA Wrapper for library <b>ClTimer</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface ClTimerLibrary extends Library {
	public static final String JNA_LIBRARY_NAME = "ClTimer";
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(ClTimerLibrary.JNA_LIBRARY_NAME);
	public static final ClTimerLibrary INSTANCE = (ClTimerLibrary)Native.load(ClTimerLibrary.JNA_LIBRARY_NAME, ClTimerLibrary.class);
	/**
	 * <i>native declaration : clTimerApi.h</i><br>
	 * enum values
	 */
	public static interface ClTimerTypeT {
		/** <i>native declaration : clTimerApi.h:116</i> */
		public static final int CL_TIMER_ONE_SHOT = 0;
		/** <i>native declaration : clTimerApi.h:118</i> */
		public static final int CL_TIMER_REPETITIVE = 1;
		/** <i>native declaration : clTimerApi.h:120</i> */
		public static final int CL_TIMER_VOLATILE = 2;
		/** <i>native declaration : clTimerApi.h:121</i> */
		public static final int CL_TIMER_MAX_TYPE = 3;
	};
	/**
	 * <i>native declaration : clTimerApi.h</i><br>
	 * enum values
	 */
	public static interface ClTimerContextT {
		/** <i>native declaration : clTimerApi.h:136</i> */
		public static final int CL_TIMER_TASK_CONTEXT = 0;
		/** <i>native declaration : clTimerApi.h:138</i> */
		public static final int CL_TIMER_SEPARATE_CONTEXT = 1;
		/** <i>native declaration : clTimerApi.h:139</i> */
		public static final int CL_TIMER_MAX_CONTEXT = 2;
	};
	/**
	 * The type fo the callback fucntion that will be called on timer expiry.<br>
	 * Cast your function to 'ClRcT (*) (void *)'<br>
	 * <i>native declaration : clTimerApi.h:65</i>
	 */
	public interface ClTimerCallBackT extends Callback {
		int apply(Pointer pActionArgument);
	};
	/** <i>native declaration : clTimerApi.h</i> */
	public interface ClTimerReplicationCallbackT extends Callback {
		int apply(long bufferHandle);
	};
	/** <i>native declaration : clTimerApi.h</i> */
	/*public interface ClRcT_callback extends Callback {
		int apply(Pointer voidPtr1);
	};*/
	/**
	 * ***********************************<br>
	 *  \brief Configures the Timer library.<br>
	 *  \param pConfigData Pointer to instance of configuration structure.<br>
	 *  You must pass a pointer to a \e ClTimerConfigT as the input.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_TIMER_ERR_INVLD_PARAM On passing an invalid parameter.<br>
	 *  \retval CL_ERR_NULL_POINTER On passing a NULL pointer.<br>
	 *  \par Description:<br>
	 *  This API is used to configure the timer service library. The configurable<br>
	 *  parameters in \e ClTimerConfigT are:<br>
	 *   -# <B> timerResolution </B>:<br>
	 *  This value is in miliseconds and cannot be less than 10ms. Default value is 10 milliseconds. \n<br>
	 *   -# <B> timerTaskPriority </B>:<br>
	 *  This value can vary between 1 and 160. Default value is 150.<br>
	 * Original signature : <code>ClRcT clTimerConfigInitialize(void*)</code><br>
	 * <i>native declaration : clTimerApi.h:179</i>
	 */
	int clTimerConfigInitialize(Pointer pConfigData);
	/**
	 * ***********************************<br>
	 *  \brief Initializes the Timer library.<br>
	 *  \param pConfig<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval ERROR On failure.<br>
	 *  \par Description:<br>
	 *  This API is used to initialize the timer service library. After invoking this API<br>
	 *  you can create, start, stop and destroy timers.<br>
	 *  \sa clTimerFinalize()<br>
	 * Original signature : <code>ClRcT clTimerInitialize(ClPtrT)</code><br>
	 * <i>native declaration : clTimerApi.h:198</i>
	 */
	int clTimerInitialize(Pointer pConfig);
	/**
	 * ***********************************<br>
	 *  \brief Cleans up the Timer library.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval ERROR On failure.<br>
	 *  \par Description:<br>
	 *  This API is used to clean up the timer service library. This API is invoked<br>
	 *  during the system shutdown process or when timers are no longer needed.<br>
	 * Original signature : <code>ClRcT clTimerFinalize()</code><br>
	 * <i>native declaration : clTimerApi.h:214</i>
	 */
	int clTimerFinalize();
	/**
	 * ***********************************<br>
	 *  \brief Creates a timer.<br>
	 *  \param timeOut Timeout value of the timer.<br>
	 *  \param type Type of the timer to be created. It can be either One-shot or repetitive.<br>
	 *  \param timerTaskSpawn Determines whether the user-function invoked is<br>
	 *  in a separate task or in the same context as the timer-task.<br>
	 *  \param fpAction Function to be called after timer expiry.<br>
	 *  \param pActionArgument Argument to be passed to the callback<br>
	 *  function (fpAction in this case).<br>
	 *  \param pTimerHandle (out) Pointer to the memory location where the timer handle<br>
	 *  created is being copied.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_TIMER_ERR_INVLD_PARAM On passing invalid parameters.<br>
	 *  \retval CL_ERR_NO_MEMORY On memory allocation failure.<br>
	 *  \retval CL_ERR_NULL_POINTER On passing a NULL pointer.<br>
	 *  \retval CL_TIMER_ERR_NULL_CALLBACK_FUNCTION On passing a NULL callback function.<br>
	 *  \retval CL_TIMER_ERR_INVALID_TYPE On passing an invalid type.<br>
	 *  \retval CL_TIMER_ERR_INVALID_CONTEXT_TYPE On passing an invalid context.<br>
	 *  \par Description:<br>
	 *  This API is used to create a new timer. This timer would remain inactive<br>
	 *  until the timer is started. The callback function would be executed in the<br>
	 *  context of the timer task when the timer expires. This API returns a<br>
	 *  handle which needs to be specified whenever you want to start, stop, restart or destroy<br>
	 *  the timer.<br>
	 * Original signature : <code>ClRcT clTimerCreate(ClTimerTimeOutT, ClTimerTypeT, ClTimerContextT, ClTimerCallBackT, void*, ClTimerHandleT*)</code><br>
	 * @param timeOut the timeout, in clockticks<br>
	 * @param type one shot or repetitive<br>
	 * @param timerTaskSpawn whether to spawn off the timer function<br>as a separate task or invoke it in the<br>same context as the timer-task<br>
	 * @param fpAction the function to be called on timeout<br>
	 * @param pActionArgument the argument to the function called on timeout<br>
	 * <i>native declaration : clTimerApi.h:253</i>
	 */
	int clTimerCreate(ByValue timeOut, int type, int timerTaskSpawn, ClTimerLibrary.ClTimerCallBackT fpAction, Pointer pActionArgument, PointerByReference pTimerHandle);
	/**
	 * ***********************************<br>
	 *  \brief Deletes a timer.<br>
	 *  \note<br>
	 *  If the timer being deleted is active, then it is made inactive and deleted.<br>
	 *  \param pTimerHandle (out) Pointer to timer handle being deleted. The contents are set to 0.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER On passing a NULL pointer.<br>
	 *  \retval CL_ERR_INVALID_HANDLE On passing an invalid handle.<br>
	 *  \retval CL_TIMER_ERR_INVALID If the internal timer representation is invalid.<br>
	 *  \par Description:<br>
	 *  This API is used to delete an existing timer. It is invoked by the<br>
	 *  application after the timer has expired.<br>
	 *  Typically, this API is invoked during the time of application exit, but<br>
	 *  it can also be called at any other time.<br>
	 * Original signature : <code>ClRcT clTimerDelete(ClTimerHandleT*)</code><br>
	 * <i>native declaration : clTimerApi.h:286</i>
	 */
	int clTimerDelete(LongByReference pTimerHandle);
	/**
	 * Original signature : <code>ClRcT clTimerDeleteAsync(ClTimerHandleT*)</code><br>
	 * <i>native declaration : clTimerApi.h:289</i>
	 */
	int clTimerDeleteAsync(LongByReference pTimerHandle);
	/**
	 * ***********************************<br>
	 *  \brief Starts a timer.<br>
	 *  \param timerHandle Handle of the timer being started.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE On passing an invalid handle.<br>
	 *  \retval CL_TIMER_ERR_INVALID If the internal timer representation is invalid.<br>
	 *  \par Description:<br>
	 *  This API is used to start a timer. Before the timer can be started,<br>
	 *  the timer must be created. The callback API<br>
	 *  is executed when the timeout occurs. The callback<br>
	 *  API would be executed in the context of the timer task.<br>
	 * Original signature : <code>ClRcT clTimerStart(ClTimerHandleT)</code><br>
	 * <i>native declaration : clTimerApi.h:310</i>
	 */
	int clTimerStart(Pointer timerHandle);
	/**
	 * ***********************************<br>
	 *  \breif Stops a timer.<br>
	 *  \note<br>
	 *  This API only stops the timer and does not destroy it.<br>
	 *  \param timerHandle Handle of the timer being stopped.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE On passing an invalid handle.<br>
	 *  \retval CL_TIMER_ERR_INVALID If the internal timer representation is invalid.<br>
	 *  \par Description:<br>
	 *  This API is used to stop a timer. After invoking this API, the timer becomes inactive.<br>
	 * Original signature : <code>ClRcT clTimerStop(ClTimerHandleT)</code><br>
	 * <i>native declaration : clTimerApi.h:331</i>
	 */
	int clTimerStop(Pointer timerHandle);
	/**
	 * ***********************************<br>
	 *  \brief Creates a new timer and activates it.<br>
	 *  \param timeOut Timeout value of the timer.<br>
	 *  \param type Type of the timer to be created. It can be either One-shot or repetitive.<br>
	 *  \param timerTaskSpawn Determines whether the user-function invoked is<br>
	 *  in a separate task or in the same context as the timer-task.<br>
	 *  \param fpAction Function to be called after timer expiry.<br>
	 *  \param actionArgument Argument to be passed to the callback function (fpAction in this case).<br>
	 *  \param  pTimerHandle (out) Pointer to the memory location where the timer handle<br>
	 *  created is being copied.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_INVALID_PARAMETER  On passing an invalid parameter.<br>
	 *  \retval CL_ERR_NO_MEMORY On memory allocation failure.<br>
	 *  \retval CL_ERR_NULL_POINTER On passing a NULL pointer.<br>
	 *  \retval CL_TIMER_ERR_NULL_CALLBACK_FUNCTION On passing an invalid callback function.<br>
	 *  \retval CL_TIMER_ERR_INVALID_TYPE If type is invalid.<br>
	 *  \par Description:<br>
	 *  This API is used to create a new timer and activate it. It is essentially a<br>
	 *  combination of clTimerCreate() and clTimerStart().<br>
	 *  This API is useful when you want to create a new timer and<br>
	 *  activate it at the time of its creation.<br>
	 * Original signature : <code>ClRcT clTimerCreateAndStart(ClTimerTimeOutT, ClTimerTypeT, ClTimerContextT, ClTimerCallBackT, void*, ClTimerHandleT*)</code><br>
	 * @param timeOut the timeout, in clockticks<br>
	 * @param type one shot or repetitive<br>
	 * @param timerTaskSpawn whether to spawn off the timer function<br>as a separate task or invoke it in the<br>same context as the timer-task<br>
	 * @param fpAction the function to be called on timeout<br>
	 * @param pActionArgument the argument to the function<br>called on timeout<br>
	 * <i>native declaration : clTimerApi.h:361</i>
	 */
	int clTimerCreateAndStart(ClTimerTimeOutT.ByValue timeOut, int type, int timerTaskSpawn, ClTimerLibrary.ClTimerCallBackT fpAction, Pointer pActionArgument, LongByReference pTimerHandle);
	/**
	 * ***********************************<br>
	 *  \brief Restarts a timer.<br>
	 *  \param timerHandle Handle of the timer being restarted.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE On passing an invalid handle.<br>
	 *  \retval CL_TIMER_ERR_INVLD_STATE If timer is in invalid state.<br>
	 *  \retval CL_TIMER_ERR_INVALID If the internal timer representation is invalid.<br>
	 *  \par Description:<br>
	 *  This API is used to restart a timer.<br>
	 * Original signature : <code>ClRcT clTimerRestart(ClTimerHandleT)</code><br>
	 * <i>native declaration : clTimerApi.h:389</i>
	 */
	int clTimerRestart(Pointer timerHandle);
	/**
	 * ***********************************<br>
	 *  \brief Updates a timer.<br>
	 *  \param timerHandle Handle of the timer being updated.<br>
	 *  \param newTimeout New timeout value for the timer.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_INVALID_HANDLE On passing an invalid handle.<br>
	 *  \retval CL_TIMER_ERR_INVALID If the internal timer representation is invalid.<br>
	 *  \par Description:<br>
	 *  This API is used to update the timeout value of a timer.<br>
	 * Original signature : <code>ClRcT clTimerUpdate(ClTimerHandleT, ClTimerTimeOutT)</code><br>
	 * <i>native declaration : clTimerApi.h:408</i>
	 */
	int clTimerUpdate(Pointer timerHandle, ByValue newTimeout);
	/**
	 * ***********************************<br>
	 *  \brief Returns the timer type.<br>
	 *  \param timerHandle Handle of the timer.<br>
	 *  \param  pTimerType  (out) The pointer to the location to which the type of the<br>
	 *  timer is being copied. It can have two possible values:<br>
	 *  If the value is -<br>
	 *  \arg  0: The timer type is One-shot.<br>
	 *  \arg  1: The timer type is repetitive.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER On passing a NULL pointer.<br>
	 *  \retval CL_ERR_INVALID_HANDLE On passing an invalid handle.<br>
	 *  \retval CL_TIMER_ERR_INVALID If the internal timer representation is invalid.<br>
	 *  \par Description:<br>
	 *  This API is used to query and return for a specific type of timer, whether it is one-shot or repetitive.<br>
	 * Original signature : <code>ClRcT clTimerTypeGet(ClTimerHandleT, ClUint32T*)</code><br>
	 * <i>native declaration : clTimerApi.h:434</i><br>
	 * use the safer methods {@link #clTimerTypeGet(com.sun.jna.Pointer, java.nio.IntBuffer)} and {@link #clTimerTypeGet(com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference)} instead
	 */
	//@Deprecated 
	int clTimerTypeGet(long timerHandle, IntByReference pTimerType);
	/**
	 * ***********************************<br>
	 *  \brief Returns the timer type.<br>
	 *  \param timerHandle Handle of the timer.<br>
	 *  \param  pTimerType  (out) The pointer to the location to which the type of the<br>
	 *  timer is being copied. It can have two possible values:<br>
	 *  If the value is -<br>
	 *  \arg  0: The timer type is One-shot.<br>
	 *  \arg  1: The timer type is repetitive.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER On passing a NULL pointer.<br>
	 *  \retval CL_ERR_INVALID_HANDLE On passing an invalid handle.<br>
	 *  \retval CL_TIMER_ERR_INVALID If the internal timer representation is invalid.<br>
	 *  \par Description:<br>
	 *  This API is used to query and return for a specific type of timer, whether it is one-shot or repetitive.<br>
	 * Original signature : <code>ClRcT clTimerTypeGet(ClTimerHandleT, ClUint32T*)</code><br>
	 * <i>native declaration : clTimerApi.h:434</i>
	 */
	//int clTimerTypeGet(Pointer timerHandle, IntBuffer pTimerType);
	/**
	 * Original signature : <code>ClRcT clTimerClusterRegister(ClTimerCallBackT, ClTimerReplicationCallbackT)</code><br>
	 * <i>native declaration : clTimerApi.h:438</i>
	 */
	int clTimerClusterRegister(ClTimerLibrary.ClTimerCallBackT clusterCallback, ClTimerLibrary.ClTimerReplicationCallbackT replicationCallback);
	/**
	 * Original signature : <code>ClRcT clTimerCreateCluster(ClTimerTimeOutT, ClTimerTypeT, ClTimerContextT, void*, ClUint32T, ClTimerHandleT*)</code><br>
	 * <i>native declaration : clTimerApi.h:441</i>
	 */
	int clTimerCreateCluster(ByValue timeOut, int timerType, int timerContext, Pointer timerData, int timerDataSize, PointerByReference pTimerHandle);
	/**
	 * Original signature : <code>ClRcT clTimerCreateAndStartCluster(ClTimerTimeOutT, ClTimerTypeT, ClTimerContextT, void*, ClUint32T, ClTimerHandleT*)</code><br>
	 * <i>native declaration : clTimerApi.h:448</i>
	 */
	int clTimerCreateAndStartCluster(ByValue timeOut, int timerType, int timerContext, Pointer timerData, int timerDataSize, PointerByReference pTimerHandle);
	/**
	 * Original signature : <code>ClRcT clTimerClusterPack(ClTimerHandleT, ClBufferHandleT)</code><br>
	 * <i>native declaration : clTimerApi.h:455</i>
	 */
	int clTimerClusterPack(Pointer timer, Pointer msg);
	/**
	 * Original signature : <code>ClRcT clTimerClusterPackAll(ClBufferHandleT)</code><br>
	 * <i>native declaration : clTimerApi.h:457</i>
	 */
	int clTimerClusterPackAll(Pointer msg);
	/**
	 * Original signature : <code>ClRcT clTimerClusterUnpack(ClBufferHandleT, ClTimerHandleT*)</code><br>
	 * <i>native declaration : clTimerApi.h:459</i>
	 */
	int clTimerClusterUnpack(Pointer msg, PointerByReference pTimerHandle);
	/**
	 * Original signature : <code>ClRcT clTimerClusterUnpackAll(ClBufferHandleT)</code><br>
	 * <i>native declaration : clTimerApi.h:461</i>
	 */
	int clTimerClusterUnpackAll(Pointer msg);
	/**
	 * Original signature : <code>ClRcT clTimerClusterFree(ClTimerHandleT*)</code><br>
	 * <i>native declaration : clTimerApi.h:463</i>
	 */
	int clTimerClusterFree(PointerByReference pTimerHandle);
	/**
	 * Original signature : <code>ClRcT clTimerClusterConfigureAll()</code><br>
	 * <i>native declaration : clTimerApi.h:465</i>
	 */
	int clTimerClusterConfigureAll();
	/**
	 * Original signature : <code>ClRcT clTimerClusterConfigure(ClTimerHandleT*)</code><br>
	 * <i>native declaration : clTimerApi.h:467</i>
	 */
	int clTimerClusterConfigure(PointerByReference pTimerHandle);
	/**
	 * Original signature : <code>ClRcT clTimerClusterSync()</code><br>
	 * <i>native declaration : clTimerApi.h:469</i>
	 */
	int clTimerClusterSync();
	/**
	 * Original signature : <code>ClRcT clTimerIsRunning(ClTimerHandleT, ClBoolT*)</code><br>
	 * <i>native declaration : clTimerApi.h:474</i><br>
	 * use the safer methods {@link #clTimerIsRunning(com.sun.jna.Pointer, java.nio.ShortBuffer)} and {@link #clTimerIsRunning(com.sun.jna.Pointer, com.sun.jna.ptr.ShortByReference)} instead
	 */
	//@Deprecated 
	int clTimerIsRunning(long timerHandle, ShortByReference pState);
	/**
	 * Original signature : <code>ClRcT clTimerIsRunning(ClTimerHandleT, ClBoolT*)</code><br>
	 * <i>native declaration : clTimerApi.h:474</i>
	 */
	//int clTimerIsRunning(Pointer timerHandle, ShortBuffer pState);
	/**
	 * Original signature : <code>ClRcT clTimerIsStopped(ClTimerHandleT, ClBoolT*)</code><br>
	 * <i>native declaration : clTimerApi.h:476</i><br>
	 * use the safer methods {@link #clTimerIsStopped(com.sun.jna.Pointer, java.nio.ShortBuffer)} and {@link #clTimerIsStopped(com.sun.jna.Pointer, com.sun.jna.ptr.ShortByReference)} instead
	 */
	//@Deprecated 
	int clTimerIsStopped(long timerHandle, ShortByReference pState);
	/**
	 * Original signature : <code>ClRcT clTimerIsStopped(ClTimerHandleT, ClBoolT*)</code><br>
	 * <i>native declaration : clTimerApi.h:476</i>
	 */
	//int clTimerIsStopped(Pointer timerHandle, ShortBuffer pState);
	/**
	 * Original signature : <code>ClRcT clTimerStatsGet(ClTimerStatsT**, ClUint32T*)</code><br>
	 * <i>native declaration : clTimerApi.h:478</i><br>
	 * use the safer methods {@link #clTimerStatsGet(clTimerApi.ClTimerStats.ByReference[], java.nio.IntBuffer)} and {@link #clTimerStatsGet(clTimerApi.ClTimerStats.ByReference[], com.sun.jna.ptr.IntByReference)} instead
	 */
	//@Deprecated 
	int clTimerStatsGet(PointerByReference ppStats, IntByReference pNumTimers);
	/**
	 * Original signature : <code>ClRcT clTimerStatsGet(ClTimerStatsT**, ClUint32T*)</code><br>
	 * <i>native declaration : clTimerApi.h:478</i>
	 */
	//int clTimerStatsGet(ByReference ppStats[], IntBuffer pNumTimers);
	/**
	 * Original signature : <code>ClRcT clTimerStatsGet(ClTimerStatsT**, ClUint32T*)</code><br>
	 * <i>native declaration : clTimerApi.h:478</i>
	 */
	//int clTimerStatsGet(ByReference ppStats[], IntByReference pNumTimers);
	/**
	 * Original signature : <code>ClRcT clTimerCheckAndDelete(ClTimerHandleT*)</code><br>
	 * <i>native declaration : clTimerApi.h:480</i>
	 */
	int clTimerCheckAndDelete(PointerByReference pTimerHandle);
	/*public static class ClTimerCallBackT extends PointerType {
		public ClTimerCallBackT(Pointer address) {
			super(address);
		}
		public ClTimerCallBackT() {
			super();
		}
	};*/
}
