package clAmfClient;
import clAmfClient.ClAmsCSIDescriptorT.ByValue;
import com.sun.jna.Callback;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.Pointer;
import com.sun.jna.PointerType;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.LongByReference;
//import com.sun.jna.ptr.PointerByReference;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import java.nio.LongBuffer;
import clUtils.ClUtilsLibrary.*;
import clTimerApi.ClTimerTimeOutT;
import clIocApi.ClIocAddressT;

/**
 * JNA Wrapper for library <b>ClAmfClient</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface ClAmfClientLibrary extends Library {
	public static final String JNA_LIBRARY_NAME = "ClAmfClient";
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(ClAmfClientLibrary.JNA_LIBRARY_NAME);
	public static final ClAmfClientLibrary INSTANCE = (ClAmfClientLibrary)Native.load(ClAmfClientLibrary.JNA_LIBRARY_NAME, ClAmfClientLibrary.class);
	/**
	 * <i>native declaration : clCpmConfigApi.h</i><br>
	 * enum values
	 */
	public static interface ClCorMoPathQualifierT {
	  /**
 * Signifies that the path is absolute, equivalent to Unix '/'.
 */
    public static final int CL_COR_MO_PATH_ABSOLUTE = 0;     

/**
 * Signifies that the path is relative.
 */
    public static final int CL_COR_MO_PATH_RELATIVE = 1;         

/**
 * Signifies that the path is relative to blade position
 * in the COR hierarchy. equivalent to unix '~'.
 */
    public static final int CL_COR_MO_PATH_RELATIVE_TO_BASE = 2;
 
    public static final int CL_COR_MO_PATH_QUALIFIER_MAX = CL_COR_MO_PATH_RELATIVE_TO_BASE;
	};
	 
	public static interface ClCpmCompProcessRelT {
		/** <i>native declaration : clCpmConfigApi.h:66</i> */
		public static final int CL_CPM_COMP_NONE = 0;
		/** <i>native declaration : clCpmConfigApi.h:71</i> */
		public static final int CL_CPM_COMP_MULTI_PROCESS = 1;
		/** <i>native declaration : clCpmConfigApi.h:76</i> */
		public static final int CL_CPM_COMP_SINGLE_PROCESS = 2;
		/** <i>native declaration : clCpmConfigApi.h:82</i> */
		public static final int CL_CPM_COMP_THREADED = 3;
	};
	/**
	 * <i>native declaration : clAmsTypes.h</i><br>
	 * enum values
	 */
	public static interface ClAmsMgmtStateT {
		/** <i>native declaration : clAmsTypes.h:15</i> */
		public static final int CL_AMS_MGMT_STATE_NONE = 0;
		/** <i>native declaration : clAmsTypes.h:16</i> */
		public static final int CL_AMS_MGMT_STATE_DISABLED = 1;
		/** <i>native declaration : clAmsTypes.h:17</i> */
		public static final int CL_AMS_MGMT_STATE_ENABLED = 2;
	};
	/**
	 * <i>native declaration : clAmsTypes.h</i><br>
	 * enum values
	 */
	public static interface ClAmsAdminStateT {
		/** <i>native declaration : clAmsTypes.h:29</i> */
		public static final int CL_AMS_ADMIN_STATE_NONE = 0;
		/** <i>native declaration : clAmsTypes.h:30</i> */
		public static final int CL_AMS_ADMIN_STATE_UNLOCKED = 1;
		/** <i>native declaration : clAmsTypes.h:31</i> */
		public static final int CL_AMS_ADMIN_STATE_LOCKED_A = 2;
		/** <i>native declaration : clAmsTypes.h:32</i> */
		public static final int CL_AMS_ADMIN_STATE_LOCKED_I = 3;
		/** <i>native declaration : clAmsTypes.h:33</i> */
		public static final int CL_AMS_ADMIN_STATE_SHUTTINGDOWN = 4;
		/** <i>native declaration : clAmsTypes.h:34</i> */
		public static final int CL_AMS_ADMIN_STATE_MAX = 5;
	};
	/**
	 * <i>native declaration : clAmsTypes.h</i><br>
	 * enum values
	 */
	public static interface ClAmsPresenceStateT {
		/** <i>native declaration : clAmsTypes.h:45</i> */
		public static final int CL_AMS_PRESENCE_STATE_NONE = 0;
		/** <i>native declaration : clAmsTypes.h:46</i> */
		public static final int CL_AMS_PRESENCE_STATE_UNINSTANTIATED = 1;
		/** <i>native declaration : clAmsTypes.h:47</i> */
		public static final int CL_AMS_PRESENCE_STATE_INSTANTIATING = 2;
		/** <i>native declaration : clAmsTypes.h:48</i> */
		public static final int CL_AMS_PRESENCE_STATE_INSTANTIATED = 3;
		/** <i>native declaration : clAmsTypes.h:49</i> */
		public static final int CL_AMS_PRESENCE_STATE_TERMINATING = 4;
		/** <i>native declaration : clAmsTypes.h:50</i> */
		public static final int CL_AMS_PRESENCE_STATE_RESTARTING = 5;
		/** <i>native declaration : clAmsTypes.h:51</i> */
		public static final int CL_AMS_PRESENCE_STATE_INSTANTIATION_FAILED = 6;
		/** <i>native declaration : clAmsTypes.h:52</i> */
		public static final int CL_AMS_PRESENCE_STATE_TERMINATION_FAILED = 7;
		/** <i>native declaration : clAmsTypes.h:56</i> */
		public static final int CL_AMS_PRESENCE_STATE_ABSENT = 0;
		/** <i>native declaration : clAmsTypes.h:57</i> */
		public static final int CL_AMS_PRESENCE_STATE_FAULT = 8;
		/** <i>native declaration : clAmsTypes.h:58</i> */
		public static final int CL_AMS_PRESENCE_STATE_FAULT_WTC = 9;
		/** <i>native declaration : clAmsTypes.h:59</i> */
		public static final int CL_AMS_PRESENCE_STATE_FAULT_WTR = 10;
	};
	/**
	 * <i>native declaration : clAmsTypes.h</i><br>
	 * enum values
	 */
	public static interface ClAmsOperStateT {
		/** <i>native declaration : clAmsTypes.h:69</i> */
		public static final int CL_AMS_OPER_STATE_NONE = 0;
		/** <i>native declaration : clAmsTypes.h:70</i> */
		public static final int CL_AMS_OPER_STATE_ENABLED = 1;
		/** <i>native declaration : clAmsTypes.h:71</i> */
		public static final int CL_AMS_OPER_STATE_DISABLED = 2;
	};
	/**
	 * <i>native declaration : clAmsTypes.h</i><br>
	 * enum values
	 */
	public static interface ClAmsHAStateT {
		/** <i>native declaration : clAmsTypes.h:81</i> */
		public static final int CL_AMS_HA_STATE_NONE = 0;
		/** <i>native declaration : clAmsTypes.h:82</i> */
		public static final int CL_AMS_HA_STATE_ACTIVE = 1;
		/** <i>native declaration : clAmsTypes.h:83</i> */
		public static final int CL_AMS_HA_STATE_STANDBY = 2;
		/** <i>native declaration : clAmsTypes.h:84</i> */
		public static final int CL_AMS_HA_STATE_QUIESCED = 3;
		/** <i>native declaration : clAmsTypes.h:85</i> */
		public static final int CL_AMS_HA_STATE_QUIESCING = 4;
	};
	/**
	 * <i>native declaration : clAmsTypes.h</i><br>
	 * enum values
	 */
	public static interface ClAmsReadinessStateT {
		/** <i>native declaration : clAmsTypes.h:96</i> */
		public static final int CL_AMS_READINESS_STATE_NONE = 0;
		/** <i>native declaration : clAmsTypes.h:97</i> */
		public static final int CL_AMS_READINESS_STATE_OUTOFSERVICE = 1;
		/** <i>native declaration : clAmsTypes.h:98</i> */
		public static final int CL_AMS_READINESS_STATE_INSERVICE = 2;
		/** <i>native declaration : clAmsTypes.h:99</i> */
		public static final int CL_AMS_READINESS_STATE_STOPPING = 3;
	};
	/**
	 * <i>native declaration : clAmsTypes.h</i><br>
	 * enum values
	 */
	public static interface ClAmsServiceStateT {
		/** <i>native declaration : clAmsTypes.h:109</i> */
		public static final int CL_AMS_SERVICE_STATE_NONE = 0;
		/** <i>native declaration : clAmsTypes.h:110</i> */
		public static final int CL_AMS_SERVICE_STATE_RUNNING = 1;
		/** <i>native declaration : clAmsTypes.h:111</i> */
		public static final int CL_AMS_SERVICE_STATE_STOPPED = 2;
		/** <i>native declaration : clAmsTypes.h:112</i> */
		public static final int CL_AMS_SERVICE_STATE_STARTINGUP = 3;
		/** <i>native declaration : clAmsTypes.h:113</i> */
		public static final int CL_AMS_SERVICE_STATE_SHUTTINGDOWN = 4;
		/** <i>native declaration : clAmsTypes.h:114</i> */
		public static final int CL_AMS_SERVICE_STATE_UNAVAILABLE = 5;
		/** <i>native declaration : clAmsTypes.h:115</i> */
		public static final int CL_AMS_SERVICE_STATE_HOT_STANDBY = 6;
	};
	/**
	 * <i>native declaration : clAmsTypes.h</i><br>
	 * enum values
	 */
	public static interface ClAmsNodeClassT {
		/** <i>native declaration : clAmsTypes.h:129</i> */
		public static final int CL_AMS_NODE_CLASS_NONE = 0;
		/** <i>native declaration : clAmsTypes.h:130</i> */
		public static final int CL_AMS_NODE_CLASS_A = 1;
		/** <i>native declaration : clAmsTypes.h:131</i> */
		public static final int CL_AMS_NODE_CLASS_B = 2;
		/** <i>native declaration : clAmsTypes.h:132</i> */
		public static final int CL_AMS_NODE_CLASS_C = 3;
		/** <i>native declaration : clAmsTypes.h:133</i> */
		public static final int CL_AMS_NODE_CLASS_D = 4;
		/** <i>native declaration : clAmsTypes.h:134</i> */
		public static final int CL_AMS_NODE_CLASS_MAX = 5;
	};
	/**
	 * <i>native declaration : clAmsTypes.h</i><br>
	 * enum values
	 */
	public static interface ClAmsNodeClusterMemberT {
		/** <i>native declaration : clAmsTypes.h:143</i> */
		public static final int CL_AMS_NODE_IS_NOT_CLUSTER_MEMBER = 0;
		/** <i>native declaration : clAmsTypes.h:144</i> */
		public static final int CL_AMS_NODE_IS_CLUSTER_MEMBER = 1;
		/** <i>native declaration : clAmsTypes.h:145</i> */
		public static final int CL_AMS_NODE_IS_LEAVING_CLUSTER = 2;
	};
	/**
	 * <i>native declaration : clAmsTypes.h</i><br>
	 * enum values
	 */
	public static interface ClAmsSGRedundancyModelT {
		/** <i>native declaration : clAmsTypes.h:164</i> */
		public static final int CL_AMS_SG_REDUNDANCY_MODEL_NONE = 0;
		/** <i>native declaration : clAmsTypes.h:165</i> */
		public static final int CL_AMS_SG_REDUNDANCY_MODEL_NO_REDUNDANCY = 1;
		/** <i>native declaration : clAmsTypes.h:166</i> */
		public static final int CL_AMS_SG_REDUNDANCY_MODEL_TWO_N = 2;
		/** <i>native declaration : clAmsTypes.h:167</i> */
		public static final int CL_AMS_SG_REDUNDANCY_MODEL_M_PLUS_N = 3;
		/** <i>native declaration : clAmsTypes.h:168</i> */
		public static final int CL_AMS_SG_REDUNDANCY_MODEL_N_WAY = 4;
		/** <i>native declaration : clAmsTypes.h:169</i> */
		public static final int CL_AMS_SG_REDUNDANCY_MODEL_N_WAY_ACTIVE = 5;
		/**
		 * user controlled redundancy mode<br>
		 * <i>native declaration : clAmsTypes.h:170</i>
		 */
		public static final int CL_AMS_SG_REDUNDANCY_MODEL_CUSTOM = 6;
		/** <i>native declaration : clAmsTypes.h:171</i> */
		public static final int CL_AMS_SG_REDUNDANCY_MODEL_MAX = 7;
	};
	/**
	 * <i>native declaration : clAmsTypes.h</i><br>
	 * enum values
	 */
	public static interface ClAmsSGLoadingStrategyT {
		/**
		 * invalid<br>
		 * <i>native declaration : clAmsTypes.h:219</i>
		 */
		public static final int CL_AMS_SG_LOADING_STRATEGY_NONE = 0;
		/**
		 * all models<br>
		 * <i>native declaration : clAmsTypes.h:220</i>
		 */
		public static final int CL_AMS_SG_LOADING_STRATEGY_LEAST_SI_PER_SU = 1;
		/**
		 * all models<br>
		 * <i>native declaration : clAmsTypes.h:221</i>
		 */
		public static final int CL_AMS_SG_LOADING_STRATEGY_LEAST_SU_ASSIGNED = 2;
		/**
		 * all models<br>
		 * <i>native declaration : clAmsTypes.h:222</i>
		 */
		public static final int CL_AMS_SG_LOADING_STRATEGY_LEAST_LOAD_PER_SU = 3;
		/**
		 * n-way-* only<br>
		 * <i>native declaration : clAmsTypes.h:223</i>
		 */
		public static final int CL_AMS_SG_LOADING_STRATEGY_BY_SI_PREFERENCE = 4;
		/**
		 * user-callout<br>
		 * <i>native declaration : clAmsTypes.h:224</i>
		 */
		public static final int CL_AMS_SG_LOADING_STRATEGY_USER_DEFINED = 5;
		/** <i>native declaration : clAmsTypes.h:225</i> */
		public static final int CL_AMS_SG_LOADING_STRATEGY_MAX = 6;
	};
	/**
	 * <i>native declaration : clAmsTypes.h</i><br>
	 * enum values
	 */
	public static interface ClAmsCompCapModelT {
		/** <i>native declaration : clAmsTypes.h:239</i> */
		public static final int CL_AMS_COMP_CAP_X_ACTIVE_AND_Y_STANDBY = 1;
		/** <i>native declaration : clAmsTypes.h:240</i> */
		public static final int CL_AMS_COMP_CAP_X_ACTIVE_OR_Y_STANDBY = 2;
		/** <i>native declaration : clAmsTypes.h:241</i> */
		public static final int CL_AMS_COMP_CAP_ONE_ACTIVE_OR_X_STANDBY = 3;
		/** <i>native declaration : clAmsTypes.h:242</i> */
		public static final int CL_AMS_COMP_CAP_ONE_ACTIVE_OR_ONE_STANDBY = 4;
		/** <i>native declaration : clAmsTypes.h:243</i> */
		public static final int CL_AMS_COMP_CAP_X_ACTIVE = 5;
		/** <i>native declaration : clAmsTypes.h:244</i> */
		public static final int CL_AMS_COMP_CAP_ONE_ACTIVE = 6;
		/** <i>native declaration : clAmsTypes.h:245</i> */
		public static final int CL_AMS_COMP_CAP_NON_PREINSTANTIABLE = 7;
		/** <i>native declaration : clAmsTypes.h:246</i> */
		public static final int CL_AMS_COMP_CAP_MAX = 8;
	};
	/**
	 * <i>native declaration : clAmsTypes.h</i><br>
	 * enum values
	 */
	public static interface ClAmsCompPropertyT {
		/** <i>native declaration : clAmsTypes.h:263</i> */
		public static final int CL_AMS_COMP_PROPERTY_SA_AWARE = 1;
		/** <i>native declaration : clAmsTypes.h:264</i> */
		public static final int CL_AMS_COMP_PROPERTY_PROXIED_PREINSTANTIABLE = 2;
		/** <i>native declaration : clAmsTypes.h:265</i> */
		public static final int CL_AMS_COMP_PROPERTY_PROXIED_NON_PREINSTANTIABLE = 3;
		/** <i>native declaration : clAmsTypes.h:266</i> */
		public static final int CL_AMS_COMP_PROPERTY_NON_PROXIED_NON_PREINSTANTIABLE = 4;
		/** <i>native declaration : clAmsTypes.h:267</i> */
		public static final int CL_AMS_COMP_PROPERTY_MAX = 5;
	};
	/**
	 * <i>native declaration : clAmsTypes.h</i><br>
	 * enum values
	 */
	public static interface ClAmsCompHealthcheckInvocationT {
		/** <i>native declaration : clAmsTypes.h:276</i> */
		public static final int CL_AMS_COMP_HEALTHCHECK_AMF_INVOKED = 1;
		/** <i>native declaration : clAmsTypes.h:277</i> */
		public static final int CL_AMS_COMP_HEALTHCHECK_CLIENT_INVOKED = 2;
	};
	/**
	 * <i>native declaration : clAmsTypes.h</i><br>
	 * enum values
	 */
	public static interface ClAmsRecoveryT {
		/** <i>native declaration : clAmsTypes.h:293</i> */
		public static final int CL_AMS_RECOVERY_NONE = 0;
		/** <i>native declaration : clAmsTypes.h:294</i> */
		public static final int CL_AMS_RECOVERY_NO_RECOMMENDATION = 1;
		/** <i>native declaration : clAmsTypes.h:295</i> */
		public static final int CL_AMS_RECOVERY_COMP_RESTART = 2;
		/** <i>native declaration : clAmsTypes.h:296</i> */
		public static final int CL_AMS_RECOVERY_COMP_FAILOVER = 3;
		/** <i>native declaration : clAmsTypes.h:297</i> */
		public static final int CL_AMS_RECOVERY_NODE_SWITCHOVER = 4;
		/** <i>native declaration : clAmsTypes.h:298</i> */
		public static final int CL_AMS_RECOVERY_NODE_FAILOVER = 5;
		/** <i>native declaration : clAmsTypes.h:299</i> */
		public static final int CL_AMS_RECOVERY_NODE_FAILFAST = 6;
		/** <i>native declaration : clAmsTypes.h:300</i> */
		public static final int CL_AMS_RECOVERY_CLUSTER_RESET = 7;
		/** <i>native declaration : clAmsTypes.h:301</i> */
		public static final int CL_AMS_RECOVERY_APP_RESTART = 8;
		/** <i>native declaration : clAmsTypes.h:307</i> */
		public static final int CL_AMS_RECOVERY_INTERNALLY_RECOVERED = 20;
		/** <i>native declaration : clAmsTypes.h:308</i> */
		public static final int CL_AMS_RECOVERY_SU_RESTART = 21;
		/** <i>native declaration : clAmsTypes.h:309</i> */
		public static final int CL_AMS_RECOVERY_NODE_HALT = 22;
		/** <i>native declaration : clAmsTypes.h:315</i> */
		public static final int CL_AMS_EXTERNAL_RECOVERY_RESET = 30;
		/** <i>native declaration : clAmsTypes.h:316</i> */
		public static final int CL_AMS_EXTERNAL_RECOVERY_REBOOT = 31;
		/** <i>native declaration : clAmsTypes.h:317</i> */
		public static final int CL_AMS_EXTERNAL_RECOVERY_POWER_ON = 32;
		/** <i>native declaration : clAmsTypes.h:318</i> */
		public static final int CL_AMS_EXTERNAL_RECOVERY_POWER_OFF = 33;
	};
	/**
	 * <i>native declaration : clAmsTypes.h</i><br>
	 * enum values
	 */
	public static interface ClAmsCSITransitionDescriptorT {
		/** <i>native declaration : clAmsTypes.h:337</i> */
		public static final int CL_AMS_CSI_NEW_ASSIGN = 1;
		/** <i>native declaration : clAmsTypes.h:338</i> */
		public static final int CL_AMS_CSI_QUIESCED = 2;
		/** <i>native declaration : clAmsTypes.h:339</i> */
		public static final int CL_AMS_CSI_NOT_QUIESCED = 3;
		/** <i>native declaration : clAmsTypes.h:340</i> */
		public static final int CL_AMS_CSI_STILL_ACTIVE = 4;
	};
	/**
	 * <i>native declaration : clAmsTypes.h</i><br>
	 * enum values
	 */
	public static interface ClAmsPGTrackFlagT {
		/** <i>native declaration : clAmsTypes.h:399</i> */
		public static final int CL_AMS_PG_TRACK_CURRENT = 1;
		/** <i>native declaration : clAmsTypes.h:400</i> */
		public static final int CL_AMS_PG_TRACK_CHANGES = 2;
		/** <i>native declaration : clAmsTypes.h:401</i> */
		public static final int CL_AMS_PG_TRACK_CHANGES_ONLY = 4;
	};
	/**
	 * <i>native declaration : clAmsTypes.h</i><br>
	 * enum values
	 */
	public static interface ClAmsPGChangeT {
		/** <i>native declaration : clAmsTypes.h:406</i> */
		public static final int CL_AMS_PG_NO_CHANGE = 1;
		/** <i>native declaration : clAmsTypes.h:407</i> */
		public static final int CL_AMS_PG_ADDED = 2;
		/** <i>native declaration : clAmsTypes.h:408</i> */
		public static final int CL_AMS_PG_REMOVED = 3;
		/** <i>native declaration : clAmsTypes.h:409</i> */
		public static final int CL_AMS_PG_STATE_CHANGE = 4;
	};
	/**
	 * <i>native declaration : clCpmApi.h</i><br>
	 * enum values
	 */
	public static interface ClCpmNodeEventT {
		/** <i>native declaration : clCpmApi.h:164</i> */
		public static final int CL_CPM_NODE_ARRIVAL = 0;
		/** <i>native declaration : clCpmApi.h:169</i> */
		public static final int CL_CPM_NODE_DEPARTURE = 1;
		/** <i>native declaration : clCpmApi.h:174</i> */
		public static final int CL_CPM_NODE_DEATH = 2;
	};
	/**
	 * <i>native declaration : clCpmApi.h</i><br>
	 * enum values
	 */
	public static interface ClCpmCompEventT {
		/** <i>native declaration : clCpmApi.h:187</i> */
		public static final int CL_CPM_COMP_ARRIVAL = 0;
		/** <i>native declaration : clCpmApi.h:191</i> */
		public static final int CL_CPM_COMP_DEPARTURE = 1;
		/** <i>native declaration : clCpmApi.h:196</i> */
		public static final int CL_CPM_COMP_DEATH = 2;
	};
	/**
	 * <i>native declaration : clCpmExtApi.h</i><br>
	 * enum values
	 */
	public static interface ClCpmSlotInfoFieldIdT {
		/** <i>native declaration : clCpmExtApi.h:41</i> */
		public static final int CL_CPM_SLOT_ID = 0;
		/** <i>native declaration : clCpmExtApi.h:46</i> */
		public static final int CL_CPM_IOC_ADDRESS = 1;
		/** <i>native declaration : clCpmExtApi.h:52</i> */
		public static final int CL_CPM_NODE_MOID = 2;
		/** <i>native declaration : clCpmExtApi.h:57</i> */
		public static final int CL_CPM_NODENAME = 3;
	};
	/**
	 * <i>native declaration : clCpmExtApi.h</i><br>
	 * enum values
	 */
	public static interface ClCpmEventTypeT {
		/** <i>native declaration : clCpmExtApi.h:104</i> */
		public static final int CL_CPM_COMP_EVENT = 0;
		/** <i>native declaration : clCpmExtApi.h:108</i> */
		public static final int CL_CPM_NODE_EVENT = 1;
	};
	/** <i>native declaration : clCpmConfigApi.h</i> */
	public static final int CL_CPM_DEFAULT_MIN_FREQ = (int)2000;
	/** <i>native declaration : clCpmConfigApi.h</i> */
	public static final int CL_CPM_DEFAULT_MAX_FREQ = (int)32000;
	/** <i>native declaration : clCpmErrors.h</i> */
	public static final int CL_CPM_ERR_OPERATION_NOT_ALLOWED = (int)0x100;
	/** <i>native declaration : clCpmErrors.h</i> */
	public static final int CL_CPM_ERR_EO_UNREACHABLE = (int)0x101;
	/** <i>native declaration : clCpmErrors.h</i> */
	public static final int CL_CPM_ERR_INVALID_ARGUMENTS = (int)0x102;
	/** <i>native declaration : clCpmErrors.h</i> */
	public static final int CL_CPM_ERR_OPERATION_FAILED = (int)0x103;
	/** <i>native declaration : clCpmErrors.h</i> */
	public static final int CL_CPM_ERR_FORWARDING_FAILED = (int)0x104;
	/** <i>native declaration : clCpmErrors.h</i> */
	public static final int CL_CPM_ERR_OPERATION_IN_PROGRESS = (int)0x105;
	/** <i>native declaration : clCpmErrors.h</i> */
	public static final int CL_CPM_ERR_INIT = (int)0x106;
	/** <i>native declaration : clCpmErrors.h</i> */
	public static final int CL_CPM_ERR_BAD_OPERATION = (int)0x107;
	/** <i>native declaration : clCpmErrors.h</i> */
	public static final int CL_CPM_ERR_EXIST = (int)0x108;
	/** <i>native declaration : clCpmErrors.h</i> */
	public static final int CL_CPM_ERR_OPER_ABANDONED = (int)0x109;
	/** <i>native declaration : clAmsTypes.h</i> */
	public static final int CL_AMS_HEALTHCHECK_KEY_MAX = (int)32;
	/** <i>native declaration : clAmsTypes.h</i> */
	public static final int CL_AMS_CSI_FLAG_ADD_ONE = (int)0x1;
	/** <i>native declaration : clAmsTypes.h</i> */
	public static final int CL_AMS_CSI_FLAG_TARGET_ONE = (int)0x2;
	/** <i>native declaration : clAmsTypes.h</i> */
	public static final int CL_AMS_CSI_FLAG_TARGET_ALL = (int)0x4;
	/** <i>native declaration : clCpmApi.h</i> */
	public static final char CL_CPM_RELEASE_CODE = (char)'B';
	/** <i>native declaration : clCpmApi.h</i> */
	public static final int CL_CPM_MAJOR_VERSION = (int)0x01;
	/** <i>native declaration : clCpmApi.h</i> */
	public static final int CL_CPM_MINOR_VERSION = (int)0x01;
	/** <i>native declaration : clCpmApi.h</i> */
	public static final String CL_CPM_EVENT_CHANNEL_NAME = (String)"CPM_EVENT_CHANNEL";
	/** <i>native declaration : clCpmApi.h</i> */
	public static final String CL_CPM_NODE_EVENT_CHANNEL_NAME = (String)"CPM_NODE_EVENT_CHANNEL";
	/** <i>native declaration : clCpmApi.h</i> */
	public static final int CL_CPM_IOC_SLOT_BITS = (int)16;
	/** <i>native declaration : clCpmApi.h</i> */
	public static final int CL_CPM_IOC_SLOT_BITS_HEX = (int)0x0000ffff;
	/** <i>native declaration : clCpmApi.h</i> */
	public static final int CL_CPM_COMP_ARRIVAL_PATTERN = (int)(1 << 0);
	/** <i>native declaration : clCpmApi.h</i> */
	public static final int CL_CPM_COMP_DEPART_PATTERN = (int)(1 << 1);
	/** <i>native declaration : clCpmApi.h</i> */
	public static final int CL_CPM_COMP_DEATH_PATTERN = (int)(1 << 2);
	/** <i>native declaration : clCpmApi.h</i> */
	public static final int CL_CPM_NODE_ARRIVAL_PATTERN = (int)(1 << 3);
	/** <i>native declaration : clCpmApi.h</i> */
	public static final int CL_CPM_NODE_DEPART_PATTERN = (int)(1 << 4);
	/** <i>native declaration : clCpmApi.h</i> */
	public static final int CL_CPM_NODE_DEATH_PATTERN = (int)(1 << 5);
	/**
	 * \brief Component Manager requests the component, identified by \e<br>
	 * compName, to execute healthcheck using \e healthcheckkey<br>
	 * [Asynchronous Call].<br>
	 * * \param invocation Particular invocation of this callback function.<br>
	 * * \param pCompName Pointer to the name of the component that must<br>
	 * undergo healthcheck.<br>
	 * * \param pHealthCheckKey Key to fetch the healthcheck related<br>
	 * attributes.<br>
	 * <i>native declaration : clCpmApi.h:326</i>
	 */
	/*public interface ClRcT extends Callback {
		ClAmfClientLibrary.ClRcT_callback apply(Pointer ClCpmHealthCheckCallbackT);
	};*/
	/** <i>native declaration : clCpmApi.h</i> */
	
	public interface ClCpmHealthCheckCallbackT extends Callback {
		int apply(long invocation, ClNameT pCompName, ClAmsCompHealthcheckKeyT pHealthcheckKey);
	};
	public interface ClCpmTerminateCallbackT extends Callback {
		int apply(long invocation, Pointer pCompName);
	};
	/** <i>native declaration : clCpmApi.h</i> */
	public interface ClCpmCSISetCallbackT extends Callback {
		int apply(long invocation, Pointer pCompName, int haState, ByValue csiDescriptor);
	};
	/** <i>native declaration : clCpmApi.h</i> */
	public interface ClCpmCSIRmvCallbackT extends Callback {
		int apply(long invocation, Pointer pCompName, Pointer pCsiName, int csiFlags);
	};
	/** <i>native declaration : clCpmApi.h</i> */
	public interface ClCpmProtectionGroupTrackCallbackT extends Callback {
		void apply(Pointer pCsiName, ClAmsPGNotificationBufferT pNotificationBuffer, int numberOfMembers, int error);
	};
	/** <i>native declaration : clCpmApi.h</i> */
	public interface ClCpmProxiedComponentInstantiateCallbackT extends Callback {
		int apply(long invocation, Pointer pProxiedCompName);
	};
	/** <i>native declaration : clCpmApi.h</i> */
	public interface ClCpmProxiedComponentCleanupCallbackT extends Callback {
		int apply(long invocation, Pointer pProxiedCompName);
	};
	/** <i>native declaration : clCpmApi.h</i> */
	public interface ClCpmNotificationFuncT extends Callback {
		void apply(int event, Pointer pArg, Pointer pAddress);
	};
	/** <i>native declaration : clCpmApi.h</i> */
	/*public interface ClRcT_callback extends Callback {
		int apply(long invocation, Pointer pCompName, ClAmsCompHealthcheckKeyT pHealthCheckKey);
	};*/
	/**
	 * ***********************************<br>
	 *  \brief Initializes the client Component Manager library.<br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \param pCpmHandle Handle of the component.<br>
	 *  \param pCallback Callbacks provided by the application to the Component<br>
	 *  Manager.<br>
	 *  \param pVersion Required version number.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER On passing a NULL pointer.<br>
	 *  \par Description:<br>
	 *  Before invoking this API, the EO must be created. This API is used to<br>
	 *  update the EO client table internally based on \e ClCpmCallbacksT.<br>
	 *  It also ensures that the Component Manager client and Server Libraries are<br>
	 *  compatible in version.<br>
	 *  \note<br>
	 *  This API is equivalent to \e saAmfInitialize, which makes a synchronous call.<br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 *  \sa clCpmClientFinalize()<br>
	 * Original signature : <code>ClRcT clCpmClientInitialize(ClCpmHandleT*, const ClCpmCallbacksT*, ClVersionT*)</code><br>
	 * <i>native declaration : clCpmApi.h:536</i><br>
	 * use the safer methods {@link #clCpmClientInitialize(java.nio.LongBuffer, clAmfClient.ClCpmCallbacksT, com.sun.jna.Pointer)} and {@link #clCpmClientInitialize(com.sun.jna.ptr.LongByReference, clAmfClient.ClCpmCallbacksT, com.sun.jna.Pointer)} instead
	 */
	 
	int clCpmClientInitialize(LongByReference pCpmHandle, ClCpmCallbacksT pCallback, Pointer pVersion);
	/**
	 * ***********************************<br>
	 *  \brief Initializes the client Component Manager library.<br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \param pCpmHandle Handle of the component.<br>
	 *  \param pCallback Callbacks provided by the application to the Component<br>
	 *  Manager.<br>
	 *  \param pVersion Required version number.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER On passing a NULL pointer.<br>
	 *  \par Description:<br>
	 *  Before invoking this API, the EO must be created. This API is used to<br>
	 *  update the EO client table internally based on \e ClCpmCallbacksT.<br>
	 *  It also ensures that the Component Manager client and Server Libraries are<br>
	 *  compatible in version.<br>
	 *  \note<br>
	 *  This API is equivalent to \e saAmfInitialize, which makes a synchronous call.<br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 *  \sa clCpmClientFinalize()<br>
	 * Original signature : <code>ClRcT clCpmClientInitialize(ClCpmHandleT*, const ClCpmCallbacksT*, ClVersionT*)</code><br>
	 * <i>native declaration : clCpmApi.h:536</i>
	 */
	//int clCpmClientInitialize(LongBuffer pCpmHandle, ClCpmCallbacksT pCallback, Pointer pVersion);
	/**
	 * ***********************************<br>
	 *  \brief Cleans up the client Component Manager library.<br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \param cpmHandle Handle returned by \e clCpmClientInitialize API.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \par Description:<br>
	 *  This API is used to clean up the client Component Manager library.<br>
	 *  It releases all the resources acquired when clCpmClientInitialize()<br>
	 *  was called. The \e cpmHandle will become invalid after calling<br>
	 *  this API.<br>
	 *  \note<br>
	 *  This API is equivalent to \e saAmfFinalize, which makes an asynchronous call.<br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 *  \sa clCpmClientInitialize()<br>
	 * Original signature : <code>ClRcT clCpmClientFinalize(ClCpmHandleT)</code><br>
	 * <i>native declaration : clCpmApi.h:566</i>
	 */
	int clCpmClientFinalize(long cpmHandle);
	/**
	 * ***********************************<br>
	 *  \brief Returns an operating system handle for detecting<br>
	 *  pending callbacks.<br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \param cpmHandle Handle returned by \e clCpmClientInitialize API.<br>
	 *  \param pSelectionObject A pointer to the operating system handle that the<br>
	 *  process can use to detect pending callbacks<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \par Description:<br>
	 *  This API returns the operating system handle \e pSelectionObject,<br>
	 *  associated with the handle \e cpmHandle. The process can use this operating<br>
	 *  system handle to detect pending callbacks, instead of repeatedly invoking<br>
	 *  clCpmDispatch() for this purpose.<br>
	 *  \par<br>
	 *  The operating system handle returned by this API is a file descriptor<br>
	 *  that is used with poll() or select() systems call detect incoming<br>
	 *  callbacks.<br>
	 *  \par<br>
	 *  The \e pSelectionObject returned by this API is valid until<br>
	 *  clCpmClientFinalize() is invoked on the same handle \e cpmHandle.<br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 *  \sa clCpmClientInitialize(), clCpmDispatch()<br>
	 * Original signature : <code>ClRcT clCpmSelectionObjectGet(ClCpmHandleT, ClSelectionObjectT*)</code><br>
	 * <i>native declaration : clCpmApi.h:601</i><br>
	 * use the safer methods {@link #clCpmSelectionObjectGet(long, java.nio.LongBuffer)} and {@link #clCpmSelectionObjectGet(long, com.sun.jna.ptr.LongByReference)} instead
	 */
	 
	int clCpmSelectionObjectGet(long cpmHandle, LongByReference pSelectionObject);
	/**
	 * ***********************************<br>
	 *  \brief Returns an operating system handle for detecting<br>
	 *  pending callbacks.<br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \param cpmHandle Handle returned by \e clCpmClientInitialize API.<br>
	 *  \param pSelectionObject A pointer to the operating system handle that the<br>
	 *  process can use to detect pending callbacks<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \par Description:<br>
	 *  This API returns the operating system handle \e pSelectionObject,<br>
	 *  associated with the handle \e cpmHandle. The process can use this operating<br>
	 *  system handle to detect pending callbacks, instead of repeatedly invoking<br>
	 *  clCpmDispatch() for this purpose.<br>
	 *  \par<br>
	 *  The operating system handle returned by this API is a file descriptor<br>
	 *  that is used with poll() or select() systems call detect incoming<br>
	 *  callbacks.<br>
	 *  \par<br>
	 *  The \e pSelectionObject returned by this API is valid until<br>
	 *  clCpmClientFinalize() is invoked on the same handle \e cpmHandle.<br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 *  \sa clCpmClientInitialize(), clCpmDispatch()<br>
	 * Original signature : <code>ClRcT clCpmSelectionObjectGet(ClCpmHandleT, ClSelectionObjectT*)</code><br>
	 * <i>native declaration : clCpmApi.h:601</i>
	 */
	//int clCpmSelectionObjectGet(long cpmHandle, LongBuffer pSelectionObject);
	/**
	 * ***********************************<br>
	 *  \brief Invoke pending callbacks.<br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \param cpmHandle Handle returned by \e clCpmClientInitialize API.<br>
	 *  \param dispatchFlags Flags that specify the callback execution behaviour<br>
	 *  of this function<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \par Description:<br>
	 *  This API invokes, in the context of the calling EO, pending callbacks for<br>
	 *  handle \e cpmHandle in a way that is specified by the \e dispatchFlags<br>
	 *  parameter.<br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 *  \sa clCpmClientInitialize(), clCpmSelectionObjectGet()<br>
	 * Original signature : <code>ClRcT clCpmDispatch(ClCpmHandleT, ClDispatchFlagsT)</code><br>
	 * <i>native declaration : clCpmApi.h:629</i>
	 */
	int clCpmDispatch(long cpmHandle, int dispatchFlags);
	/**
	 * ***********************************<br>
	 *  \brief Registers a component with CPM.<br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \param cpmHandle Handle returned by \e clCpmClientInitialize API.<br>
	 *  \param pCompName Name of the component.<br>
	 *  \param pProxyCompName Name of the component, proxy for \e pCompName.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER On passing Null Pointer<br>
	 *  \retval CL_CPM_ERR_INIT If callbacks are provided during the<br>
	 *  initialization is improper.<br>
	 *  \retval CL_CPM_ERR_EXIST If the component has already been registered.<br>
	 *  \par Description:<br>
	 *  This API is used to register a component with CPM. It can also be used<br>
	 *  by a proxy component to register a proxied component. By calling this<br>
	 *  API, the component is indicating that it is up and running and is ready<br>
	 *  to provide service.<br>
	 *  \note<br>
	 *  This API is equivalent to \e saAmfComponentRegister, which makes a<br>
	 *  synchronous call.<br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 *  \sa clCpmComponentUnregister()<br>
	 * Original signature : <code>ClRcT clCpmComponentRegister(ClCpmHandleT, const ClNameT*, const ClNameT*)</code><br>
	 * <i>native declaration : clCpmApi.h:665</i>
	 */
	int clCpmComponentRegister(long cpmHandle, Pointer pCompName, Pointer pProxyCompName);
	/**
	 * ***********************************<br>
	 *  \brief Un-registers a component.<br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \param cpmHandle Handle returned by \e clCpmClientInitialize API.<br>
	 *  \param pCompName Name of the component.<br>
	 *  \param pProxyCompName Name of the component proxied by \e pCompName<br>
	 *  component.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER On passing a NULL pointer.<br>
	 *  \retval CL_CPM_ERR_BAD_OPERATION If the component identified by<br>
	 *  \e pCompName has not unregistered all the proxied components OR<br>
	 *  \e proxyComp is not the proxy for \e pCompName.<br>
	 *  \par Description:<br>
	 *  This API is used for two purposes:<br>
	 *  Either a proxy component can unregister one of its proxied components or<br>
	 *  a component can unregister itself. The \e cpmHandle in this<br>
	 *  API must be same as that used in the corresponding<br>
	 *  clCpmComponentRegister() call.<br>
	 *  \note<br>
	 *  This API is equivalent to \e saAmfComponentUnregister, which makes an<br>
	 *  asynchronous call.<br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 *  \sa clCpmClientInitialize(), clCpmComponentRegister()<br>
	 * Original signature : <code>ClRcT clCpmComponentUnregister(ClCpmHandleT, const ClNameT*, const ClNameT*)</code><br>
	 * <i>native declaration : clCpmApi.h:704</i>
	 */
	int clCpmComponentUnregister(long cpmHandle, Pointer pCompName, Pointer pProxyCompName);
	/**
	 * ***********************************<br>
	 *  \brief Returns the component name.<br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \param cpmHandle Handle returned by \e clCpmClientInitialize API.<br>
	 *  \param pCompName Name of the component.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER On passing a NULL pointer.<br>
	 *  \par Description:<br>
	 *  This API returns the name of the component the calling process belongs to.<br>
	 *  This API can be invoked by the process before its component has been<br>
	 *  registered with the CPM. The component name provided by this API should be<br>
	 *  used by a process when it registers its local component.<br>
	 *  \note<br>
	 *  This API is equivalent to \e saAmfComponentNameGet.<br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 *  \sa clCpmClientInitialize(), clCpmComponentRegister()<br>
	 * Original signature : <code>ClRcT clCpmComponentNameGet(ClCpmHandleT, ClNameT*)</code><br>
	 * <i>native declaration : clCpmApi.h:736</i>
	 */
	int clCpmComponentNameGet(long cpmHandle, ClNameT.ByReference pCompName);
	/**
	 * Original signature : <code>ClRcT clCpmComponentDNNameGet(ClCpmHandleT, ClNameT*, ClNameT*)</code><br>
	 * <i>native declaration : clCpmApi.h:739</i>
	 */
	int clCpmComponentDNNameGet(long cpmHandle, ClNameT.ByReference pCompName, ClNameT.ByReference pDNName);
	/**
	 * ***********************************<br>
	 *  \brief Respond to AMF with the result of components execution of a<br>
	 *         particular request by AMF.<br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \param cpmHandle Handle returned by \e clCpmClientInitialize API.<br>
	 *  \param invocation associates an invocation of this response function<br>
	 *  with a particular invocation of a callback function by the cpm.<br>
	 *  \param rc Status of executing a particular callback of AMF.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \par Description:<br>
	 *  This API is used to respond the success and failure of the callback<br>
	 *  invoked by CPM. Through this API the component responds to the CPM<br>
	 *  with the result of its execution of a particular request of the<br>
	 *  CPM designated by the \e invocation.<br>
	 *  \note<br>
	 *  This API is equivalent to \e saAmfResponse.<br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 *  \sa clCpmClientInitialize(), clCpmComponentRegister()<br>
	 * Original signature : <code>ClRcT clCpmResponse(ClCpmHandleT, ClInvocationT, ClRcT)</code><br>
	 * <i>native declaration : clCpmApi.h:774</i>
	 */
	int clCpmResponse(long cpmHandle, long invocation, int rc);
	/**
	 * ***********************************<br>
	 *  \brief Returns the HA state of the component.<br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \param cpmHandle Handle returned by \e clCpmClientInitialize API.<br>
	 *  \param compName A pointer to the name of the component for which the<br>
	 *  information is requested<br>
	 *  \param csiName A pointer to the name of the component service instance<br>
	 *  for which the information is requested<br>
	 *  \param haState Pointer to the HA state that the AMS is assigning to the<br>
	 *  component, identified by \e compName, on behalf of the component service<br>
	 *  instance, identified by \e csiName.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER on passing the unallocated node Name<br>
	 *  \retval CL_ERR_DOESNT_EXIST CPM library is not able to retrieve the<br>
	 *  nodeName.<br>
	 *  \par Description:<br>
	 *  This API returns the HA state of a component, identified by \e compName,<br>
	 *  on behalf of the component service instance, identified by \e csiName.<br>
	 *  The HA state of the component indicates whether it is currently responsible<br>
	 *  to provide service characterized by the component service instance assigned<br>
	 *  to it, whether it is a standby or whether it is in the quiesced state.<br>
	 *  \par Library Files:<br>
	 *  libClAmfClient<br>
	 *  \sa clCpmClientInitialize()<br>
	 * Original signature : <code>ClRcT clCpmHAStateGet(ClCpmHandleT, ClNameT*, ClNameT*, ClAmsHAStateT*)</code><br>
	 * <i>native declaration : clCpmApi.h:812</i><br>
	 * use the safer methods {@link #clCpmHAStateGet(long, com.sun.jna.Pointer, com.sun.jna.Pointer, java.nio.IntBuffer)} and {@link #clCpmHAStateGet(long, com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference)} instead
	 */
	 
	int clCpmHAStateGet(long cpmHandle, Pointer compName, Pointer csiName, IntByReference haState);
	/**
	 * ***********************************<br>
	 *  \brief Returns the HA state of the component.<br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \param cpmHandle Handle returned by \e clCpmClientInitialize API.<br>
	 *  \param compName A pointer to the name of the component for which the<br>
	 *  information is requested<br>
	 *  \param csiName A pointer to the name of the component service instance<br>
	 *  for which the information is requested<br>
	 *  \param haState Pointer to the HA state that the AMS is assigning to the<br>
	 *  component, identified by \e compName, on behalf of the component service<br>
	 *  instance, identified by \e csiName.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER on passing the unallocated node Name<br>
	 *  \retval CL_ERR_DOESNT_EXIST CPM library is not able to retrieve the<br>
	 *  nodeName.<br>
	 *  \par Description:<br>
	 *  This API returns the HA state of a component, identified by \e compName,<br>
	 *  on behalf of the component service instance, identified by \e csiName.<br>
	 *  The HA state of the component indicates whether it is currently responsible<br>
	 *  to provide service characterized by the component service instance assigned<br>
	 *  to it, whether it is a standby or whether it is in the quiesced state.<br>
	 *  \par Library Files:<br>
	 *  libClAmfClient<br>
	 *  \sa clCpmClientInitialize()<br>
	 * Original signature : <code>ClRcT clCpmHAStateGet(ClCpmHandleT, ClNameT*, ClNameT*, ClAmsHAStateT*)</code><br>
	 * <i>native declaration : clCpmApi.h:812</i>
	 */
	//int clCpmHAStateGet(long cpmHandle, Pointer compName, Pointer csiName, IntBuffer haState);
	/**
	 * ***********************************<br>
	 *  \brief Respond to AMF whether it was able to successfully service<br>
	 *         all pending requests for a particular component service<br>
	 *         instance, following the earlier request by AMF to the component<br>
	 *         to enter the \e CL_AMS_HA_STATE_QUIESCING HA state via the<br>
	 *         components ::ClCpmCSISetCallbackT callback.<br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \param cpmHandle Handle returned by \e clCpmClientInitialize API.<br>
	 *  \param invocation Associates an invocation of this response function<br>
	 *                    with a particular invocation of a callback function<br>
	 *                    by the CPM.<br>
	 *  \param retCode Indicates the status of the quiescing operation.<br>
	 *  <br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \par Description:<br>
	 *  This API is used to respond the success and failure of the<br>
	 *  callback invoked by CPM for the quiescing the HA state of a given<br>
	 *  CSI. Using this call a component can notify the CPM that it has<br>
	 *  successfully stopped its activity related to a particular<br>
	 *  component service instance or to all component service instances<br>
	 *  assigned to it, following a previous request by the AMS to enter<br>
	 *  the \c CL_AMS_HA_STATE_QUIESCING HA state for that particular<br>
	 *  component service instance or to all component service instances.<br>
	 *  \note<br>
	 *  This API is equivalent to \e saAmfCSIQuiescingComplete.<br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 *  \sa clCpmClientInitialize(), clCpmComponentRegister(), clCpmResponse()<br>
	 * Original signature : <code>ClRcT clCpmCSIQuiescingComplete(ClCpmHandleT, ClInvocationT, ClRcT)</code><br>
	 * <i>native declaration : clCpmApi.h:855</i>
	 */
	int clCpmCSIQuiescingComplete(long cpmHandle, long invocation, int retCode);
	/**
	 * ***********************************<br>
	 *  \brief Notifies about the failed component.<br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \param cpmHandle Handle returned by \e clCpmClientInitialize API.<br>
	 *  \param pCompName Pointer to the component name for which the failure is<br>
	 *  notified.<br>
	 *  \param errorDetectionTime Time when the error is detected.<br>
	 *  \param recommendedRecovery Recommonded recovery to be performed using AMF.<br>
	 *  \param alarmHandle This is the key returned by the \e clAlarmRaise function.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER On passing a NULL pointer.<br>
	 *  \par Description:<br>
	 *  This API is used to notify the Component Manager about the failure<br>
	 *  of a component. It reports an error and provides a recovery<br>
	 *  recommendation to the AMF. The AMF will react on the error report<br>
	 *  and carry out a recovery operation to retain the availability of<br>
	 *  component service instances supported by the erroneous<br>
	 *  component. The AMF will not carry out weaker recovery action than<br>
	 *  that recommended by the above API, but it may decide to escalate<br>
	 *  to higher recovery level.<br>
	 *  \note<br>
	 *  This API is equivalent to \e saAmfComponentFailureReport, which makes a<br>
	 *  synchronous call.<br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 *  \sa clCpmClientInitialize(), clCpmComponentFailureClear()<br>
	 * Original signature : <code>ClRcT clCpmComponentFailureReport(ClCpmHandleT, const ClNameT*, ClTimeT, ClAmsLocalRecoveryT, ClUint32T)</code><br>
	 * <i>native declaration : clCpmApi.h:896</i>
	 */
	int clCpmComponentFailureReport(long cpmHandle, Pointer pCompName, long errorDetectionTime, int recommendedRecovery, int alarmHandle);
	/**
	 * ***********************************<br>
	 *  \brief Notifies about the restoration of the failed component.<br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \param cpmHandle Handle returned by \e clCpmClientInitialize API.<br>
	 *  \param pCompName Pointer to the component name for which the failure is<br>
	 *  notified.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER On passing a NULL pointer.<br>
	 *  \par Description:<br>
	 *  This API is used to notify the Component Manager that the failed component<br>
	 *  is restored. It cancels the failure notification made by<br>
	 *  clCpmComponentFailureReport().<br>
	 *  \note<br>
	 *  This API is equivalent to \e saAmfComponentFailureClear, which makes a<br>
	 *  synchronous call.<br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 *  \sa clCpmClientInitialize(), clCpmComponentFailureReport()<br>
	 * Original signature : <code>ClRcT clCpmComponentFailureClear(ClCpmHandleT, ClNameT*)</code><br>
	 * <i>native declaration : clCpmApi.h:932</i>
	 */
	int clCpmComponentFailureClear(long cpmHandle, Pointer pCompName);
	/**
	 * ***********************************<br>
	 *  \brief Starts the component healthcheck.<br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \param cpmHandle Handle returned by \e clCpmClientInitialize API.<br>
	 *  \param pCompName Name of the component.<br>
	 *  \param pCompHealthCheck Key used to fetch healthcheck parameters<br>
	 *  for this component. Not used.<br>
	 *  \param invocationType Indicates whether the AMF should initiate<br>
	 *  the healthcheck or the component itself performs the healthcheck.<br>
	 *  \param recommondedRecovery Recommended recovery to be performed by<br>
	 *  the AMF if the component fails a healthcheck.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER On passing a NULL pointer.<br>
	 *  \retval CL_ERR_INVALID_PARAMETER One of the parameters are invalid.<br>
	 *  \retval CL_ERR_INVALID_HANDLE The passed CPM handle is invalid.<br>
	 *  \par Description:<br>
	 *  This API starts health check of the component \e pCompName. The \e<br>
	 *  invocationType specifies whether this is an AMF invoked<br>
	 *  healthcheck or a component invoked healthcheck. If the \e<br>
	 *  invocationType is CL_AMS_COMP_HEALTHCHECK_AMF_INVOKED, the<br>
	 *  appHealthCheck() callback function must be supplied when calling<br>
	 *  clCpmClientInitialize().<br>
	 *  \note<br>
	 *  This API is equivalent to \e saAmfHealthCheckStart.<br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 *  \sa clCpmClientInitialize(), clCpmHealthcheckConfirm(),<br>
	 *      clCpmHealthcheckStop()<br>
	 * Original signature : <code>ClRcT clCpmHealthcheckStart(ClCpmHandleT, const ClNameT*, const ClAmsCompHealthcheckKeyT*, ClAmsCompHealthcheckInvocationT, ClAmsRecoveryT)</code><br>
	 * <i>native declaration : clCpmApi.h:974</i>
	 */
	int clCpmHealthcheckStart(long cpmHandle, Pointer pCompName, ClAmsCompHealthcheckKeyT pCompHealthCheck, int invocationType, int recommondedRecovery);
	/**
	 * ***********************************<br>
	 *  \brief Inform AMF the status of component invoked healthcheck.<br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \param cpmHandle Handle returned by \e clCpmClientInitialize API.<br>
	 *  \param pCompName Name of the component.<br>
	 *  \param pCompHealthCheck Key used to fetch healthcheck parameters<br>
	 *  for this component. Not used.<br>
	 *  \param healthCheckResult Result of the component invoked healthcheck.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER On passing a NULL pointer.<br>
	 *  \retval CL_ERR_INVALID_HANDLE The passed CPM handle is invalid.<br>
	 *  \par Description:<br>
	 *  This API is used by the component to inform AMF that, it has<br>
	 *  performed a healthcheck on component \e pCompName and whether the<br>
	 *  healthcheck was successful or not using \e healthCheckResult,<br>
	 *  which is the exit status of the healthcheck performed on the<br>
	 *  component.<br>
	 *  \note<br>
	 *  This API is equivalent to \e saAmfHealthCheckConfirm.<br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 *  \sa clCpmClientInitialize(), clCpmHealthcheckStart(), <br>
	 *      clCpmHealthcheckStop()<br>
	 * Original signature : <code>ClRcT clCpmHealthcheckConfirm(ClCpmHandleT, const ClNameT*, const ClAmsCompHealthcheckKeyT*, ClRcT)</code><br>
	 * <i>native declaration : clCpmApi.h:1015</i>
	 */
	int clCpmHealthcheckConfirm(long cpmHandle, Pointer pCompName, ClAmsCompHealthcheckKeyT pCompHealthCheck, int healthCheckResult);
	/**
	 * ***********************************<br>
	 *  \brief Stops the component healthcheck.<br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \param cpmHandle handle returned by \e clCpmClientInitialize API.<br>
	 *  \param pCompName Name of the component for which health-check needs to be<br>
	 *  stopped.<br>
	 *  \param pCompHealthCheck Key used to fetch healthcheck parameters<br>
	 *  for this component. Not used.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER On passing a NULL pointer.<br>
	 *  \retval CL_ERR_INVALID_HANDLE The passed CPM handle is invalid.<br>
	 *  \par Description:<br>
	 *  This API is used to stop the healthcheck of the component \e compName.<br>
	 *  \note<br>
	 *  This API is equivalent to \e saAmfComponentHealthCheckStop.<br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 *  \sa clCpmClientInitialize(), clCpmComponentHealthCheckStart()<br>
	 * Original signature : <code>ClRcT clCpmHealthcheckStop(ClCpmHandleT, const ClNameT*, const ClAmsCompHealthcheckKeyT*)</code><br>
	 * <i>native declaration : clCpmApi.h:1050</i>
	 */
	int clCpmHealthcheckStop(long cpmHandle, Pointer pCompName, ClAmsCompHealthcheckKeyT pCompHealthCheck);
	/**
	 * ***********************************<br>
	 *  \brief Track the protection group for the given CSI.<br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \param cpmHandle Handle returned by \e clCpmClientInitialize API.<br>
	 *  \param pCsiName Pointer to the CSI for which protection group needs to<br>
	 *  be tracked.<br>
	 *  \param trackFlags The kind of tracking that is requested, which is the<br>
	 *  bitwise OR of one or more of the flags \c CL_AMS_PG_TRACK_CURRENT,<br>
	 *  \c CL_AMS_PG_TRACK_CHANGES or \c CL_AMS_PG_TRACK_CHANGES_ONLY.<br>
	 *  \param pNotificationBuffer pointer to a buffer of type<br>
	 *  ClAmsPGNotificationT. This parameter is ignored if \c<br>
	 *  CL_AMS_PG_TRACK_CURRENT is not set in \e trackFlags; otherwise, if<br>
	 *  \e notificationBuffer is not NULL, the buffer will contain<br>
	 *  information about all components in the protection group when<br>
	 *  clCpmProtectionGroupTrack() returns.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER On passing a NULL pointer.<br>
	 *  \par Description:<br>
	 *  This API is used to request the framework to start tracking changes in the<br>
	 *  protection group associated with the component service instance, identified<br>
	 *  by \e csiName, or changes of attributes of any component in the protection<br>
	 *  group. These changes are notified via the invocation of the<br>
	 *  \e ClCpmProtectionGroupTrackCallbackT() callback function, which must have<br>
	 *  been supplied when the process invoked the \e clCpmClientInitialize call.<br>
	 *  \note<br>
	 *  This API is equivalent to \e saAmfProtectionGroupTrack, which makes a<br>
	 *  synchronous call.<br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 *  \sa clCpmClientInitialize(), clCpmProtectionGroupTrackStop()<br>
	 * Original signature : <code>ClRcT clCpmProtectionGroupTrack(ClCpmHandleT, ClNameT*, ClUint8T, ClAmsPGNotificationBufferT*)</code><br>
	 * <i>native declaration : clCpmApi.h:1096</i>
	 */
	int clCpmProtectionGroupTrack(long cpmHandle, Pointer pCsiName, byte trackFlags, ClAmsPGNotificationBufferT pNotificationBuffer);
	/**
	 * ***********************************<br>
	 *  \brief Stop tracking the protection group for the given CSI.<br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \param cpmHandle Handle returned by \e clCpmClientInitialize API.<br>
	 *  \param pCsiName Pointer to the CSI for which protection group needs to<br>
	 *  be tracked.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER On passing a NULL pointer.<br>
	 *  \par Description:<br>
	 *  The invoking process requests the Availability Management Framework to<br>
	 *  stop tracking protection group changes for the component service instance<br>
	 *  designated by \e pCsiName.<br>
	 *  \note<br>
	 *  This API is equivalent to \e saAmfProtectionGroupTrackStop, which makes a<br>
	 *  synchronous call.<br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 *  \sa clCpmClientInitialize(), clCpmProtectionGroupTrack()<br>
	 * Original signature : <code>ClRcT clCpmProtectionGroupTrackStop(ClCpmHandleT, ClNameT*)</code><br>
	 * <i>native declaration : clCpmApi.h:1131</i>
	 */
	int clCpmProtectionGroupTrackStop(long cpmHandle, Pointer pCsiName);
	/**
	 * ***********************************<br>
	 *  \brief Returns the component ID of a component.<br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \param cpmHandle Handle returned by \e clCpmClientInitialize API.<br>
	 *  \param pCompName Name of the component.<br>
	 *  \param pCompId (out) Unique Id of the component.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER On passing a NULL pointer.<br>
	 *  \par Description:<br>
	 *  This API is used to return the component ID for a component identified<br>
	 *  by \e pCompName. This unique component ID is node internal and is not known<br>
	 *  to outside entities. Each time a component is instantiated, a new component<br>
	 *  ID is assigned to it.<br>
	 *  \note This is a synchronous API.<br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 * Original signature : <code>ClRcT clCpmComponentIdGet(ClCpmHandleT, ClNameT*, ClUint32T*)</code><br>
	 * <i>native declaration : clCpmApi.h:1164</i><br>
	 * use the safer methods {@link #clCpmComponentIdGet(long, com.sun.jna.Pointer, java.nio.IntBuffer)} and {@link #clCpmComponentIdGet(long, com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference)} instead
	 */
	 
	int clCpmComponentIdGet(long cpmHandle, Pointer pCompName, IntByReference pCompId);
	/**
	 * ***********************************<br>
	 *  \brief Returns the component ID of a component.<br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \param cpmHandle Handle returned by \e clCpmClientInitialize API.<br>
	 *  \param pCompName Name of the component.<br>
	 *  \param pCompId (out) Unique Id of the component.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER On passing a NULL pointer.<br>
	 *  \par Description:<br>
	 *  This API is used to return the component ID for a component identified<br>
	 *  by \e pCompName. This unique component ID is node internal and is not known<br>
	 *  to outside entities. Each time a component is instantiated, a new component<br>
	 *  ID is assigned to it.<br>
	 *  \note This is a synchronous API.<br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 * Original signature : <code>ClRcT clCpmComponentIdGet(ClCpmHandleT, ClNameT*, ClUint32T*)</code><br>
	 * <i>native declaration : clCpmApi.h:1164</i>
	 */
	//int clCpmComponentIdGet(long cpmHandle, Pointer pCompName, IntBuffer pCompId);
	/**
	 * ***********************************<br>
	 *  \brief Returns the IOC address of a component.<br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \param nodeAddress Node IOC Address.<br>
	 *  \param pCompName Name of the component.<br>
	 *  \param pCompAddress IOC address of the component including port<br>
	 *  information.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER On passing a NULL pointer.<br>
	 *  \par Description:<br>
	 *  This API is used to return the IOC address of a component identified by<br>
	 *  \e pCompName. This represents the physical address of the node where the<br>
	 *  CPM is running.<br>
	 *  \note This is a synchronous API.<br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 *  \sa clCpmComponentStatusGet()<br>
	 * Original signature : <code>ClRcT clCpmComponentAddressGet(ClIocNodeAddressT, ClNameT*, ClIocAddressT*)</code><br>
	 * <i>native declaration : clCpmApi.h:1196</i>
	 */
	int clCpmComponentAddressGet(int nodeAddress, Pointer pCompName, ClIocAddressT.ByReference pCompAddress);
	/**
	 * ***********************************<br>
	 *  \brief Returns the IOC address of a component.<br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \param nodeAddress Node IOC Address.<br>
	 *  \param pCompName Name of the component.<br>
	 *  \param pCompAddress IOC address of the component including port<br>
	 *  information.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER On passing a NULL pointer.<br>
	 *  \par Description:<br>
	 *  This API is used to return the IOC address of a component identified by<br>
	 *  \e pCompName. This represents the physical address of the node where the<br>
	 *  CPM is running.<br>
	 *  \note This is a synchronous API.<br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 *  \sa clCpmComponentStatusGet()<br>
	 * Original signature : <code>ClRcT clCpmComponentAddressGetFast(ClIocNodeAddressT, ClNameT*, ClIocAddressT*)</code><br>
	 * <i>native declaration : clCpmApi.h:1229</i>
	 */
	int clCpmComponentAddressGetFast(int nodeAddress, Pointer pCompName, ClIocAddressT.ByReference pCompAddress);
	/**
	 * ***********************************<br>
	 *  \brief Returns the component presence and operational state.<br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \param pCompName Name of the component.<br>
	 *  \param pNodeName IOC address of the component.<br>
	 *  \param pPresenceState Presence state of the component.<br>
	 *  \param pOperationalState Operational state of the component.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER On passing a NULL pointer.<br>
	 *  \par Description:<br>
	 *  This API is used to return the presence and operational state of a component<br>
	 *  identified by \e pCompName. The presence state of the component reflects the<br>
	 *  component life cycle and the operational state of the component is used by<br>
	 *  the AMF to determine whether a component is capable of taking component<br>
	 *  service instance assignments.<br>
	 *  \note This is a synchronous API.<br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 *  \sa clCpmComponentAddressGet()<br>
	 * Original signature : <code>ClRcT clCpmComponentStatusGet(ClNameT*, ClNameT*, ClAmsPresenceStateT*, ClAmsOperStateT*)</code><br>
	 * <i>native declaration : clCpmApi.h:1263</i><br>
	 * use the safer methods {@link #clCpmComponentStatusGet(com.sun.jna.Pointer, com.sun.jna.Pointer, java.nio.IntBuffer, java.nio.IntBuffer)} and {@link #clCpmComponentStatusGet(com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	 
	int clCpmComponentStatusGet(Pointer pCompName, Pointer pNodeName, IntByReference pPresenceState, IntByReference pOperationalState);
	/**
	 * ***********************************<br>
	 *  \brief Returns the component presence and operational state.<br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \param pCompName Name of the component.<br>
	 *  \param pNodeName IOC address of the component.<br>
	 *  \param pPresenceState Presence state of the component.<br>
	 *  \param pOperationalState Operational state of the component.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER On passing a NULL pointer.<br>
	 *  \par Description:<br>
	 *  This API is used to return the presence and operational state of a component<br>
	 *  identified by \e pCompName. The presence state of the component reflects the<br>
	 *  component life cycle and the operational state of the component is used by<br>
	 *  the AMF to determine whether a component is capable of taking component<br>
	 *  service instance assignments.<br>
	 *  \note This is a synchronous API.<br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 *  \sa clCpmComponentAddressGet()<br>
	 * Original signature : <code>ClRcT clCpmComponentStatusGet(ClNameT*, ClNameT*, ClAmsPresenceStateT*, ClAmsOperStateT*)</code><br>
	 * <i>native declaration : clCpmApi.h:1263</i>
	 */
	//int clCpmComponentStatusGet(Pointer pCompName, Pointer pNodeName, IntBuffer pPresenceState, IntBuffer pOperationalState);
	/**
	 * ***********************************<br>
	 *  \brief Returns the IOC address of the master.<br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \param pIocAddress (out) IOC address of the master.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER On passing a NULL pointer.<br>
	 *  \par Description:<br>
	 *  This API is used to retrieve the IOC address of the master. The<br>
	 *  address returned by this API represents the physical address of<br>
	 *  the node where the CPM/G is running.<br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 *  \sa clCpmIsMaster()<br>
	 * Original signature : <code>ClRcT clCpmMasterAddressGet(ClIocNodeAddressT*)</code><br>
	 * <i>native declaration : clCpmApi.h:1291</i><br>
	 * use the safer methods {@link #clCpmMasterAddressGet(java.nio.IntBuffer)} and {@link #clCpmMasterAddressGet(com.sun.jna.ptr.IntByReference)} instead
	 */
 
	int clCpmMasterAddressGet(IntByReference pIocAddress);
	/**
	 * ***********************************<br>
	 *  \brief Returns the IOC address of the master.<br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \param pIocAddress (out) IOC address of the master.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER On passing a NULL pointer.<br>
	 *  \par Description:<br>
	 *  This API is used to retrieve the IOC address of the master. The<br>
	 *  address returned by this API represents the physical address of<br>
	 *  the node where the CPM/G is running.<br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 *  \sa clCpmIsMaster()<br>
	 * Original signature : <code>ClRcT clCpmMasterAddressGet(ClIocNodeAddressT*)</code><br>
	 * <i>native declaration : clCpmApi.h:1291</i>
	 */
	//int clCpmMasterAddressGet(IntBuffer pIocAddress);
	/**
	 * Original signature : <code>ClRcT clCpmMasterAddressGetExtended(ClIocNodeAddressT*, ClInt32T, ClTimerTimeOutT*)</code><br>
	 * <i>native declaration : clCpmApi.h:1292</i><br>
	 * use the safer methods {@link #clCpmMasterAddressGetExtended(java.nio.IntBuffer, int, com.sun.jna.Pointer)} and {@link #clCpmMasterAddressGetExtended(com.sun.jna.ptr.IntByReference, int, com.sun.jna.Pointer)} instead
	 */
	 
	int clCpmMasterAddressGetExtended(IntByReference pIocAddress, int numRetries, ClTimerTimeOutT pDelay);
	/**
	 * Original signature : <code>ClRcT clCpmMasterAddressGetExtended(ClIocNodeAddressT*, ClInt32T, ClTimerTimeOutT*)</code><br>
	 * <i>native declaration : clCpmApi.h:1292</i>
	 */
	//int clCpmMasterAddressGetExtended(IntBuffer pIocAddress, int numRetries, Pointer pDelay);
	/**
	 * ***********************************<br>
	 *  \brief Informs if the node is master of the cluster.<br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \par Parameters:<br>
	 *  None<br>
	 *  \retval CL_TRUE The node is the master.<br>
	 *  \retval CL_FALSE The node is not the master.<br>
	 *  \par Description:<br>
	 *  This API indicates if the node is master of the cluster. This API<br>
	 *  can be used by the component to determine whether it is running on<br>
	 *  the CPM master (CPM/G (global) or CPM/L (local)).<br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 *  \sa clCpmMasterAddressGet()<br>
	 * Original signature : <code>ClUint32T clCpmIsMaster()</code><br>
	 * <i>native declaration : clCpmApi.h:1320</i>
	 */
	int clCpmIsMaster();
	/**
	 * ***********************************<br>
	 *  \brief Shuts down the node.<br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \param iocNodeAddress IOC address of the node.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \par Description:<br>
	 *  This API is used to shut down the node, which corresponds to the given IOC<br>
	 *  Address. Shutting down the node terminates all the services  running<br>
	 *  on that node.<br>
	 *  \note This is an asynchronous API.<br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 * Original signature : <code>ClRcT clCpmNodeShutDown(ClIocNodeAddressT)</code><br>
	 * <i>native declaration : clCpmApi.h:1344</i>
	 */
	int clCpmNodeShutDown(int iocNodeAddress);
	/**
	 * ***********************************<br>
	 *  \brief Restarts the node<br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \param iocNodeAddress IOC address of the node.<br>
	 *  \param graceful Specifies whether to restart the node gracefully<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \par Description:<br>
	 *  This API is used to restart the node, which corresponds to the<br>
	 *  given IOC Address. If graceful is non zero, then all the<br>
	 *  application components are terminated gracefully running on the<br>
	 *  node. If graceful is zero, applications are abruptly terminated,<br>
	 *  either by killing the applications on the node or rebooting the<br>
	 *  node. The node may or may not be restarted depending on the<br>
	 *  environment variables ASP_NODE_RESTART, ASP_NODE_REBOOT_DISABLE<br>
	 *  and ASP_RESTART_ASP.<br>
	 *  This APIs behavior depends on the environment variables<br>
	 *  ASP_NODE_RESTART, ASP_NODE_REBOOT_DISABLE and ASP_RESTART_ASP,<br>
	 *  documented in the command line and environment variable reference<br>
	 *  section of the SDK guide.<br>
	 *  \note This is an asynchronous API.<br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 * Original signature : <code>ClRcT clCpmNodeRestart(ClIocNodeAddressT, ClBoolT)</code><br>
	 * <i>native declaration : clCpmApi.h:1379</i>
	 */
	int clCpmNodeRestart(int iocNodeAddress, short graceful);
	/**
	 * ***********************************<br>
	 *  \brief Switch over the node.<br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \param iocNodeAddress IOC address of the node.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \par Description:<br>
	 *  This API is used to switch over the node, which corresponds to the<br>
	 *  given IOC Address. All the application components running on the<br>
	 *  node are switched over and terminated gracefully and the node is<br>
	 *  shutdown. The node may or may not be restarted depending on the<br>
	 *  environment variables ASP_NODE_RESTART, ASP_NODE_REBOOT_DISABLE<br>
	 *  and ASP_RESTART_ASP.<br>
	 *  This APIs behavior depends on the environment variables<br>
	 *  ASP_NODE_RESTART, ASP_NODE_REBOOT_DISABLE and ASP_RESTART_ASP,<br>
	 *  documented in the command line and environment variable reference<br>
	 *  section of the SDK guide.<br>
	 *  \note This is an asynchronous API.<br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 * Original signature : <code>ClRcT clCpmNodeSwitchover(ClIocNodeAddressT)</code><br>
	 * <i>native declaration : clCpmApi.h:1413</i>
	 */
	int clCpmNodeSwitchover(int iocNodeAddress);
	/**
	 * This API is the same as clCpmNodeRestart. However with a few differences.<br>
	 * The middleware restart reboots the node or restarts asp if nodeReset flag is CL_FALSE.<br>
	 * It works irrespective of the environment variables that one can use to override the node reset behavior.<br>
	 * If you want to get environment variable behavior for node resets, then clCpmNodeRestart is the API to use.<br>
	 * Original signature : <code>ClRcT clCpmMiddlewareRestart(ClIocNodeAddressT, ClBoolT, ClBoolT)</code><br>
	 * <i>native declaration : clCpmApi.h:1422</i>
	 */
	int clCpmMiddlewareRestart(int iocNodeAddress, short graceful, short nodeReset);
	/**
	 * ***********************************<br>
	 *  \brief Returns the name of the local node.<br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \param nodeName Local node name.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER On passing the unallocated node Name.<br>
	 *  \retval CL_ERR_DOESNT_EXIST CPM library is not able to retrieve the<br>
	 *  \e nodeName.<br>
	 *  \par Description:<br>
	 *  This API provides the local node Name, in the buffer provided by the user.<br>
	 *  This API can be used by a component to determine the name of the node<br>
	 *  on which it is running.<br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 * Original signature : <code>ClRcT clCpmLocalNodeNameGet(ClNameT*)</code><br>
	 * <i>native declaration : clCpmApi.h:1447</i>
	 */
	int clCpmLocalNodeNameGet(ClNameT.ByReference nodeName);
	/**
	 * <i>native declaration : clCpmApi.h:1475</i><br>
	 * Conversion Error : union  ClIocAddress {<br>
	 * 	/** Physical address. * /<br>
	 * 	struct ClIocPhysicalAddress {<br>
	 * 		/** The IOC Node address. * /<br>
	 * 		unsigned int nodeAddress;<br>
	 * 		/** The IOC communication end point identification on a node. * /<br>
	 * 		ClUint32T portId;<br>
	 * 	} iocPhyAddress;<br>
	 * 	/** Logical address. * /<br>
	 * 	unsigned long long iocLogicalAddress;<br>
	 * 	/** Multicast address. * /<br>
	 * 	ClUint64T iocMulticastAddress;<br>
	 * }
	 */
	/**
	 * ***********************************<br>
	 *  \brief Returns the status of any ASP node in a system.<br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \param compAddr The ASP node address, whose status is to be know.<br>
	 *  \param pStatus  The pointer to a variable to hold the status of the component.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \par Description:<br>
	 *  This API should be used to get the status of an ASP node<br>
	 *  in a system. The *pStatus will contain CL_STATUS_UP if that particular ASP<br>
	 *  node is up and CL_STATUS_DOWN if the node is down.<br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 * Original signature : <code>ClRcT clCpmNodeStatusGet(ClIocNodeAddressT, ClStatusT*)</code><br>
	 * <i>native declaration : clCpmApi.h:1499</i><br>
	 * use the safer methods {@link #clCpmNodeStatusGet(int, java.nio.IntBuffer)} and {@link #clCpmNodeStatusGet(int, com.sun.jna.ptr.IntByReference)} instead
	 */
	 
	int clCpmNodeStatusGet(int nodeAddr, IntByReference pStatus);
	/**
	 * ***********************************<br>
	 *  \brief Returns the status of any ASP node in a system.<br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \param compAddr The ASP node address, whose status is to be know.<br>
	 *  \param pStatus  The pointer to a variable to hold the status of the component.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \par Description:<br>
	 *  This API should be used to get the status of an ASP node<br>
	 *  in a system. The *pStatus will contain CL_STATUS_UP if that particular ASP<br>
	 *  node is up and CL_STATUS_DOWN if the node is down.<br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 * Original signature : <code>ClRcT clCpmNodeStatusGet(ClIocNodeAddressT, ClStatusT*)</code><br>
	 * <i>native declaration : clCpmApi.h:1499</i>
	 */
	//int clCpmNodeStatusGet(int nodeAddr, IntBuffer pStatus);
	/**
	 * <i>native declaration : clCpmApi.h:1532</i><br>
	 * Conversion Error : struct ClIocPhysicalAddress {<br>
	 * 	/** The IOC Node address. * /<br>
	 * 	unsigned int nodeAddress;<br>
	 * 	/** The IOC communication end point identification on a node. * /<br>
	 * 	ClUint32T portId;<br>
	 * }
	 */
	/**
	 * ***********************************<br>
	 *  \brief The API uninstalls the callback, which would have been installed<br>
	 *  through the \e clCpmNotificationCallbackInstall API.<br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \param pHandle The handle for unistalling the callback, returned by<br>
	 *  \e clCpmNotificationCallbackInstall API.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \par Description:<br>
	 *  This API should be used, when the callback installed through<br>
	 *  \e clCpmNotificationCallbackInstall API, is to be uninstalled. The handle<br>
	 *  passed to this API should be the correct one as this API doent do any<br>
	 *  kind of verification on the handle.<br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 * Original signature : <code>ClRcT clCpmNotificationCallbackUninstall(ClHandleT*)</code><br>
	 * <i>native declaration : clCpmApi.h:1559</i><br>
	 * use the safer methods {@link #clCpmNotificationCallbackUninstall(java.nio.LongBuffer)} and {@link #clCpmNotificationCallbackUninstall(com.sun.jna.ptr.LongByReference)} instead
	 */
	 
	int clCpmNotificationCallbackUninstall(LongByReference pHandle);
	/**
	 * ***********************************<br>
	 *  \brief The API uninstalls the callback, which would have been installed<br>
	 *  through the \e clCpmNotificationCallbackInstall API.<br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \param pHandle The handle for unistalling the callback, returned by<br>
	 *  \e clCpmNotificationCallbackInstall API.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \par Description:<br>
	 *  This API should be used, when the callback installed through<br>
	 *  \e clCpmNotificationCallbackInstall API, is to be uninstalled. The handle<br>
	 *  passed to this API should be the correct one as this API doent do any<br>
	 *  kind of verification on the handle.<br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 * Original signature : <code>ClRcT clCpmNotificationCallbackUninstall(ClHandleT*)</code><br>
	 * <i>native declaration : clCpmApi.h:1559</i>
	 */
	//int clCpmNotificationCallbackUninstall(LongBuffer pHandle);
	/**
	 * ***********************************<br>
	 *  \brief The API gets the comp CSI List from the component CSI cache<br>
	 *  maintained per-process.<br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \param pCompName Name of the component to query to obtain the CSI list<br>
	 *  \param pCSIRef   List of CSI references cached for the component <br>
	 *  is returned through this variable<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_INVALID_PARAMETER The API was invoked with invalid arguments<br>
	 *  \par Description:<br>
	 *  This API should be used to obtain the cached CSI list for a component<br>
	 *  The csi list is returned through the pCSIRef argument. The API returns<br>
	 *  the cached haState and the csiDescriptor for the component for each CSI. <br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 * Original signature : <code>ClRcT clCpmCompCSIList(const ClNameT*, ClCpmCompCSIRefT*)</code><br>
	 * <i>native declaration : clCpmApi.h:1586</i>
	 */
	int clCpmCompCSIList(Pointer pCompName, ClCpmCompCSIRef.ByReference pCSIRef);
	/**
	 * ***********************************<br>
	 *  \brief The API returns whether this node is system controller or not.<br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \retval CL_YES If the current node is system controller.<br>
	 *  \retval CL_NO If the current node is not system controller<br>
	 *  (i.e. it is a payload node) or the application calling this API is<br>
	 *  running out side of AMF for e.g. using safplus_run script.<br>
	 *  \par Description:<br>
	 *  This API should be used by the application to check if the node on<br>
	 *  which it is running is system controller.<br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 * Original signature : <code>ClBoolT clCpmIsSC()</code><br>
	 * <i>native declaration : clCpmApi.h:1608</i>
	 */
	short clCpmIsSC();
	/**
	 * ***********************************<br>
	 *  \brief The API returns component specific information.<br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_INVALID_PARAMETER The API was invoked with invalid arguments.<br>
	 *  \retval CL_ERR_NO_MEMORY Not enough memory to complete the request.<br>
	 *  \par Description:<br>
	 *  This API should be used by the application to fetch any component specific<br>
	 *  information maintained by CPM.<br>
	 *  \note This API allocates a array of pointers as well as memory for<br>
	 *  each of the components argument for \arg args. It is the<br>
	 *  responsibility of the user to free the memory allocated by this<br>
	 *  API.<br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 * Original signature : <code>ClRcT clCpmCompInfoGet(const ClNameT*, const ClIocNodeAddressT, ClCpmCompSpecInfoT*)</code><br>
	 * <i>native declaration : clCpmApi.h:1634</i>
	 */
	int clCpmCompInfoGet(Pointer compName, int nodeAddress, ClCpmCompSpecInfo.ByReference compInfo);
	/**
	 * ***********************************<br>
	 *  \brief Extracts the event payload data.<br>
	 * <br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \param eventHandle Event handle.<br>
	 *  \param eventDataSize Size of the event data.<br>
	 *  \param cpmEventType Type of the event published.<br>
	 *  \param payLoad (out) The actual payload.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER On passing a NULL pointer.<br>
	 * <br>
	 *  \par Description:<br>
	 *  This API extracts the payload data from the flat buffer returned by<br>
	 *  the event delivery callback for the events published by the CPM. The<br>
	 *  \e eventHandle and \e eventDataSize are the parameters obtained from <br>
	 *  event delivery callback.<br>
	 *  This API must be called only in the event subscriber's context of event <br>
	 *  delivery callback, which is invoked when the event is published by the <br>
	 *  CPM.<br>
	 * <br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 * Original signature : <code>ClRcT clCpmEventPayLoadExtract(ClEventHandleT, ClSizeT, ClCpmEventTypeT, void*)</code><br>
	 * <i>native declaration : clCpmExtApi.h:139</i>
	 */
	int clCpmEventPayLoadExtract(long eventHandle, long eventDataSize, int cpmEventType, Pointer payLoad);
	/**
	 * ***********************************<br>
	 *  \brief Returns the process ID of the component.<br>
	 * <br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \param compName Name of the component.<br>
	 *  \param[out] pid Process ID of the component.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER On passing a NULL pointer.<br>
	 *  \retval CL_ERR_NOT_EXIST On passing invalid component name.<br>
	 * <br>
	 *  \par Description:<br>
	 *  This API returns the process id \e pid of the component \e compName.<br>
	 * <br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 * Original signature : <code>ClRcT clCpmComponentPIDGet(const ClNameT*, ClUint32T*)</code><br>
	 * <i>native declaration : clCpmExtApi.h:165</i><br>
	 * use the safer methods {@link #clCpmComponentPIDGet(com.sun.jna.Pointer, java.nio.IntBuffer)} and {@link #clCpmComponentPIDGet(com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference)} instead
	 */
	 
	int clCpmComponentPIDGet(Pointer compName, IntByReference pid);
	/**
	 * ***********************************<br>
	 *  \brief Returns the process ID of the component.<br>
	 * <br>
	 *  \par Header File:<br>
	 *  clCpmApi.h<br>
	 *  \param compName Name of the component.<br>
	 *  \param[out] pid Process ID of the component.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_NULL_POINTER On passing a NULL pointer.<br>
	 *  \retval CL_ERR_NOT_EXIST On passing invalid component name.<br>
	 * <br>
	 *  \par Description:<br>
	 *  This API returns the process id \e pid of the component \e compName.<br>
	 * <br>
	 *  \par Library Files:<br>
	 *  ClAmfClient<br>
	 * Original signature : <code>ClRcT clCpmComponentPIDGet(const ClNameT*, ClUint32T*)</code><br>
	 * <i>native declaration : clCpmExtApi.h:165</i>
	 */
	//int clCpmComponentPIDGet(Pointer compName, IntBuffer pid);
	/**
	 * Original signature : <code>ClRcT clCpmComponentPIDGetBySlot(ClIocNodeAddressT, const ClNameT*, ClUint32T*)</code><br>
	 * <i>native declaration : clCpmExtApi.h:168</i><br>
	 * use the safer methods {@link #clCpmComponentPIDGetBySlot(int, com.sun.jna.Pointer, java.nio.IntBuffer)} and {@link #clCpmComponentPIDGetBySlot(int, com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference)} instead
	 */
	 
	int clCpmComponentPIDGetBySlot(int slot, Pointer compName, IntByReference pid);
	/**
	 * Original signature : <code>ClRcT clCpmComponentPIDGetBySlot(ClIocNodeAddressT, const ClNameT*, ClUint32T*)</code><br>
	 * <i>native declaration : clCpmExtApi.h:168</i>
	 */
	//int clCpmComponentPIDGetBySlot(int slot, Pointer compName, IntBuffer pid);
	/**
	 * CM requirement.<br>
	 * Single function which returns the consolidated information<br>
	 * about the slot.<br>
	 * Original signature : <code>ClRcT clCpmSlotInfoGet(ClCpmSlotInfoFieldIdT, ClCpmSlotInfoT*)</code><br>
	 * <i>native declaration : clCpmExtApi.h:211</i>
	 */
	int clCpmSlotInfoGet(int flag, ClCpmSlotInfoT.ByReference slotInfo);
	/**
	 * ***********************************<br>
	 *  \brief  Returns the Slot related information<br>
	 *          [ nodeName and IocAddress], provides the mapping<br>
	 *          between slot ID, IOC address,and name of the given node<br>
	 *          depending on the flag that is passed to it.<br>
	 * <br>
	 *  \par Header File:<br>
	 *  clCpmExtApi.h<br>
	 *  \param flag The flag which indicates that which field of the structure<br>
	 *  \e slotInfo is filled in by the user.<br>
	 *  \param slotInfo The structure which will get filled by this API and will<br>
	 *  contain other information about node corresponding to the field which was <br>
	 *  filled by the user.<br>
	 *  \retval CL_OK The API executed successfully.<br>
	 *  \retval CL_ERR_INVALID_PARAMETER On passing the invalid flag or passing <br>
	 *  invalid value in any of the fields.<br>
	 * <br>
	 *  \par Description:<br>
	 *  This API provides mapping between the attributes which are unique to node<br>
	 *  namely, slot ID, IOC address and node name. Depending on the flag<br>
	 *  which is given by the user, this API assumes that the corresponding field<br>
	 *  has been given a proper value by the user and fills the remaining fields <br>
	 *  of the structure corresponding to the information in this field. For example<br>
	 *  suppose the user wants to know the nodename given the slot ID, then he should<br>
	 *  pass the flag CL_CPM_SLOT_NODENAME (which are exposed in clCpmApi.h) and set the<br>
	 *  \e slotId field of \e slotInfo structure to some valid slot number.<br>
	 * <br>
	 *  \par Library Files:<br>
	 *  libClAmfClient<br>
	 * Original signature : <code>ClRcT clCpmSlotGet(ClCpmSlotInfoFieldIdT, ClCpmSlotInfoT*)</code><br>
	 * <i>native declaration : clCpmExtApi.h:250</i>
	 */
	int clCpmSlotGet(int flag, ClCpmSlotInfoT.ByReference slotInfo);
	/**
	 * <i>native declaration : clCpmExtApi.h:277</i><br>
	 * Conversion Error : struct ClNameT {<br>
	 * 	unsigned short length;<br>
	 * 	char[256] value;<br>
	 * }
	 */
	/**
	 * <i>native declaration : clCpmExtApi.h:300</i><br>
	 * Conversion Error : struct ClNameT {<br>
	 * 	unsigned short length;<br>
	 * 	char[256] value;<br>
	 * }
	 */
	/**
	 * Original signature : <code>ClRcT clCpmNodeConfigSet(ClCpmNodeConfigT*)</code><br>
	 * <i>native declaration : clCpmExtApi.h:302</i>
	 */
	int clCpmNodeConfigSet(ClCpmNodeConfigT nodeConfig);
	/**
	 * Original signature : <code>ClRcT clCpmNodeConfigGet(const ClCharT*, ClCpmNodeConfigT*)</code><br>
	 * <i>native declaration : clCpmExtApi.h:304</i><br>
	 * use the safer methods {@link #clCpmNodeConfigGet(java.nio.ByteBuffer, clAmfClient.ClCpmNodeConfig)} and {@link #clCpmNodeConfigGet(com.sun.jna.Pointer, clAmfClient.ClCpmNodeConfig)} instead
	 */
	 
	int clCpmNodeConfigGet(String nodeName, ClCpmNodeConfigT.ByReference nodeConfig);
	/**
	 * Original signature : <code>ClRcT clCpmNodeConfigGet(const ClCharT*, ClCpmNodeConfigT*)</code><br>
	 * <i>native declaration : clCpmExtApi.h:304</i>
	 */
	//int clCpmNodeConfigGet(ByteBuffer nodeName, ClCpmNodeConfig nodeConfig);
	/**
	 * Original signature : <code>ClRcT clCpmCompConfigSet(ClIocNodeAddressT, ClCharT*, ClCharT*, __declspec(property) ClAmsCompPropertyT, ClUint64T)</code><br>
	 * <i>native declaration : clCpmExtApi.h:306</i><br>
	 *  use the safer methods {@link #clCpmCompConfigSet(int, java.nio.ByteBuffer, java.nio.ByteBuffer, int, long)} and {@link #clCpmCompConfigSet(int, com.sun.jna.Pointer, com.sun.jna.Pointer, int, long)} instead
	 */
	
	int clCpmCompConfigSet(int node, String name, String instantiateCommand, int ClAmsCompPropertyT1, long mask);
	/**
	 * Original signature : <code>ClRcT clCpmCompConfigSet(ClIocNodeAddressT, ClCharT*, ClCharT*, __declspec(property) ClAmsCompPropertyT, ClUint64T)</code><br>
	 * <i>native declaration : clCpmExtApi.h:306</i>
	 */
	//int clCpmCompConfigSet(int node, ByteBuffer name, ByteBuffer instantiateCommand, int ClAmsCompPropertyT1, long mask);
	/**
	 * Original signature : <code>ClRcT clCpmComponentFailureReportWithCookie(ClCpmHandleT, const ClNameT*, ClUint64T, ClTimeT, ClAmsLocalRecoveryT, ClUint32T)</code><br>
	 * <i>native declaration : clCpmExtApi.h:310</i>
	 */
	int clCpmComponentFailureReportWithCookie(long cpmHandle, String pCompName, long instantiateCookie, long errorDetectionTime, int recommendedRecovery, int alarmHandle);
	/**
	 * Original signature : <code>ClRcT clCpmTargetSlotInfoGet(const ClCharT*, ClIocNodeAddressT, ClTargetSlotInfoT*)</code><br>
	 * <i>native declaration : clCpmExtApi.h:318</i><br>
	 * use the safer methods {@link #clCpmTargetSlotInfoGet(java.nio.ByteBuffer, int, clAmfClient.ClTargetSlotInfo)} and {@link #clCpmTargetSlotInfoGet(com.sun.jna.Pointer, int, clAmfClient.ClTargetSlotInfo)} instead
	 */
	
	int clCpmTargetSlotInfoGet(String name, int addr, ClTargetSlotInfoT.ByReference slotInfo);
	/**
	 * Original signature : <code>ClRcT clCpmTargetSlotInfoGet(const ClCharT*, ClIocNodeAddressT, ClTargetSlotInfoT*)</code><br>
	 * <i>native declaration : clCpmExtApi.h:318</i>
	 */
	//int clCpmTargetSlotInfoGet(ByteBuffer name, int addr, ClTargetSlotInfo slotInfo);
	/**
	 * Original signature : <code>ClRcT clCpmTargetInfoGet(ClTargetInfoT*)</code><br>
	 * <i>native declaration : clCpmExtApi.h:321</i>
	 */
	int clCpmTargetInfoGet(ClTargetSlotInfoT.ByReference targetInfo);
	/**
	 * Original signature : <code>ClRcT clCpmTargetSlotListGet(ClTargetSlotInfoT*, ClUint32T*)</code><br>
	 * <i>native declaration : clCpmExtApi.h:324</i><br>
	 *  use the safer methods {@link #clCpmTargetSlotListGet(clAmfClient.ClTargetSlotInfo, java.nio.IntBuffer)} and {@link #clCpmTargetSlotListGet(clAmfClient.ClTargetSlotInfo, com.sun.jna.ptr.IntByReference)} instead
	 */
	
	int clCpmTargetSlotListGet(ClTargetSlotInfoT.ByReference slotInfo, IntByReference numSlots);
	/**
	 * Original signature : <code>ClRcT clCpmTargetSlotListGet(ClTargetSlotInfoT*, ClUint32T*)</code><br>
	 * <i>native declaration : clCpmExtApi.h:324</i>
	 */
	//int clCpmTargetSlotListGet(ClTargetSlotInfo slotInfo, IntBuffer numSlots);
	/**
	 * Original signature : <code>ClRcT clCpmTargetVersionGet(ClCharT*, ClUint32T)</code><br>
	 * <i>native declaration : clCpmExtApi.h:327</i><br>
	 *  use the safer methods {@link #clCpmTargetVersionGet(java.nio.ByteBuffer, int)} and {@link #clCpmTargetVersionGet(com.sun.jna.Pointer, int)} instead
	 */
	
	int clCpmTargetVersionGet(String aspVersion, int maxBytes);
	/**
	 * Original signature : <code>ClRcT clCpmTargetVersionGet(ClCharT*, ClUint32T)</code><br>
	 * <i>native declaration : clCpmExtApi.h:327</i>
	 */
	//int clCpmTargetVersionGet(ByteBuffer aspVersion, int maxBytes);
	/**
	 * Original signature : <code>ClBoolT clCpmIsSCCapable()</code><br>
	 * <i>native declaration : clCpmExtApi.h:330</i>
	 */
	short clCpmIsSCCapable();
	/*public static class ClCpmHealthCheckCallbackT extends PointerType {
		public ClCpmHealthCheckCallbackT(Pointer address) {
			super(address);
		}
		public ClCpmHealthCheckCallbackT() {
			super();
		}
	};*/
	/*public static class ClCorMOIdT extends PointerType {
		public ClCorMOIdT(Pointer address) {
			super(address);
		}
		public ClCorMOIdT() {
			super();
		}
	};*/
}
